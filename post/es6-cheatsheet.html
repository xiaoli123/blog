<!DOCTYPE html>
<html lang="en">
<head>
  <!-- content-Type -->
<meta charset="utf-8">


<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="renderer" content="webkit|ie-comp|ie-stand">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="language" content="en">
<meta name="robots" content="all">


<meta content="yes" name="apple-mobile-web-app-capable">
<meta content="black" name="apple-mobile-web-app-status-bar-style">
<meta content="telephone=no" name="format-detection">
<meta content="email=no" name="format-detection">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



<meta name="author" content="theme.author, theme.email">
<meta name="reply-to" content="theme.email">
<meta name="owner" content="theme.author">




<meta name="google-site-verification" content="UA-78049587-1" />




<meta name="baidu-site-verification" content="fRBucd9VmI" />




<meta name="baidu-gxt-verify-token" content="ca8f032797b876ef3be37c3d492168a0" />




<meta name="description" content="hello word! 😺" />




<meta name="keywords" content="JavaScript," />


<meta name="description" content="tip原文 https://github.com/DrkSephy/es6-cheatsheet


ES6 手册这篇手册包含了 ES2015(ES6) 的使用小技巧、最佳实践以及可以给你每天的工作参考的代码片段。
内容列表
var 和 let/const 的比较
用块级作用域代替 IIFES
箭头函数
字符串
解构
模块
参数
类 Classes
Symbols
Maps
WeakMaps
Pr">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6 手册">
<meta property="og:url" content="http://qiutc.me/post/es6-cheatsheet.html">
<meta property="og:site_name" content="阿城的blog">
<meta property="og:description" content="tip原文 https://github.com/DrkSephy/es6-cheatsheet


ES6 手册这篇手册包含了 ES2015(ES6) 的使用小技巧、最佳实践以及可以给你每天的工作参考的代码片段。
内容列表
var 和 let/const 的比较
用块级作用域代替 IIFES
箭头函数
字符串
解构
模块
参数
类 Classes
Symbols
Maps
WeakMaps
Pr">
<meta property="og:image" content="http://qiutc.me/img/es6.jpg">
<meta property="og:updated_time" content="2016-07-30T09:03:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6 手册">
<meta name="twitter:description" content="tip原文 https://github.com/DrkSephy/es6-cheatsheet


ES6 手册这篇手册包含了 ES2015(ES6) 的使用小技巧、最佳实践以及可以给你每天的工作参考的代码片段。
内容列表
var 和 let/const 的比较
用块级作用域代替 IIFES
箭头函数
字符串
解构
模块
参数
类 Classes
Symbols
Maps
WeakMaps
Pr">






  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.0.1" />






<link href="http://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.0.1"/>


<script>
(function(){
  var bp = document.createElement('script');
  bp.src = '//push.zhanzhang.baidu.com/push.js';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script>

  <title> ES6 手册 </title>
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-78049587-1', 'auto');
  ga('send', 'pageview');
</script>



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?47d302b006bf28a09c22990da53cd3da";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



</head>
<body lang="zh-Hans">

  <!--[if lte IE 9]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->


  <div class="another-theme layout">

    
<header class="header" id="header" style="background: url(/img/es6-cheatsheet.jpg) center / cover">

  <div class="header-cont">
    <div class="text-area">
      
        <h1 class="title"> ES6 手册 </h1>

        
        <div class="post-meta">
          <div class="post-time">
            发表于
            <time  datetime="2016-07-27T09:05:05+08:00" content="2016-07-27">
              2016-07-27
            </time>
          </div>

          
            <div class="post-category" >
              
                <span>
                  <a href="/categories#JavaScript" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                

              
            </div>
          

          
            
              <span class="post-comments-count">
                <a href="/post/es6-cheatsheet.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="post/es6-cheatsheet.html" itemprop="commentsCount"></span>
                </a>
              </span>
            
          
        </div>
        
      
    </div>
    <!-- Navigation -->
    
    <nav class="navigation clearfix" id="navigation">
      
        
        <a class="nav-link" href="/" rel="section">
          首页
        </a>
      
        
        <a class="nav-link" href="/categories" rel="section">
          分类
        </a>
      
        
        <a class="nav-link" href="/tags" rel="section">
          标签
        </a>
      
        
        <a class="nav-link" href="/about" rel="section">
          关于
        </a>
      
    </nav>
    
  </div>
  <div class="mask"></div>
</header>


    <main class="container">

      

  <article class="post-article post-type-normal post" itemscope>

    <div class="post-body">

      <div class="content markdown-body"><h1 id="tip">tip</h1><p>原文 <a href="https://github.com/DrkSephy/es6-cheatsheet" target="_blank" rel="external">https://github.com/DrkSephy/es6-cheatsheet</a></p>
<hr>
<p><img src="/img/es6.jpg" alt="es6"></p>
<h1 id="ES6_手册">ES6 手册</h1><p>这篇手册包含了 ES2015(ES6) 的使用小技巧、最佳实践以及可以给你每天的工作参考的代码片段。</p>
<h2 id="内容列表">内容列表</h2><ul>
<li><a href="#var_和_let/const_的比较">var 和 let/const 的比较</a></li>
<li><a href="#用块级作用域代替_IIFES">用块级作用域代替 IIFES</a></li>
<li><a href="#箭头函数">箭头函数</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#解构">解构</a></li>
<li><a href="#模块">模块</a></li>
<li><a href="#参数">参数</a></li>
<li><a href="#类_Classes">类 Classes</a></li>
<li><a href="#Symbols">Symbols</a></li>
<li><a href="#Maps">Maps</a></li>
<li><a href="#WeakMaps">WeakMaps</a></li>
<li><a href="#Promises">Promises</a></li>
<li><a href="#Generators_生成器">Generators 生成器</a></li>
<li><a href="#Async_Await">Async Await</a></li>
<li><a href="#Getter/Setter_函数">Getter/Setter 函数</a></li>
</ul>
<h2 id="var_和_let/const_的比较">var 和 let/const 的比较</h2><blockquote>
<p>除了 <code>var</code> ，我们现在还可以使用两个新的标示符来定义一个变量 —— <code>let</code> 和 <code>const</code>。和 <code>var</code> 不一样的是，<code>let</code> 和 <code>const</code> 不存在变量提升。</p>
</blockquote>
<p>使用 <code>var</code> 的栗子：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> snack = <span class="string">'Meow Mix'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFood</span><span class="params">(food)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (food) &#123;</span><br><span class="line">        <span class="keyword">var</span> snack = <span class="string">'Friskies'</span>;</span><br><span class="line">        <span class="keyword">return</span> snack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> snack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFood(<span class="literal">false</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>当我们用 <code>let</code> 代替 <code>var</code> 的时候，观察会发生什么：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> snack = <span class="string">'Meow Mix'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFood</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (food) &#123;</span><br><span class="line">        <span class="keyword">let</span> snack = <span class="string">'Friskies'</span>;</span><br><span class="line">        <span class="keyword">return</span> snack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> snack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFood(<span class="literal">false</span>); <span class="comment">// 'Meow Mix'</span></span><br></pre></td></tr></table></figure></p>
<p>当我们重构使用 <code>var</code> 的老代码的时候应该注意上面的变化。盲目地使用 <code>let</code> 替换 <code>var</code> 可能会出现出乎意料的情况。</p>
<blockquote>
<p><strong>注意</strong>： <code>let</code> 和 <code>const</code> 是块级作用域，因此在变量未被定义之前使用它会产生一个 <code>ReferenceError</code>。</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x); <span class="regexp">//</span> <span class="attribute">ReferenceError</span>: x <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br><span class="line">let x = <span class="string">'hi'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>最佳实践</strong>： 在遗留代码中放弃使用 <code>var</code> 声明意味着需要很小心地重构；在新的项目代码中，使用 <code>let</code> 声明一个可以改变的变量，用 <code>const</code> 声明一个不能被重新赋值的变量。</p>
</blockquote>
<h2 id="用块级作用域代替_IIFES">用块级作用域代替 IIFES</h2><blockquote>
<p><strong>函数立即执行表达式</strong> 的通常用途是创造一个内部的作用域，在 ES6 中，我们能够创造一个块级作用域而不仅限于函数作用域：</p>
</blockquote>
<p>IIFES：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> food = <span class="string">'Meow Mix'</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(food); <span class="comment">// Reference Error</span></span><br></pre></td></tr></table></figure></p>
<p>使用 ES6 的块级作用域：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> food = <span class="string">'Meow Mix'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(food); <span class="comment">// Reference Error</span></span><br></pre></td></tr></table></figure></p>
<h2 id="箭头函数">箭头函数</h2><p>我们经常需要给回调函数维护一个词法作用域的上下文 <code>this</code>。<br>看看这个栗子：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> <span class="params">(character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + character; <span class="comment">// Cannot read property 'name' of undefined</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一个常用的解决办法是把 <code>this</code> 存在一个变量中：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// Store the context of this</span></span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> <span class="params">(character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> that.name + character;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以传递一个合适的 <code>this</code> 上下文：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> <span class="params">(character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + character;</span><br><span class="line">    &#125;, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们还可以绑定上下文：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> Person(<span class="keyword">name</span>) &#123;</span><br><span class="line">    this.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span></span> (arr) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span></span> (<span class="type">character</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> this.<span class="keyword">name</span> + <span class="type">character</span>;</span><br><span class="line">    &#125;.<span class="keyword">bind</span>(this));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用 <strong>箭头函数</strong>，<code>this</code> 将不会受到影响，并且我们可以重写上面的函数：<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span></span> Person(<span class="keyword">name</span>) &#123;</span><br><span class="line">    this.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span></span> (arr) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="type">character</span> =&gt; this.<span class="keyword">name</span> + <span class="type">character</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>最佳实践</strong>：当你需要维护一个 <code>this</code> 上下文的时候使用 <strong>箭头函数</strong>。</p>
</blockquote>
<p>在我们写一个函数的时候，箭头函数更加简洁并且可以很简单地返回一个值：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> squares = arr.map(<span class="function"><span class="keyword">function</span> <span class="params">(x)</span> </span>&#123; <span class="keyword">return</span> x * x &#125;); <span class="comment">// Function Expression</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> squares = arr.<span class="built_in">map</span>(x =&gt; x * x); <span class="comment">// Arrow Function for terser implementation</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>最佳实践</strong>：尽可能使用箭头函数代替原来的写法。</p>
</blockquote>
<h2 id="字符串">字符串</h2><p>在 ES6 中，标准库升级了很多，在这些变化中有许多新的对于字符串的函数，比如 <code>.includes()</code> 和 <code>.repeat()</code>。</p>
<h3 id="-includes(_)">.includes( )</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">string</span> = <span class="string">'food'</span>;</span><br><span class="line"><span class="built_in">var</span> substring = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line">console<span class="built_in">.</span><span class="keyword">log</span>(<span class="built_in">string</span><span class="built_in">.</span>indexOf(substring) &gt; -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>之前我们使用 <code>indexOf()</code> 函数的返回值是否 <code>&gt;-1</code> 来判断字符串是否包含某些字符串，现在我们更简单地使用 <code>.includes()</code> 来返回一个布尔值来判断：<br><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">const <span class="keyword">string</span> = <span class="string">'food'</span>;</span><br><span class="line">const <span class="keyword">substring</span> = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="keyword">log</span>(<span class="keyword">string</span>.includes(<span class="keyword">substring</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="-repeat(_)">.repeat( )</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">function <span class="keyword">repeat</span>(<span class="type">string</span>, <span class="command">count</span>) &#123;</span><br><span class="line">    var strings = [];</span><br><span class="line">    <span class="keyword">while</span>(strings.<span class="property">length</span> &lt; <span class="command">count</span>) &#123;</span><br><span class="line">        strings.push(<span class="type">string</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="command">    return</span> strings.join('');</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ES6 中，可以更简便地实现：<br><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.repeat(numberOfRepetitions)</span></span><br><span class="line"><span class="string">'meow'</span>.<span class="keyword">repeat</span><span class="comment">(3)</span>; <span class="comment">// 'meowmeowmeow'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="模版字符串">模版字符串</h3><p>使用 <strong>模版字符串</strong> 我们就可以不用对某些特殊自负进行转义处理了：<br><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">text</span> = <span class="string">"This string contains \"</span><span class="built_in">double</span> quotes\<span class="string">" which are escaped."</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="tag">`This</span> <span class="built_in">string</span> contains <span class="string">"double quotes"</span> which don't need <span class="keyword">to</span> be escaped anymore.`;</span><br></pre></td></tr></table></figure>
<p><strong>模版字符串</strong> 还支持插入，可以把变量值和字符串连接起来.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Tiger'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'My cat is named '</span> + name + <span class="string">' and is '</span> + age + <span class="string">' years old.'</span>);</span><br></pre></td></tr></table></figure></p>
<p>更简单：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'Tiger'</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`My cat is named <span class="subst">$&#123;name&#125;</span> and is <span class="subst">$&#123;age&#125;</span> years old.`</span>);</span><br></pre></td></tr></table></figure></p>
<p>在 ES5 中，需要换行时，需要这样：<br><figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">var text = (</span><br><span class="line">    <span class="symbol">'cat</span>\n' +</span><br><span class="line">    <span class="symbol">'dog</span>\n' +</span><br><span class="line">    <span class="symbol">'nickelodeon'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>或者这样：<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = [</span><br><span class="line">    <span class="string">'cat'</span>,</span><br><span class="line">    <span class="string">'dog'</span>,</span><br><span class="line">    <span class="string">'nickelodeon'</span></span><br><span class="line">].<span class="keyword">join</span>(<span class="string">'\n'</span>);</span><br></pre></td></tr></table></figure></p>
<p><strong>模版字符串</strong> 可以支持换行并且不需要额外的处理：<br><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">let text = ( <span class="escape">`c</span>at</span><br><span class="line">dog</span><br><span class="line">nickelodeon<span class="escape">`</span><br><span class="line"></span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>模版字符串</strong> 还支持表达式：<br><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> text = `The <span class="built_in">time</span> <span class="keyword">and</span> <span class="built_in">date</span> <span class="keyword">is</span> $&#123;today.toLocaleString()&#125;`;</span><br></pre></td></tr></table></figure></p>
<h2 id="解构">解构</h2><p>结构可以让我们用一个更简便的语法从一个数组或者对象（即使是深层的）中分离出来值，并存储他们。</p>
<h3 id="结构数组">结构数组</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> a</span> = arr[<span class="number">0</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span> = arr[<span class="number">1</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> c</span> = arr[<span class="number">2</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> d</span> = arr[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let [a, b, c, d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">console.<span class="built_in">log</span>(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="结构对象">结构对象</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> luke</span> = &#123; occupation: 'jedi', father: 'anakin' &#125;;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> occupation</span> = luke.occupation; <span class="comment">// 'jedi'</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> father</span> = luke.father; <span class="comment">// 'anakin'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> luke = &#123; occupation: <span class="string">'jedi'</span>, father: <span class="string">'anakin'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;occupation, father&#125; = luke;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(occupation); <span class="comment">// 'jedi'</span></span><br><span class="line"><span class="built_in">console</span>.log(father); <span class="comment">// 'anakin'</span></span><br></pre></td></tr></table></figure>
<h2 id="模块">模块</h2><p>在 ES6 之前，我们使用 <code>Browserify</code> 这样的库来创建客户端的模块化，在 <code>node.js</code> 中使用 <code>require</code>。<br>在 ES6 中，我们可以直接使用所有类型的模块化（AMD 和 CommonJS）。</p>
<h3 id="使用_CommonJS_的出口">使用 CommonJS 的出口</h3><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> &#123; foo: 'bar' &#125;;</span><br><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> ['foo', 'bar'];</span><br><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">()</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用_ES6_的出口">使用 ES6 的出口</h3><p>在 ES6 中我们可以暴漏多个值，使用 <code>Exports</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> name = <span class="string">'David'</span>;</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> age  = <span class="number">25</span>;​​</span><br></pre></td></tr></table></figure></p>
<p>或者暴露一个对象列表：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumTwo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumThree</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; sumTwo, sumThree &#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们还可以暴露函数、对象和其他的值，通过简单地使用 <code>export</code> 这个关键字：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sumTwo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sumThree</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们还可以绑定一个默认的输出：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumTwo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumThree</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> api = &#123;</span><br><span class="line">    sumTwo,</span><br><span class="line">    sumThree</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> api;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Which is the same as</span><br><span class="line"> * export &#123; api as default &#125;;</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>最佳实践</strong>：总是在模块的最后面使用 <code>export default</code> 方法，这可以让暴露的东西更加清晰并且可以节省时间去找出暴漏出来值的名字。尤其如此，在 CommonJS 中通常的实践就是暴露一个简单的值或者对象。坚持这种模式，可以让我们的代码更加可读，并且在 ES6 和 CommonJS 模块之间更好地兼容。</p>
</blockquote>
<h3 id="ES6_中的导入">ES6 中的导入</h3><p>在 ES6 中同样提供了多样的导入方式，我们可以这么导入一个整个文件：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'underscore'</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要着重注意的一点是简单的导入整个文件会在那个文件的顶部执行所有的代码</p>
</blockquote>
<p>和 Python 中类似，我们可以命名导入的值：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sumTwo, sumThree &#125; <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br></pre></td></tr></table></figure></p>
<p>我们还可以重命名导入：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    sumTwo <span class="keyword">as</span> addTwoNumbers,</span><br><span class="line">    sumThree <span class="keyword">as</span> sumThreeNumbers</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br></pre></td></tr></table></figure></p>
<p>另外，我们可以导入所有的东西（整体加载）：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> util <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们可以从一个模块中导入一个值的列表：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> additionUtil <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; sumTwo, sumThree &#125; = additionUtil;</span><br></pre></td></tr></table></figure></p>
<p>可以像这样导入默认绑定的输出：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br><span class="line">// Same <span class="keyword">as</span>: <span class="keyword">import</span> &#123; default <span class="keyword">as</span> api &#125; <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br></pre></td></tr></table></figure></p>
<p>虽然最好保持出口的简单，但如果需要的话我们有时可以混合默认的进口和混合进口。当我们这样出口的时候：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foos.js</span></span><br><span class="line"><span class="literal">export</span> &#123; foo <span class="literal">as</span> <span class="keyword">default</span>, foo1, foo2 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以这样导入它们：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo, &#123; foo1, foo2 &#125; <span class="keyword">from</span> <span class="string">'foos'</span>;</span><br></pre></td></tr></table></figure></p>
<p>当我们用 commonjs 的语法导入一个模块的出口时（比如 React），我们可以这样做：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; Component, PropTypes &#125; = React;</span><br></pre></td></tr></table></figure></p>
<p>还有更精简的写法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong>：导出的值是动态引用的，而不是拷贝。因此，在一个模块中改变一个变量的绑定将影响输出模块中的值。应该避免改变这些导出值的公共接口。（原文这里我觉得有误）</p>
</blockquote>
<h2 id="参数">参数</h2><p>在 ES5 中，在函数中我们需要各种操作去处理 <strong><em>默认参数</em></strong>、<strong><em>不定参数</em></strong> 和 <strong><em>重命名参数</em></strong> 等需求，在 ES6 中我们可以使用更简洁的语法完成这些需求：</p>
<h3 id="默认参数">默认参数</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwoNumbers</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    x = x || <span class="number">0</span>;</span><br><span class="line">    y = y || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 中，函数的参数可以支持设置默认值：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwoNumbers</span><span class="params">(x=0, y=0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addTwoNumbers(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 6</span></span><br><span class="line">addTwoNumbers(<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line">addTwoNumbers(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h3 id="rest_参数">rest 参数</h3><p>在 ES5 中，我们需要这么处理不定参数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 <strong>rest</strong> ，我们就可以处理不确定数目的参数：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArguments</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (let arg of args) &#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="命名参数">命名参数</h3><p>在 ES5 中是使用配置对象的模式来处理命名参数，jQuery 中的使用：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeCanvas</span><span class="params">(options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> height = options.height || <span class="number">600</span>;</span><br><span class="line">    <span class="keyword">var</span> width  = options.width  || <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">var</span> lineStroke = options.lineStroke || <span class="string">'black'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以利用解构的一个函数的形参实现相同的功能：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeCanvas</span><span class="params">(</span><br><span class="line">    &#123; height=600, width=400, lineStroke=<span class="string">'black'</span>&#125;)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use variables height, width, lineStroke here</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们想使整个值可选择，我们可以结构将一个空的对象：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeCanvas</span><span class="params">(</span><br><span class="line">    &#123; height=600, width=400, lineStroke=<span class="string">'black'</span>&#125; = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="展开操作">展开操作</h3><p>在 ES5 中，我们可以 <code>apply</code> <code>Math.max</code> 方法来获得一个数组中的最大值：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Math.max.apply(null, [-<span class="number">1</span>, <span class="number">100</span>, <span class="number">9001</span>, -<span class="number">32</span>]); <span class="comment">// 9001</span></span><br></pre></td></tr></table></figure></p>
<p>在 ES6 中，我们可以通过展开操作把一个数组的值作为参数传递给一个函数：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Math.max(...[-<span class="number">1</span>, <span class="number">100</span>, <span class="number">9001</span>, -<span class="number">32</span>]); <span class="comment">// 9001</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以更简洁地使用这个语法来合并数组：<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="atom">let</span> <span class="atom">cities</span> = [<span class="string">'San Francisco'</span>, <span class="string">'Los Angeles'</span>];</span><br><span class="line"><span class="atom">let</span> <span class="atom">places</span> = [<span class="string">'Miami'</span>, ...<span class="atom">cities</span>, <span class="string">'Chicago'</span>]; // [<span class="string">'Miami'</span>, <span class="string">'San Francisco'</span>, <span class="string">'Los Angeles'</span>, <span class="string">'Chicago'</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="类_Classes">类 Classes</h2><p>在 ES6 之前，我们通过构造函数来创造一个类，并且通过原型来扩展属性：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, gender)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name   = name;</span><br><span class="line">    <span class="keyword">this</span>.age    = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.incrementAge = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age += <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后可以这样继承类：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Personal</span>(<span class="params">name, age, gender, occupation, hobby</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age, gender);</span><br><span class="line">    <span class="keyword">this</span>.occupation = occupation;</span><br><span class="line">    <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Personal.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Personal.prototype.constructor = Personal;</span><br><span class="line">Personal.prototype.incrementAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.prototype.incrementAge.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.age += <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在 ES6 中，提供了更多的语法糖，可以直接创造一个类：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(name, age, gender) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name   = name;</span><br><span class="line">        <span class="keyword">this</span>.age    = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incrementAge() &#123;</span><br><span class="line">      <span class="keyword">this</span>.age += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>extends</code> 关键字来继承一个类：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Personal</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    constructor(name, age, gender, occupation, hobby) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age, gender);</span><br><span class="line">        <span class="keyword">this</span>.occupation = occupation;</span><br><span class="line">        <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incrementAge() &#123;</span><br><span class="line">        <span class="keyword">super</span>.incrementAge();</span><br><span class="line">        <span class="keyword">this</span>.age += <span class="number">20</span>;</span><br><span class="line">        console.log(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>最佳实践</strong>：虽然使用 ES6 的语法创造类的时候，js引擎是如何实现类以及如何操作原型是令人费解的，但是未来对初学者来说这是一个好的开始，同时也可以让我们写更简洁的代码。</p>
</blockquote>
<h2 id="Symbols">Symbols</h2><p><code>Symbols</code> 在 ES6 之前就已经存在，但是我们现在可以直接使用一个开发的接口了。<code>Symbols</code> 是不可改变并且是第一无二的，可以在任意哈希中作一个key。</p>
<h3 id="Symbol()">Symbol()</h3><p>调用 <code>Symbol()</code> 或者 <code>Symbol(description)</code> 可以创造一个第一无二的符号，但是在全局是看不到的。<code>Symbol()</code> 的一个使用情况是给一个类或者命名空间打上补丁，但是可以确定的是你不会去更新它。比如，你想给 <code>React.Component</code> 类添加一个 <code>refreshComponent</code> 方法，但是可以确定的是你不会在之后更新这个方法：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const refreshComponent = Symbol();</span><br><span class="line"></span><br><span class="line">React.Component.prototype[refreshComponent] = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Symbol-for(key)">Symbol.for(key)</h3><p><code>Symbol.for(key)</code> 同样会创造一个独一无二并且不可改变的 Symbol，但是它可以全局看到，两个相同的调用 <code>Symbol.for(key)</code> 会返回同一个 <code>Symbol</code> 类：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>对于 Symbols 的普遍用法（尤其是<code>Symbol.for(key)</code>）是为了协同性。它可以通过在一个第三方插件中已知的接口中对象中的参数中寻找用 Symbol 成员来实现，比如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reader</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> specialRead = <span class="built_in">Symbol</span>.for(<span class="string">'specialRead'</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj[specialRead]) &#123;</span><br><span class="line">        <span class="keyword">const</span> reader = obj[specialRead]();</span><br><span class="line">        <span class="comment">// do something with reader</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'object cannot be read'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在另一个库中：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> specialRead = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'specialRead'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeReadableType</span> </span>&#123;</span><br><span class="line">    [specialRead]() &#123;</span><br><span class="line">        <span class="keyword">const</span> reader = createSomeReaderFrom(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> reader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Maps">Maps</h2><p>Maps 在 JavaScript 中是一个非常必须的数据结构，在 ES6 之前，我们通过对象来实现哈希表：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">map</span> = <span class="built_in">new</span> Object();</span><br><span class="line"><span class="keyword">map</span>[key1] = <span class="string">'value1'</span>;</span><br><span class="line"><span class="keyword">map</span>[key2] = <span class="string">'value2'</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是它并不能防止我们偶然地用一些特殊的属性名重写函数：<br><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">&gt; getOwnProperty(&#123; <span class="attribute">hasOwnProperty</span>: <span class="string">'Hah, overwritten'</span>&#125;, <span class="string">'Pwned'</span>);</span><br><span class="line">&gt; <span class="attribute">TypeError</span>: Property <span class="string">'hasOwnProperty'</span> <span class="keyword">is</span> <span class="keyword">not</span> a <span class="keyword">function</span></span><br></pre></td></tr></table></figure></p>
<p>实际上 <strong>Maps</strong> 允许我们对值进行 <code>set</code>、<code>get</code> 和 <code>search</code> 操作：<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>();</span><br><span class="line">&gt; <span class="built_in">map</span><span class="built_in">.</span><span class="built_in">set</span>(<span class="string">'name'</span>, <span class="string">'david'</span>);</span><br><span class="line">&gt; <span class="built_in">map</span><span class="built_in">.</span>get(<span class="string">'name'</span>); <span class="comment">// david</span></span><br><span class="line">&gt; <span class="built_in">map</span><span class="built_in">.</span>has(<span class="string">'name'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Maps</strong> 更令人惊奇的部分就是它不仅限于使用字符串作为 key，还可以用其他任何类型的数据作为 key：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'name'</span>, <span class="string">'david'</span>],</span><br><span class="line">    [<span class="literal">true</span>, <span class="string">'false'</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">    [&#123;&#125;, <span class="string">'object'</span>],</span><br><span class="line">    [<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="string">'function'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> key);</span><br><span class="line">    <span class="comment">// &gt; string, boolean, number, object, function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong>：但我们使用 <code>map.get()</code> 方法去测试相等时，如果在 Maps 中使用 函数 或者 对象 等非原始类型值的时候测试将不起作用，所以我们应该使用 Strings, Booleans 和 Numbers 这样的原始类型的值。</p>
</blockquote>
<p>我们还可以使用 <code>.entries()</code> 来遍历迭代：<br><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, <span class="keyword">value</span>] <span class="keyword">of</span> <span class="keyword">map</span>.entries()) &#123;</span><br><span class="line">    console.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="WeakMaps">WeakMaps</h2><p>在 ES6 之前，为了存储私有变量，我们有各种各样的方法去实现，其中一种方法就是用命名约定：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(age) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _incrementAge() &#123;</span><br><span class="line">        <span class="keyword">this</span>._age += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是命名约定在代码中仍然会令人混淆并且并不会真正的保持私有变量不被访问。现在，我们可以使用 <strong>WeakMaps</strong>  来存储变量：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _age = <span class="keyword">new</span> WeakMap();</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(age) </span>&#123;</span><br><span class="line">        _age.set(<span class="keyword">this</span>, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incrementAge() &#123;</span><br><span class="line">        <span class="keyword">let</span> age = _age.get(<span class="keyword">this</span>) + <span class="number">1</span>;</span><br><span class="line">        _age.set(<span class="keyword">this</span>, age);</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">50</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Midlife crisis'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 WeakMaps 存储变量很酷的一件事是它的 key 他不需要属性名称，可以使用 <code>Reflect.ownKeys()</code> 来查看这一点：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="number">50</span>);</span><br><span class="line">&gt; person.incrementAge(); <span class="comment">// 'Midlife crisis'</span></span><br><span class="line">&gt; Reflect.ownKeys(person); <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p>
<p>一个更实际的实践就是可以 WeakMaps 储存 DOM 元素，而不会污染元素本身：<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> WeakMap();</span><br><span class="line"><span class="keyword">let</span> el  = document<span class="built_in">.</span>getElementById(<span class="string">'someElement'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store a weak reference to the element with a key</span></span><br><span class="line"><span class="built_in">map</span><span class="built_in">.</span><span class="built_in">set</span>(el, <span class="string">'reference'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Access the value of the element</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="built_in">map</span><span class="built_in">.</span>get(el); <span class="comment">// 'reference'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove the reference</span></span><br><span class="line">el<span class="built_in">.</span>parentNode<span class="built_in">.</span>removeChild(el);</span><br><span class="line">el = <span class="built_in">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map is empty, since the element is destroyed</span></span><br></pre></td></tr></table></figure></p>
<p>如上所示，当一个对象被垃圾回收机制销毁的时候， WeakMap 将会自动地一处关于这个对象地键值对。</p>
<blockquote>
<p><strong>注意</strong>：为了进一步说明这个例子的实用性，可以考虑 jQuery 是如何实现缓存一个对象相关于对引用地 DOM 元素对象。使用 jQuery ，当一个特定地元素一旦在 document 中移除的时候，jQuery 会自动地释放内存。总体来说，jQuery 在任何 dom 库中都是很有用的。</p>
</blockquote>
<h2 id="Promises">Promises</h2><p>Promises 可以让我们远离平行的代码（回调地狱）：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">func1<span class="list">(<span class="keyword">function</span> <span class="list">(<span class="keyword">value1</span>)</span> &#123;</span><br><span class="line">    func2<span class="list">(<span class="keyword">value1</span>, function <span class="list">(<span class="keyword">value2</span>)</span> &#123;</span><br><span class="line">        func3<span class="list">(<span class="keyword">value2</span>, function <span class="list">(<span class="keyword">value3</span>)</span> &#123;</span><br><span class="line">            func4<span class="list">(<span class="keyword">value3</span>, function <span class="list">(<span class="keyword">value4</span>)</span> &#123;</span><br><span class="line">                func5<span class="list">(<span class="keyword">value4</span>, function <span class="list">(<span class="keyword">value5</span>)</span> &#123;</span><br><span class="line">                    // Do something with value <span class="number">5</span></span><br><span class="line">                &#125;)</span><span class="comment">;</span></span><br><span class="line">            &#125;)</span><span class="comment">;</span></span><br><span class="line">        &#125;)</span><span class="comment">;</span></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>转变成垂直代码：<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">func<span class="number">1</span>(<span class="keyword">value</span><span class="number">1</span>)</span><br><span class="line">    .<span class="keyword">then</span>(func<span class="number">2</span>)</span><br><span class="line">    .<span class="keyword">then</span>(func<span class="number">3</span>)</span><br><span class="line">    .<span class="keyword">then</span>(func<span class="number">4</span>)</span><br><span class="line">    .<span class="keyword">then</span>(func<span class="number">5</span>, <span class="keyword">value</span><span class="number">5</span> =&gt; &#123;</span><br><span class="line">        <span class="comment">// Do something with value 5</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>在 ES6 之前，我们使用 <a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">bluebird</a> 或者 <a href="https://github.com/kriskowal/q" target="_blank" rel="external">q</a>，现在我们可以使用原生的 <strong>Promise</strong> 了。<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span></span><br><span class="line">    reject(<span class="keyword">new</span> Error(<span class="string">'Failed to fulfill Promise'</span>)))</span><br><span class="line">        .<span class="keyword">catch</span>(reason =&gt; <span class="built_in">console</span>.log(reason));</span><br></pre></td></tr></table></figure></p>
<p>我们有两个处理器，<code>resolve</code>（当Promise是 <code>fulfilled</code> 时的回调）和 <code>reject</code>（当Promise是 <code>rejected</code> 时的回调）：。</p>
<blockquote>
<p><strong>Promises的好处</strong>：对错误的处理使用一些列回调会使代码很混乱，使用 Promise ，我看可以清晰的让错误冒泡并且在合适的时候处理它，甚至，在 Promise 确定了  resolved/rejected 之后，他的值是不可改变的－－它从来不会变化。</p>
</blockquote>
<p>这是使用 Promise 的一个实际的栗子：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">var request = require<span class="list">(<span class="quoted">'request</span>')</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">return new Promise<span class="list">(<span class="list">(<span class="keyword">resolve</span>, reject)</span> =&gt; &#123;</span><br><span class="line">  request.get<span class="list">(<span class="keyword">url</span>, <span class="list">(<span class="keyword">error</span>, response, body)</span> =&gt; &#123;</span><br><span class="line">    if <span class="list">(<span class="keyword">body</span>)</span> &#123;</span><br><span class="line">        resolve<span class="list">(<span class="keyword">JSON</span>.parse<span class="list">(<span class="keyword">body</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve<span class="list">(&#123;&#125;)</span><span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>我们还可以使用 <code>Promise.all()</code> 来 <code>并行</code> 处理多个异步函数：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">let urls = [</span><br><span class="line">  <span class="string">'/api/commits'</span>,</span><br><span class="line">  <span class="string">'/api/issues/opened'</span>,</span><br><span class="line">  <span class="string">'/api/issues/assigned'</span>,</span><br><span class="line">  <span class="string">'/api/issues/completed'</span>,</span><br><span class="line">  <span class="string">'/api/issues/comments'</span>,</span><br><span class="line">  <span class="string">'/api/pullrequests'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let promises = urls.map(<span class="function"><span class="params">(url)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    $.ajax(&#123; <span class="attribute">url</span>: url &#125;)</span><br><span class="line">      .done(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="params">(results)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> Do something with results <span class="keyword">of</span> all our promises</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Generators_生成器">Generators 生成器</h2><p>就像 Promises  可以帮我们避免回调地狱，Generators 可以帮助我们让代码风格更整洁－－用同步的代码风格来写异步代码，它本质上是一个可以暂停计算并且可以随后返回表达式的值的函数。</p>
<p>一个简单的栗子使用 generators：<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">function* sillyGenerator() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var generator = sillyGenerator();</span><br><span class="line">&gt; console.log(generator.<span class="keyword">next</span>()); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="number">1</span>, <span class="symbol">done:</span> <span class="literal">false</span> &#125;</span><br><span class="line">&gt; console.log(generator.<span class="keyword">next</span>()); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="number">2</span>, <span class="symbol">done:</span> <span class="literal">false</span> &#125;</span><br><span class="line">&gt; console.log(generator.<span class="keyword">next</span>()); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="number">3</span>, <span class="symbol">done:</span> <span class="literal">false</span> &#125;</span><br><span class="line">&gt; console.log(generator.<span class="keyword">next</span>()); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="number">4</span>, <span class="symbol">done:</span> <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>next</code> 可以回去到下一个 <code>yield</code> 返回的值，当然上面的代码是非常不自然的，我们可以利用 Generators 来用同步的方式来写异步操作：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hiding asynchronousity with Generators</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">    getJSON(url, <span class="function"><span class="keyword">function</span><span class="params">(response)</span> </span>&#123;</span><br><span class="line">        generator.next(response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 generator 函数将会返回需要的数据：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> entry1 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item1'</span>);</span><br><span class="line">    <span class="keyword">var</span> data1  = <span class="built_in">JSON</span>.parse(entry1);</span><br><span class="line">    <span class="keyword">var</span> entry2 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item2'</span>);</span><br><span class="line">    <span class="keyword">var</span> data2  = <span class="built_in">JSON</span>.parse(entry2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>yield</code>，我们可以保证 <code>entry1</code> 有 <code>data1</code> 中我们需要解析并储存的数据。</p>
<p>虽然我们可以利用 Generators 来用同步的方式来写异步操作，但是确认错误的传播变得不再清晰，我们可以在 Generators 中加上 Promise：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">        getJSON(url, resolve);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们写一个函数逐步调用 <code>next</code> 并且利用 request 方法产生一个 Promise：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterateGenerator</span><span class="params">(gen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> generator = gen();</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span><span class="params">(val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = generator.next();</span><br><span class="line">        <span class="keyword">if</span>(!ret.done) &#123;</span><br><span class="line">            ret.value.then(iterate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Generators 中加上 Promise 之后我们可以更清晰的使用 Promise 中的 <code>.catch</code> 和 <code>reject</code>来捕捉错误，让我们使用新的 Generator，和之前的还是蛮相似的：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">iterateGenerator(<span class="function"><span class="keyword">function</span>* <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> entry1 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item1'</span>);</span><br><span class="line">    <span class="keyword">var</span> data1  = <span class="built_in">JSON</span>.parse(entry1);</span><br><span class="line">    <span class="keyword">var</span> entry2 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item2'</span>);</span><br><span class="line">    <span class="keyword">var</span> data2  = <span class="built_in">JSON</span>.parse(entry2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Async_Await">Async Await</h2><p>当 ES6 真正到来的时候，<code>async await</code> 可以用更少的处理实现  Promise 和  Generators 所实现的异步处理：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    request(url, <span class="function"><span class="keyword">function</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">      resolve(body);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> getJSON();</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// NOT undefined!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure></p>
<p>在 js 引擎中，它所实现的和 Generators 其实是一样的，我更推荐在 <code>Generators + Promises</code> 之上使用 <code>async await</code>，更多的资源和使用 ES7 和 用 babel 转化可以<a href="http://masnun.com/2015/11/11/using-es7-asyncawait-today-with-babel.html" target="_blank" rel="external">看这里</a>。</p>
<h2 id="Getter/Setter_函数">Getter/Setter 函数</h2><p>ES6 已经开始实现了 <code>getter</code> 和 <code>setter</code> 函数，比如虾面这个栗子：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line"></span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(name) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Mr. '</span> + <span class="keyword">this</span>._name.toUpperCase();  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> name(newName) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newName == <span class="keyword">this</span>._name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I already have this name.'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newName) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = newName;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emp = <span class="keyword">new</span> Employee(<span class="string">"James Bond"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uses the get method in the background</span></span><br><span class="line"><span class="keyword">if</span> (emp.name) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(emp.name);  <span class="comment">// Mr. JAMES BOND</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uses the setter in the background</span></span><br><span class="line">emp.name = <span class="string">"Bond 007"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(emp.name);  <span class="comment">// Mr. BOND 007</span></span><br></pre></td></tr></table></figure></p>
<p>最新版本的浏览器也在对象中实现了 <code>getter</code> 和 <code>setter</code> 函数，我们可以使用它们来实现 <strong>计算属性</strong>，在设置和获取一个属性之前加上监听器和处理。<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'James'</span>,</span><br><span class="line">  lastName: <span class="string">'Bond'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">fullName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      console.log(<span class="string">'Getting FullName'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">set</span> <span class="title">fullName</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      console.log(<span class="string">'Setting FullName'</span>);</span><br><span class="line">      <span class="keyword">var</span> words = name.toString().split(<span class="string">' '</span>);</span><br><span class="line">      <span class="keyword">this</span>.firstName = words[<span class="number">0</span>] || <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">this</span>.lastName = words[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.fullName; <span class="comment">// James Bond</span></span><br><span class="line">person.fullName = <span class="string">'Bond 007'</span>;</span><br><span class="line">person.fullName; <span class="comment">// Bond 007</span></span><br></pre></td></tr></table></figure></p>
</div>

      <div class="post-sidebar">
  <div class="toggle-btn" id="toggle-btn">
    <i class="fa fa-reorder"></i>
  </div>
  <section class="post-toc-wrap" id="post-sidebar">
    <h2 class="toc-title">内容目录</h2>
    <div class="post-toc">
      
      
        <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#tip"><span class="nav-text">tip</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ES6_手册"><span class="nav-text">ES6 手册</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内容列表"><span class="nav-text">内容列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#var_和_let/const_的比较"><span class="nav-text">var 和 let/const 的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用块级作用域代替_IIFES"><span class="nav-text">用块级作用域代替 IIFES</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#箭头函数"><span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#-includes(_)"><span class="nav-text">.includes( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-repeat(_)"><span class="nav-text">.repeat( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模版字符串"><span class="nav-text">模版字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解构"><span class="nav-text">解构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构数组"><span class="nav-text">结构数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构对象"><span class="nav-text">结构对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块"><span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用_CommonJS_的出口"><span class="nav-text">使用 CommonJS 的出口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用_ES6_的出口"><span class="nav-text">使用 ES6 的出口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6_中的导入"><span class="nav-text">ES6 中的导入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数"><span class="nav-text">参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#默认参数"><span class="nav-text">默认参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rest_参数"><span class="nav-text">rest 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名参数"><span class="nav-text">命名参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#展开操作"><span class="nav-text">展开操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类_Classes"><span class="nav-text">类 Classes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbols"><span class="nav-text">Symbols</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol()"><span class="nav-text">Symbol()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol-for(key)"><span class="nav-text">Symbol.for(key)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maps"><span class="nav-text">Maps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WeakMaps"><span class="nav-text">WeakMaps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promises"><span class="nav-text">Promises</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generators_生成器"><span class="nav-text">Generators 生成器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Async_Await"><span class="nav-text">Async Await</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Getter/Setter_函数"><span class="nav-text">Getter/Setter 函数</span></a></li></ol></li></ol></div>
      
    </div>
  </section>
</div>


    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags#JavaScript" rel="tag">#JavaScript</a>
          
        </div>
      
      
  <style>
    .donation {
      width: 100%;
      margin-top: 2rem;
    }
    .donation .text {
      color: #333;
      font-size: .8rem;
      cursor: pointer;
      text-decoration: underline;
    }
    .donation .text:hover {
      color: rgb(63,134,181);
    }
    .donation .img-box {
      transition: all .3s;
      width: 0;
      height: 0;
      margin: 1rem auto;
      overflow: hidden;
    }
    .donation .img-box img {
      width: 100%;
      height: 100%;
    }
    .donation #donation {
      display: none;
    }
    .donation #donation:checked + .img-box {
      width: 16rem;
      height: 16rem;
    }
  </style>
  <div class="donation">
    <label class="text" for="donation">
      如果你觉得文章对你有帮助，并且想为我买一杯咖啡，点这里～
    </label>
    <input type="checkbox" name="donation" id="donation">
    <div class="img-box">
      <img src="/img/donation.png" alt="donation" />
    </div>
    </style>
  </div>


    </footer>

  </article>



      
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="post/es6-cheatsheet.html"
           data-title="ES6 手册" data-url="http://qiutc.me/post/es6-cheatsheet.html">
      </div>
    
  </div>




    </main>

    <footer class="footer clearfix">
  <div class="copyright" >
    <span>Copyright</span>
    
    &copy;  2015-
    <span itemprop="copyrightYear">2016</span>
    <span class="author" itemprop="copyrightHolder">阿城😇</span>
  </div>

  <div class="info">
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
      <span id="showDays" class="show-days"></span>
      <script>
      var birthDay = new Date('10/04/2015');
      var now = new Date();
      var duration = now.getTime() - birthDay.getTime();
      var total= Math.floor(duration / (1000 * 60 * 60 * 24));
      document.getElementById("showDays").innerHTML = "本站已运行 "+total+" 天";
      </script>
      ---
    
    <span id="busuanzi_container_site_pv">
        总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
  </div>

</footer>


  </div>

  <div class="back-top-btn" id="back-top-btn"><i class="fa fa-chevron-up"></i></div>





  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"qiutongcheng"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     




<script type="text/javascript" src="/js/main.js?v=0.0.1"></script>


</body>
</html>
