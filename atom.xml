<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[阿城的blog]]></title>
  <subtitle><![CDATA[抓啊抓啊~~~]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://qiutc.me/"/>
  <updated>2016-08-25T00:37:30.000Z</updated>
  <id>http://qiutc.me/</id>
  
  <author>
    <name><![CDATA[阿城😇]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript 中的 this !]]></title>
    <link href="http://qiutc.me/post/this-this-this-in-javascript.html"/>
    <id>http://qiutc.me/post/this-this-this-in-javascript.html</id>
    <published>2016-08-24T02:35:29.000Z</published>
    <updated>2016-08-25T00:37:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tip">tip</h1><p>首先，我知道这篇文章很无聊，无非就是关于 js 中的 this，并且也已经有千千万万的文章写过这部分内容了；</p>
<p>但是，我还是想写一篇关于 js 中的 this 的文章，算是一个总结归纳吧；（大神们可以绕行看我的其他文章😂）</p>
<p>在 js 中，this 这个上下文总是变化莫测，很多时候出现 bug 总是一头雾水，其实，只要分清楚不同的情况下如何执行就 ok 了。</p>
<h1 id="全局执行">全局执行</h1><p>首先，我们在全局环境中看看它的 this 是什么：</p>
<p>first. 浏览器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到打印出了 <code>window</code> 对象；</p>
<p>second. node：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p>可以看到打印出了 <code>global</code> 对象；</p>
<p><strong>总结</strong>：在全局作用域中它的 <code>this</code> 执行当前的全局对象（浏览器端是 <code>Window</code>，node 中是 <code>global</code>）。</p>
<h1 id="函数中执行">函数中执行</h1><h2 id="纯粹的函数调用">纯粹的函数调用</h2><p>这是最普通的函数使用方法了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，一个函数被直接调用的时候，属于全局调用，这时候它的 <code>this</code> 指向 全局对象；</p>
<h3 id="严格模式_‘use_strict’;">严格模式 ‘use strict’;</h3><p>如果在严格模式的情况下执行纯粹的函数调用，那么这里的的 <code>this</code> 并不会指向全局，而是 <code>undefined</code>，这样的做法是为了消除 js 中一些不严谨的行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>当然，把它放在一个立即执行函数中会更好，避免了污染全局：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="pi">  "use strict"</span>;</span><br><span class="line">　<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="作为对象的方法调用">作为对象的方法调用</h2><p>当一个函数被当作一个对象的方法调用的时候：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc'</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'qiutc'</span></span><br></pre></td></tr></table></figure>
<p>这时候，<code>this</code> 指向当前的这个对象；</p>
<p>当然，我们还可以这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc'</span>,</span><br><span class="line">  foo: test</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'qiutc'</span></span><br></pre></td></tr></table></figure>
<p>同样不变，因为在 js 中一切都是对象，函数也是一个对象，对于 <code>test</code> ，它只是一个函数名，函数的引用，它指向这个函数，当 <code>foo = test</code>，<code>foo</code> 同样也指向了这个函数。</p>
<p>如果把对象的方法赋值给一个变量，然后直接调用这个变量呢：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc'</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = obj.foo;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这时候 <code>this</code> 执行了全局，当我们把 <code>test = obj.foo</code> ，<code>test</code> 直接指向了一个函数的引用，这时候，其实和 <code>obj</code> 这个对象没有关系了，所以，它是被当作一个普通函数来直接调用，因此，<code>this</code> 指向全局对象。</p>
<h3 id="一些坑">一些坑</h3><p>我们经常在回调函数里面会遇到一些坑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc'</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    setTimeout(<span class="keyword">this</span>.foo, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo2();</span><br></pre></td></tr></table></figure>
<p>执行这段代码我们会发现两次打印出来的 <code>this</code> 是不一样的：</p>
<p>第一次是 <code>foo2</code> 中直接打印 <code>this</code>，这里指向 <code>obj</code> 这个对象，我们毋庸置疑；</p>
<p>但是在 <code>setTimeout</code> 中执行的 <code>this.foo</code> ，却指向了全局对象，这里不是把它当作函数的方法使用吗？这一点经常让很多初学者疑惑；<br>其实，<code>setTimeout</code> 也只是一个函数而已，函数必然有可能需要参数，我们把 <code>this.foo</code> 当作一个参数传给 <code>setTimeout</code> 这个函数，就像它需要一个 <code>fun</code> 参数，在传入参数的时候，其实做了个这样的操作 <code>fun = this.foo</code>，看到没有，这里我们直接把 <code>fun</code> 指向 <code>this.foo</code> 的引用；执行的时候其实是执行了 <code>fun()</code> 所以已经和 <code>obj</code> 无关了，它是被当作普通函数直接调用的，因此 <code>this</code> 指向全局对象。</p>
<p>这个问题是很多异步回调函数中普遍会碰到的；</p>
<h4 id="解决">解决</h4><p>为了解决这个问题，我们可以利用 <strong>闭包</strong> 的特性来处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc'</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(_this);  <span class="comment">// Object &#123;name: "qiutc"&#125;</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo2();</span><br></pre></td></tr></table></figure>
<p>可以看到直接用 <code>this</code> 仍然是 <code>Window</code>；因为 <code>foo2</code> 中的 <code>this</code> 是指向 <code>obj</code>，我们可以先用一个变量 <code>_this</code> 来储存，然后在回调函数中使用 <code>_this</code>，就可以指向当前的这个对象了；</p>
<h2 id="作为一个构造函数使用">作为一个构造函数使用</h2><p>在 js 中，为了实现类，我们需要定义一些构造函数，在调用一个构造函数的时候需要加上 <code>new</code> 这个关键字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'qiutc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person &#123;name: "qiutc"&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到当作构造函数调用时，<code>this</code> 指向了这个构造函数调用时候实例化出来的对象；</p>
<p>当然，构造函数其实也是一个函数，如果我们把它当作一个普通函数执行，这个 <code>this</code> 仍然执行全局：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = Person(<span class="string">'qiutc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Window</span></span><br></pre></td></tr></table></figure>
<p>其区别在于，如何调用函数（<code>new</code>）。</p>
<h2 id="箭头函数">箭头函数</h2><p>在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是 <code>this</code> 的指向了，还记得在上文中（<a href="#解决">作为对象的方法调用-一些坑-解决</a>）我们使用闭包来解决 <code>this</code> 的指向问题吗，如果用上了箭头函数就可以更完美的解决了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc'</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// Object &#123;name: "qiutc"&#125;</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo2();</span><br></pre></td></tr></table></figure>
<p>可以看到，在 <code>setTimeout</code> 执行的函数中，本应该打印出在 <code>Window</code>，但是在这里 <code>this</code> 却指向了 <code>obj</code>，原因就在于，给 <code>setTimeout</code> 传入的函数（参数）是一个箭头函数：</p>
<blockquote>
<p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
</blockquote>
<p>根据例子我们理解一下这句话：<br>在 <code>obj.foo2()</code> 执行的时候，当前的 <code>this</code> 指向 <code>obj</code>；在执行 <code>setTimeout</code> 时候，我们先是定义了一个匿名的箭头函数，关键点就在这，箭头函数内的 <code>this</code> 执行定义时所在的对象，就是指向定义这个箭头函数时作用域内的 <code>this</code>，也就是 <code>obj.foo2</code> 中的 <code>this</code>，即 <code>obj</code>；所以在执行箭头函数的时候，它的 <code>this</code> -&gt; <code>obj.foo2 中的 this</code> -&gt; <code>obj</code>；</p>
<p>简单来说， <strong>箭头函数中的 this 只和定义它时候的作用域的 this 有关，而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的</strong>。</p>
<h2 id="call,_apply,_bind">call, apply, bind</h2><p>在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 <code>this</code> 指向：</p>
<ul>
<li>call<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>它会立即执行函数，第一个参数是指定执行函数中 <code>this</code> 的上下文，后面的参数是执行函数需要传入的参数；</p>
<ul>
<li>apply<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fun.apply(thisArg[, [arg1, arg2, ...]])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>它会立即执行函数，第一个参数是指定执行函数中 <code>this</code> 的上下文，第二个参数是一个数组，是传给执行函数的参数（与 <code>call</code> 的区别）；</p>
<ul>
<li>bind<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = fun.bind(thisArg[, arg1[, arg2[, ...]]]);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>它不会执行函数，而是返回一个新的函数，这个新的函数被指定了 <code>this</code> 的上下文，后面的参数是执行函数需要传入的参数；</p>
<p><strong><em>这三个函数其实大同小异，总的目的就是去指定一个函数的上下文（this）</em></strong>，我们以 <code>call</code> 函数为例；</p>
<h3 id="为一个普通函数指定_this">为一个普通函数指定 this</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object &#123;name: "qiutc"&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在执行 <code>foo.call(obj)</code> 的时候，函数内的 <code>this</code> 指向了 <code>obj</code> 这个对象，成功；</p>
<h3 id="为对象中的方法指定一个_this">为对象中的方法指定一个 this</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc'</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">'tcqiu222222'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo.call(obj2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object &#123;name: "tcqiu222222"&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，执行函数的时候这里的 <code>this</code> 指向了 <code>obj2</code>，成功；</p>
<h3 id="为构造函数指定_this">为构造函数指定 this</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc2222222'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person.call(obj, <span class="string">'qiutc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Person.call is not a constructor(…)</span></span><br></pre></td></tr></table></figure>
<p>这里报了个错，原因是我们去 <code>new</code> 了 <code>Person.call</code> 函数，而非 <code>Person</code> ，这里的函数不是一个构造函数；</p>
<p>换成 <code>bind</code> 试试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc2222222'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person2 = Person.bind(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person2(<span class="string">'qiutc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person &#123;name: "qiutc"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object &#123;name: "qiutc2222222"&#125;</span></span><br></pre></td></tr></table></figure>
<p>打印出来的是 <code>Person</code> 实例化出来的对象，而和 <code>obj</code> 没有关系，而 <code>obj</code> 也没有发生变化，说明，我们给 <code>Person</code> 指定 <code>this</code> 上下文并没有生效；</p>
<p>因此可以得出： <strong>使用 bind 给一个构造函数指定 <code>this</code>，在 <code>new</code> 这个构造函数的时候，<code>bind</code> 函数所指定的 <code>this</code> 并不会生效</strong>；</p>
<p>当然 <code>bind</code> 不仅可以指定 <code>this</code> ，还能传入参数，我们来试试这个操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc2222222'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person2 = Person.bind(obj, <span class="string">'qiutc111111'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person2(<span class="string">'qiutc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person &#123;name: "qiutc111111"&#125;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，虽然指定 <code>this</code> 不起作用，但是传入参数还是起作用了；</p>
<h3 id="为箭头函数指定_this">为箭头函数指定 this</h3><p>我们来定义一个全局下的箭头函数，因此这个箭头函数中的 <code>this</code> 必然会指向全局对象，如果用 <code>call</code> 方法改变 <code>this</code> 呢：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> afoo = (a) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">afoo(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'qiutc'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">afoo.call(obj, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Window</span></span><br></pre></td></tr></table></figure>
<p>可以看到，这里的 <code>call</code> 指向 <code>this</code> 的操作并没有成功，所以可以得出： <strong>箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this），与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this</strong>。</p>
<p>只要记住箭头函数大法好，不变的 <code>this</code>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="tip">tip</h1><p>首先，我知道这篇文章很无聊，无非就是关于 js 中的 this，并且也已经有千千万万的文章写过这部分内容了；</p>
<p>但是，我还是想写一篇关于 js 中的 this 的文章，算是一个总结归纳吧；（大神们可以绕行看我的其他文章�]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://qiutc.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从一个事件绑定说起 - DOM]]></title>
    <link href="http://qiutc.me/post/binding-event-of-dom.html"/>
    <id>http://qiutc.me/post/binding-event-of-dom.html</id>
    <published>2016-08-15T02:45:32.000Z</published>
    <updated>2016-08-15T10:31:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="事件绑定的方式">事件绑定的方式</h1><p>给 DOM 元素绑定事件分为两大类：在 html 中直接绑定 和 在 JavaScript 中绑定。</p>
<h1 id="Bind_in_HTML">Bind in HTML</h1><p>在 HTML 中绑定事件叫做内联绑定事件，HTML 的元素中有如 <code>onclick</code> 这样的 <code>on***</code> 属性，它可以给这个 DOM 元素绑定一个类型的事件，主要是这样的：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> onclick=<span class="string">"***"</span>&gt;CLICK ME&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>***</code> 有两种形式：</p>
<ul>
<li>用字符串表示一段函数：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">onclick</span>=<span class="value">"var a = 1; console.log(a); console.log(this);"</span>&gt;</span>CLICK ME<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击可以发现，console:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">&lt;<span class="keyword">div</span> onclick=​<span class="string">"var a = 1;​ console.log(a)​;​ console.log(this)​;​"</span>&gt;​CLICK ME​&lt;/<span class="keyword">div</span>&gt;​</span><br></pre></td></tr></table></figure>
<p><code>var a = 1; console.log(a); console.log(this);</code> 这一段字符串被当作 js 执行了，同时 <code>this</code> 指向当前这个点击的元素。</p>
<ul>
<li>用函数名表示：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">onclick</span>=<span class="value">"foo(this)"</span>&gt;</span>CLICK ME<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里需要添加 <code>script</code> 去定义函数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">_this</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(_this);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以观察到，console：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> onclick=​<span class="string">"var a = 1;​ console.log(a)​;​ console.log(this)​;​"</span>&gt;​CLICK ME​&lt;/<span class="keyword">div</span>&gt;​</span><br><span class="line">window</span><br></pre></td></tr></table></figure>
<p>这里的 <code>this</code> 指向了全局，传入的参数是点击的 DOM 元素，其实和第一种方式是一样的，都是在 <code>onclick=</code> 后面指向了一段js的字符串，不同的是在这个字符串中是执行了一个函数名，而这个函数我们在全局中定义了，所以点击的时候可以执行，然后传入的参数 <code>this</code> 也就是一样的道理了。</p>
<p>或者多说一句，这里的字符串才是真正赋值给 <code>onclick</code> 的函数，这里我们是在函数里面再执行了 <code>foo</code> 函数。</p>
<p><strong>然而这内联的方式绑定时间不利于分离，所以一般我们不推荐这种做法，所以也就不再多阐述了</strong></p>
<h1 id="Bind_in_JavaScript">Bind in JavaScript</h1><h2 id="dom-onclick">dom.onclick</h2><p>先上栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"clickme"</span>&gt;</span>CLICK ME<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>观察 console：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="tag">clickme</span></span><br><span class="line"><span class="tag">MouseEvent</span> &#123;<span class="attribute">isTrusted</span>: true, <span class="attribute">screenX</span>: <span class="number">65</span>, <span class="attribute">screenY</span>: <span class="number">87</span>, <span class="attribute">clientX</span>: <span class="number">65</span>, <span class="attribute">clientY</span>: <span class="number">13</span>…&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们获取到了 <code>dom</code> 元素，然后给它的 <code>onclick</code> 属性赋值了一个函数；</p>
<p>点击 <code>dom</code> 我们发现那个函数执行了，同时发现函数中的 <code>this</code> 是指向当前的这个 <code>dom</code> 元素；</p>
<p>细细一想，其实这和前面用的在 <code>html</code> 中 <strong><em>内联</em></strong> 绑定函数是一样的，我们同样是给 <code>dom</code> 的 <code>onclick</code> 属性赋值一个函数，然后函数中的 <code>this</code> 指向当前元素，只是这个过程这里我们是在 js 中做的；</p>
<p>而还有一点区别就是前面的是赋值一段 js 字符串，这里是赋值一个函数，所以可以接受一个参数：<code>event</code>，这个参数是点击的事件对象。<br><br></p>
<p>用赋值绑定函数的一个缺点就是它只能绑定一次：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到这里只打印了一次 <code>clickme</code>。</p>
<h2 id="addEventListener">addEventListener</h2><p><strong>这个才是我们需要重点介绍的一个函数</strong></p>
<h3 id="语法">语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>target</code> : 表示要监听事件的目标对象，可以是一个文档上的元素 <code>Document</code> <code>本身，Window</code> 或者 <code>XMLHttpRequest</code>；</li>
<li><code>type</code> : 表示事件类型的字符串，比如: <code>click</code>、<code>change</code>、<code>touchstart</code> …；</li>
<li><code>listener</code> : 当指定的事件类型发生时被通知到的一个对象。该参数必是实现 EventListener 接口的一个对象或函数。</li>
<li><code>useCapture</code> : 设置事件的 <strong>捕获或者冒泡</strong> (后文阐述) ，<code>true</code>: 捕获，<code>false</code>: 冒泡*，默认为 <code>false</code>。</li>
</ul>
<h3 id="简单栗子">简单栗子</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"clickme"</span>&gt;</span>CLICK ME<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clickme = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>);</span><br><span class="line"></span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">  <span class="built_in">console</span>.log(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 console：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="tag">clickme</span></span><br><span class="line"><span class="tag">MouseEvent</span> &#123;<span class="attribute">isTrusted</span>: true, <span class="attribute">screenX</span>: <span class="number">37</span>, <span class="attribute">screenY</span>: <span class="number">88</span>, <span class="attribute">clientX</span>: <span class="number">37</span>, <span class="attribute">clientY</span>: <span class="number">14</span>…&#125;</span><br></pre></td></tr></table></figure>
<p>监听函数中的 <code>this</code> 指向当前的 <code>dom</code> 元素，函数接受一个 <code>event</code> 参数。</p>
<h3 id="绑定函数">绑定函数</h3><h4 id="绑定多个函数">绑定多个函数</h4><p><code>addEventListener</code> 可以给同一个 <code>dom</code> 元素绑定多个函数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"clickme"</span>&gt;</span>CLICK ME<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clickme = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>);</span><br><span class="line"></span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1);</span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 console：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">222</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到两个函数都执行了，并且执行顺序按照绑定的顺序执行。</p>
<p><strong><em>改变一下</em></strong>，如果我们的 <code>useCapture</code> 参数不同呢？<br>看下面 3 组对比：</p>
<h5 id="1">1</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clickme = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>);</span><br><span class="line"></span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1, <span class="literal">true</span>);</span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo2, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2">2</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clickme = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>);</span><br><span class="line"></span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1, <span class="literal">true</span>);</span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo2, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3">3</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clickme = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>);</span><br><span class="line"></span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1, <span class="literal">false</span>);</span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo2, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，console 并没有改变，所以执行顺序只和绑定顺序有关，和 <code>useCapture</code> 无关。</p>
<p>结论：<br><strong>我们可以给一个 <code>dom</code> 元素绑定多个函数，并且它的执行顺序按照绑定的顺序执行。</strong></p>
<h4 id="同一个元素绑定同一个函数">同一个元素绑定同一个函数</h4><p>我们给一个 <code>dom</code> 元素绑定同一个函数两次试试：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"clickme"</span>&gt;</span>CLICK ME<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clickme = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>);</span><br><span class="line"></span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1);</span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 console:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">111</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到函数只执行了一次；</p>
<p>换一种方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clickme = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>);</span><br><span class="line"></span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1, <span class="literal">true</span>);</span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 console:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">111</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到函数执行了两次。</p>
<p>结论：<br><strong>我们可以给一个 <code>dom</code> 元素绑定同一个函数，最多只能绑定 <code>useCapture</code> 类型不同的两次。</strong></p>
<h3 id="IE下使用attachEvent/detachEvent">IE下使用attachEvent/detachEvent</h3><p><code>addEventListener</code> 只支持到 IE 9，所以为了兼容性考虑，在兼容 IE 8 以及以下浏览器可以用 <code>attachEvent</code> 函数，和 <code>addEventListener</code> 函数表现一样，除了它绑定函数的 <code>this</code> 会指向全局这个缺点以外</p>
<h1 id="事件执行顺序的_PK">事件执行顺序的 PK</h1><h2 id="1-_addEventListener_和_dom-onclick">1. addEventListener 和 dom.onclick</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"clickme"</span>&gt;</span>CLICK ME<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clickme = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>);</span><br><span class="line"></span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1, <span class="literal">true</span>);</span><br><span class="line">clickme.onclick = foo2;</span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo3, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">333</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察 console：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">333</span></span><br></pre></td></tr></table></figure>
<p><strong>可见执行顺序只和绑定顺序有关</strong></p>
<h2 id="2-_addEventListener_间的比较">2. addEventListener 间的比较</h2><p><a href="#绑定多个函数">见上文</a></p>
<h1 id="事件的解绑">事件的解绑</h1><p>与事件绑定相对应的就是事件解绑了。</p>
<h2 id="1-_通过_dom_的_on**_属性设置的事件">1. 通过 dom 的 on** 属性设置的事件</h2><p><strong>对于 Bind in HTML 和 <code>dom.onclick</code> 绑定的事件都可以用 <code>dom.onclick = null</code> 来解绑事件。</strong></p>
<h2 id="2-_removeEventListener">2. removeEventListener</h2><p>通过 <code>addEventListener</code> 绑定的事件可以使用 <code>removeEventListener</code> 来解绑， <code>removeEventListener</code> 接受的参数和 <code>addEventListener</code> 是一样的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"clickme"</span>&gt;</span>CLICK ME<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> clickme = <span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>);</span><br><span class="line"></span><br><span class="line">clickme.addEventListener(<span class="string">'click'</span>, foo1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line">clickme.removeEventListener(<span class="string">'click'</span>, foo1, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>这里发现事件并没有取消绑定，发现 <code>removeEventListener</code> 的 <code>useCapture</code> 的参数原来和绑定时候传入的不一致，我们改成 <code>false</code> 之后发现事件取消了。</p>
<p>结论：<br><strong>对于使用 <code>removeEventListener</code> 函数解绑事件，需要传入的 <code>listener</code> <code>useCapture</code> 应和 <code>addEventListener</code> 一致才可以解绑事件。</strong></p>
<h2 id="3-_detachEvent">3. detachEvent</h2><p>与 <code>attachEvent</code> 对应</p>
<h1 id="DOM_事件">DOM 事件</h1><p><img src="/img/dom-event.png" alt="DEMO"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"div1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"div2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"div3"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="事件冒泡">事件冒泡</h2><p>事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。</p>
<p>比如上面的 HTML ，冒泡的顺序： div3 -&gt; div3 -&gt; div1 -&gt; body -&gt; html -&gt; document (-&gt; window)</p>
<h2 id="事件捕获">事件捕获</h2><p>事件捕获的思想是不太具体的DOM节点应该更早接收到事件，而最具体的节点应该最后接收到事件。与事件冒泡的顺序相反。</p>
<p>比如上面的 HTML ，捕获的顺序： document -&gt; html -&gt; body -&gt; div1 -&gt; div2 -&gt; div3</p>
<h2 id="DOM事件流">DOM事件流</h2><p>DOM事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。</p>
<h2 id="回到_addEventListener">回到 addEventListener</h2><p>我们来做几个小对比：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"clickme"</span>&gt;</span>CLICK ME<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="栗子_1">栗子 1</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'wrap'</span>).addEventListener(<span class="string">'click'</span>, foo1, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>).addEventListener(<span class="string">'click'</span>, foo2, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>console：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">111</span></span><br></pre></td></tr></table></figure>
<p>这里两个事件都是冒泡类型，所以是从内到外；</p>
<h3 id="栗子_2">栗子 2</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'wrap'</span>).addEventListener(<span class="string">'click'</span>, foo1, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>).addEventListener(<span class="string">'click'</span>, foo2, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>console：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">222</span></span><br></pre></td></tr></table></figure>
<p>这里两个事件都是捕获类型，所以是从外到内；</p>
<h3 id="栗子_3">栗子 3</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'wrap'</span>).addEventListener(<span class="string">'click'</span>, foo1, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>).addEventListener(<span class="string">'click'</span>, foo2, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>console：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">111</span></span><br></pre></td></tr></table></figure>
<p>wrap 事件是冒泡，clickme 事件是捕获，根据 dom 的事件流，先执行了捕获阶段（这里是目标阶段）再到冒泡阶段。</p>
<h3 id="栗子_4">栗子 4</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'wrap'</span>).addEventListener(<span class="string">'click'</span>, foo1, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>).addEventListener(<span class="string">'click'</span>, foo2, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>console：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">222</span></span><br></pre></td></tr></table></figure>
<p>clickme 事件是冒泡，wrap 事件是捕获，根据 dom 的事件流，先执行了捕获阶段（这里是目标阶段）再到冒泡阶段。</p>
<h2 id="阻止_冒泡／捕获">阻止 冒泡／捕获</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"clickme"</span>&gt;</span>CLICK ME<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'wrap'</span>).addEventListener(<span class="string">'click'</span>, foo1);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'clickme'</span>).addEventListener(<span class="string">'click'</span>, foo2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>console：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">222</span></span><br></pre></td></tr></table></figure>
<p>这里我们在 <code>clickme</code> 的目标阶段阻止了事件流，所以事件不会继续冒泡，所以 <code>wrap</code> 的冒泡事件不会执行。</p>
<p>tip:<br>IE8以及以前可以通过 <code>window.event.cancelBubble=true</code> 来阻止事件流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="事件绑定的方式">事件绑定的方式</h1><p>给 DOM 元素绑定事件分为两大类：在 html 中直接绑定 和 在 JavaScript 中绑定。</p>
<h1 id="Bind_in_HTML">Bind in HTML</h1><p>在 HTML 中绑定事]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://qiutc.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你不需要 js 就可以实现一个轮播]]></title>
    <link href="http://qiutc.me/post/carousel-without-javascript.html"/>
    <id>http://qiutc.me/post/carousel-without-javascript.html</id>
    <published>2016-08-10T10:44:47.000Z</published>
    <updated>2016-08-10T11:33:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Tip">Tip</h1><p>轮播这种组件是大部分网站都会存在的了，绝大部分都是 js 来实现逻辑控制的，它的原理就不多阐述了，因为我们现在要做的是不用 js 来实现一个轮播组件！</p>
<p>前提是只兼容现代浏览器。</p>
<h1 id="原理">原理</h1><p>这里我们主要用的原理：</p>
<ul>
<li><p>CSS3 element+element 选择器（相邻兄弟选择器），<code>element+element</code> 选择器用于选取第一个指定的元素之后（不是内部）紧跟的元素。</p>
</li>
<li><p>CSS3 element1~element2 选择器，<code>element1~element2</code> 选择 <code>element1</code> 之后出现的所有 <code>element2。两种元素必须拥有相同的父元素，但是</code> <code>element2</code> 不必直接紧随 <code>element1</code>。</p>
</li>
<li><p>CSS3 :checked 选择器，<code>:checked</code> 选择器匹配每个选中的输入元素（仅适用于单选按钮或复选框）。</p>
</li>
<li><p>HTML5 <code>label</code> 标签的 <code>for</code> 属性。</p>
</li>
</ul>
<p>我们能实现的效果：</p>
<ul>
<li>轮播图片的前进后退</li>
<li>选择某张图片</li>
<li>图片切换的淡入淡出</li>
</ul>
<p>我们实现不了的：</p>
<ul>
<li>自动轮播</li>
<li>滑动的轮播切换</li>
</ul>
<h1 id="开干">开干</h1><ol>
<li>首先对于一个轮播组件，我们需要每个图片的容器（废话）:</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-inner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/0079D8/fff/?text=Without"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/DA5930/fff/?text=JavaScript"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/F90/fff/?text=Carousel"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>然后我们需要只显示一张图片，并且加点样式。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-inner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"carousel-open"</span> <span class="attribute">type</span>=<span class="value">"radio"</span> <span class="attribute">id</span>=<span class="value">"carousel-1"</span> <span class="attribute">name</span>=<span class="value">"carousel"</span> <span class="attribute">aria-hidden</span>=<span class="value">"true"</span> <span class="attribute">hidden</span>=<span class="value">""</span> <span class="attribute">checked</span>=<span class="value">"checked"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/0079D8/fff/?text=Without"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"carousel-open"</span> <span class="attribute">type</span>=<span class="value">"radio"</span> <span class="attribute">id</span>=<span class="value">"carousel-2"</span> <span class="attribute">name</span>=<span class="value">"carousel"</span> <span class="attribute">aria-hidden</span>=<span class="value">"true"</span> <span class="attribute">hidden</span>=<span class="value">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/DA5930/fff/?text=JavaScript"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"carousel-open"</span> <span class="attribute">type</span>=<span class="value">"radio"</span> <span class="attribute">id</span>=<span class="value">"carousel-3"</span> <span class="attribute">name</span>=<span class="value">"carousel"</span> <span class="attribute">aria-hidden</span>=<span class="value">"true"</span> <span class="attribute">hidden</span>=<span class="value">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/F90/fff/?text=Carousel"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">html</span>, <span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.carousel</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> <span class="number">0px</span> <span class="number">1px</span> <span class="number">6px</span> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.64</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">26px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.carousel-inner</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.carousel-open</span><span class="pseudo">:checked</span> + <span class="class">.carousel-item</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> static</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">100</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.carousel-item</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">-webkit-transition</span>:<span class="value"> opacity <span class="number">0.6s</span> ease-out</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">transition</span>:<span class="value"> opacity <span class="number">0.6s</span> ease-out</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="class">.carousel-item</span> <span class="tag">img</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> auto</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">max-width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里我们用到 CSS3 的 <code>+</code> 兄弟选择器和 <code>:checked</code> 选择器，在 <code>radio</code> 的 <code>input</code> 有个 <code>:checked</code> 为了，当它的 <code>checked=true</code> 时会匹配，所以我们给每一个 <code>carousel-item</code> 都配上了一个 <code>radio</code>，并且 <code>name</code> 都是一个，这样就只能一组 <code>radio</code> 中选一个了。</p>
<p>同时我们吧 <code>radio</code> 放在每一个  <code>carousel-item</code> 之前，这样就可以用 <code>+</code> 选择器来匹配了，首先所有的 <code>carousel-item</code> 的 <code>opacity</code> 默认为 <code>0</code>，<code>position</code> 为 <code>absolute</code>；</p>
<p>在它之前的那个 <code>radio</code> 被checked的时候，即 <code>.carousel-open:checked + .carousel-item</code>，把 <code>opacity</code> 变为 <code>100</code>，加上过渡的 <code>transition</code>；<code>position</code> 变为 <code>static</code>。</p>
<p>这样，在每次选择一个 <code>radio</code> 的时候他之后的第一个 <code>carousel-item</code> 就会淡入，而先前的会淡出。</p>
<p>我们还需要把 <code>radio</code> 的 <code>input</code> 的  <code>aria-hidden</code> 设为 <code>true</code>，因为我们总不希望在页面上看到几个 <code>radio</code> 吧。</p>
<p>然而这样的话，我们如何点击操作 <code>radio</code> 呢？</p>
<ol>
<li>前后控制</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-inner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"carousel-open"</span> <span class="attribute">type</span>=<span class="value">"radio"</span> <span class="attribute">id</span>=<span class="value">"carousel-1"</span> <span class="attribute">name</span>=<span class="value">"carousel"</span> <span class="attribute">aria-hidden</span>=<span class="value">"true"</span> <span class="attribute">hidden</span>=<span class="value">""</span> <span class="attribute">checked</span>=<span class="value">"checked"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/0079D8/fff/?text=Without"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"carousel-open"</span> <span class="attribute">type</span>=<span class="value">"radio"</span> <span class="attribute">id</span>=<span class="value">"carousel-2"</span> <span class="attribute">name</span>=<span class="value">"carousel"</span> <span class="attribute">aria-hidden</span>=<span class="value">"true"</span> <span class="attribute">hidden</span>=<span class="value">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/DA5930/fff/?text=JavaScript"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"carousel-open"</span> <span class="attribute">type</span>=<span class="value">"radio"</span> <span class="attribute">id</span>=<span class="value">"carousel-3"</span> <span class="attribute">name</span>=<span class="value">"carousel"</span> <span class="attribute">aria-hidden</span>=<span class="value">"true"</span> <span class="attribute">hidden</span>=<span class="value">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/F90/fff/?text=Carousel"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-3"</span> <span class="attribute">class</span>=<span class="value">"carousel-control prev control-1"</span>&gt;</span>‹<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-2"</span> <span class="attribute">class</span>=<span class="value">"carousel-control next control-1"</span>&gt;</span>›<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-1"</span> <span class="attribute">class</span>=<span class="value">"carousel-control prev control-2"</span>&gt;</span>‹<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-3"</span> <span class="attribute">class</span>=<span class="value">"carousel-control next control-2"</span>&gt;</span>›<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-2"</span> <span class="attribute">class</span>=<span class="value">"carousel-control prev control-3"</span>&gt;</span>‹<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-1"</span> <span class="attribute">class</span>=<span class="value">"carousel-control next control-3"</span>&gt;</span>›<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>加点样式：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="class">.carousel-control</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.28</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">50%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> pointer</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">40px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">40px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">35px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">50%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">translate</span>(<span class="number">0</span>, -<span class="number">50%</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> pointer</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">-ms-transform</span>:<span class="value"> <span class="function">translate</span>(<span class="number">0</span>, -<span class="number">50%</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translate</span>(<span class="number">0</span>, -<span class="number">50%</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">40px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">z-index</span>:<span class="value"> <span class="number">10</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-control</span><span class="class">.prev</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">2%</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-control</span><span class="class">.next</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">2%</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-control</span><span class="pseudo">:hover</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.8</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#aaaaaa</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="id">#carousel-1</span><span class="pseudo">:checked</span> ~ <span class="class">.control-1</span>,</span><br><span class="line"><span class="id">#carousel-2</span><span class="pseudo">:checked</span> ~ <span class="class">.control-2</span>,</span><br><span class="line"><span class="id">#carousel-3</span><span class="pseudo">:checked</span> ~ <span class="class">.control-3</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这里用到了 <code>label</code> 标签和它的 <code>for</code> 属性，这个属性可以指定 <code>label</code> 的指向，<code>for</code> 属性接受的是需要指向的 <code>input radio</code> 的 <code>id</code>，这样只要我们点击 <code>label</code> 就可以触发 <code>input radio</code> 的点击了。</p>
<p>这里我们给每个 <code>radio</code> 指定了一组前后的按钮，同时用 css 来排布，每次显示当前显示图片前后图片的 <code>input radio</code> 对应的 <code>label</code>。</p>
<ol>
<li>更多的控制</li>
</ol>
<p>我们还想要很多轮播下面都有的索引点，这样就可以选择某个索引的图片了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-inner"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"carousel-open"</span> <span class="attribute">type</span>=<span class="value">"radio"</span> <span class="attribute">id</span>=<span class="value">"carousel-1"</span> <span class="attribute">name</span>=<span class="value">"carousel"</span> <span class="attribute">aria-hidden</span>=<span class="value">"true"</span> <span class="attribute">hidden</span>=<span class="value">""</span> <span class="attribute">checked</span>=<span class="value">"checked"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/0079D8/fff/?text=Without"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"carousel-open"</span> <span class="attribute">type</span>=<span class="value">"radio"</span> <span class="attribute">id</span>=<span class="value">"carousel-2"</span> <span class="attribute">name</span>=<span class="value">"carousel"</span> <span class="attribute">aria-hidden</span>=<span class="value">"true"</span> <span class="attribute">hidden</span>=<span class="value">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/DA5930/fff/?text=JavaScript"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"carousel-open"</span> <span class="attribute">type</span>=<span class="value">"radio"</span> <span class="attribute">id</span>=<span class="value">"carousel-3"</span> <span class="attribute">name</span>=<span class="value">"carousel"</span> <span class="attribute">aria-hidden</span>=<span class="value">"true"</span> <span class="attribute">hidden</span>=<span class="value">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"carousel-item"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://fakeimg.pl/2000x800/F90/fff/?text=Carousel"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-3"</span> <span class="attribute">class</span>=<span class="value">"carousel-control prev control-1"</span>&gt;</span>‹<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-2"</span> <span class="attribute">class</span>=<span class="value">"carousel-control next control-1"</span>&gt;</span>›<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-1"</span> <span class="attribute">class</span>=<span class="value">"carousel-control prev control-2"</span>&gt;</span>‹<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-3"</span> <span class="attribute">class</span>=<span class="value">"carousel-control next control-2"</span>&gt;</span>›<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-2"</span> <span class="attribute">class</span>=<span class="value">"carousel-control prev control-3"</span>&gt;</span>‹<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-1"</span> <span class="attribute">class</span>=<span class="value">"carousel-control next control-3"</span>&gt;</span>›<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ol</span> <span class="attribute">class</span>=<span class="value">"carousel-indicators"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-1"</span> <span class="attribute">class</span>=<span class="value">"carousel-bullet"</span>&gt;</span>•<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-2"</span> <span class="attribute">class</span>=<span class="value">"carousel-bullet"</span>&gt;</span>•<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"carousel-3"</span> <span class="attribute">class</span>=<span class="value">"carousel-bullet"</span>&gt;</span>•<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>完整的css：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">html</span>, <span class="tag">body</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">url</span>(<span class="string">"http://digital.bnint.com/filelib/s9/photos/white_wood_4500x3000_lo_res.jpg"</span>)</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">box-shadow</span>:<span class="value"> <span class="number">0px</span> <span class="number">1px</span> <span class="number">6px</span> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.64</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin-top</span>:<span class="value"> <span class="number">26px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-inner</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-open</span><span class="pseudo">:checked</span> + <span class="class">.carousel-item</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> static</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">100</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-item</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">opacity</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">-webkit-transition</span>:<span class="value"> opacity <span class="number">0.6s</span> ease-out</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">transition</span>:<span class="value"> opacity <span class="number">0.6s</span> ease-out</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-item</span> <span class="tag">img</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> auto</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">max-width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-control</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.28</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">border-radius</span>:<span class="value"> <span class="number">50%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> pointer</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">40px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">40px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">line-height</span>:<span class="value"> <span class="number">35px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">50%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">-webkit-transform</span>:<span class="value"> <span class="function">translate</span>(<span class="number">0</span>, -<span class="number">50%</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> pointer</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">-ms-transform</span>:<span class="value"> <span class="function">translate</span>(<span class="number">0</span>, -<span class="number">50%</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translate</span>(<span class="number">0</span>, -<span class="number">50%</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">40px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">z-index</span>:<span class="value"> <span class="number">10</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-control</span><span class="class">.prev</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">2%</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-control</span><span class="class">.next</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">2%</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-control</span><span class="pseudo">:hover</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.8</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#aaaaaa</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="id">#carousel-1</span><span class="pseudo">:checked</span> ~ <span class="class">.control-1</span>,</span><br><span class="line"><span class="id">#carousel-2</span><span class="pseudo">:checked</span> ~ <span class="class">.control-2</span>,</span><br><span class="line"><span class="id">#carousel-3</span><span class="pseudo">:checked</span> ~ <span class="class">.control-3</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-indicators</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">list-style</span>:<span class="value"> none</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">2%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">right</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">z-index</span>:<span class="value"> <span class="number">10</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-indicators</span> <span class="tag">li</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0</span> <span class="number">5px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-bullet</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">cursor</span>:<span class="value"> pointer</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">35px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.carousel-bullet</span><span class="pseudo">:hover</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#aaaaaa</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="id">#carousel-1</span><span class="pseudo">:checked</span> ~ <span class="class">.control-1</span> ~ <span class="class">.carousel-indicators</span> <span class="tag">li</span><span class="pseudo">:nth-child(1)</span> <span class="class">.carousel-bullet</span>,</span><br><span class="line"><span class="id">#carousel-2</span><span class="pseudo">:checked</span> ~ <span class="class">.control-2</span> ~ <span class="class">.carousel-indicators</span> <span class="tag">li</span><span class="pseudo">:nth-child(2)</span> <span class="class">.carousel-bullet</span>,</span><br><span class="line"><span class="id">#carousel-3</span><span class="pseudo">:checked</span> ~ <span class="class">.control-3</span> ~ <span class="class">.carousel-indicators</span> <span class="tag">li</span><span class="pseudo">:nth-child(3)</span> <span class="class">.carousel-bullet</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#428bca</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="id">#title</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">0px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">0px</span> auto</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">text-align</span>:<span class="value"> center</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">27px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="function">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">'Open Sans'</span>, sans-serif</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">z-index</span>:<span class="value"> <span class="number">9999</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">text-shadow</span>:<span class="value"> <span class="number">0px</span> <span class="number">1px</span> <span class="number">2px</span> <span class="function">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.33</span>), -<span class="number">1px</span> <span class="number">0px</span> <span class="number">2px</span> <span class="function">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>原理还是 <code>label</code> 的 <code>for</code> 属性，然后用 css 做了样式以及布局。</p>
<h1 id="END">END</h1><p>其实不用 js ，只用 css 还可以实现很多有趣的功能，比如 <code>tooltip</code>，<code>Toggle</code>，<code>Popover</code>….<br>更多可以看 <a href="https://github.com/NamPNQ/You-Dont-Need-Javascript" target="_blank" rel="external">You-Dont-Need-Javascript</a> 这个仓库。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Tip">Tip</h1><p>轮播这种组件是大部分网站都会存在的了，绝大部分都是 js 来实现逻辑控制的，它的原理就不多阐述了，因为我们现在要做的是不用 js 来实现一个轮播组件！</p>
<p>前提是只兼容现代浏览器。</p>
<h1 id="原理">原理</]]>
    </summary>
    
      <category term="CSS" scheme="http://qiutc.me/tags/CSS/"/>
    
      <category term="CSS" scheme="http://qiutc.me/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 手册]]></title>
    <link href="http://qiutc.me/post/es6-cheatsheet.html"/>
    <id>http://qiutc.me/post/es6-cheatsheet.html</id>
    <published>2016-07-27T01:05:05.000Z</published>
    <updated>2016-08-10T11:41:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tip">tip</h1><p>文章是翻译，主要是很多 ES6 的用法技巧以及最佳实践～<br>原文 <a href="https://github.com/DrkSephy/es6-cheatsheet" target="_blank" rel="external">https://github.com/DrkSephy/es6-cheatsheet</a></p>
<hr>
<p><img src="/img/es6.jpg" alt="es6"></p>
<h1 id="ES6_手册">ES6 手册</h1><p>这篇手册包含了 ES2015(ES6) 的使用小技巧、最佳实践以及可以给你每天的工作参考的代码片段。</p>
<h2 id="内容列表">内容列表</h2><ul>
<li><a href="#var_和_let/const_的比较">var 和 let/const 的比较</a></li>
<li><a href="#用块级作用域代替_IIFES">用块级作用域代替 IIFES</a></li>
<li><a href="#箭头函数">箭头函数</a></li>
<li><a href="#字符串">字符串</a></li>
<li><a href="#解构">解构</a></li>
<li><a href="#模块">模块</a></li>
<li><a href="#参数">参数</a></li>
<li><a href="#类_Classes">类 Classes</a></li>
<li><a href="#Symbols">Symbols</a></li>
<li><a href="#Maps">Maps</a></li>
<li><a href="#WeakMaps">WeakMaps</a></li>
<li><a href="#Promises">Promises</a></li>
<li><a href="#Generators_生成器">Generators 生成器</a></li>
<li><a href="#Async_Await">Async Await</a></li>
<li><a href="#Getter/Setter_函数">Getter/Setter 函数</a></li>
</ul>
<h2 id="var_和_let/const_的比较">var 和 let/const 的比较</h2><blockquote>
<p>除了 <code>var</code> ，我们现在还可以使用两个新的标示符来定义一个变量 —— <code>let</code> 和 <code>const</code>。和 <code>var</code> 不一样的是，<code>let</code> 和 <code>const</code> 不存在变量提升。</p>
</blockquote>
<p>使用 <code>var</code> 的栗子：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> snack = <span class="string">'Meow Mix'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFood</span><span class="params">(food)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (food) &#123;</span><br><span class="line">        <span class="keyword">var</span> snack = <span class="string">'Friskies'</span>;</span><br><span class="line">        <span class="keyword">return</span> snack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> snack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFood(<span class="literal">false</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>当我们用 <code>let</code> 代替 <code>var</code> 的时候，观察会发生什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> snack = <span class="string">'Meow Mix'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFood</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (food) &#123;</span><br><span class="line">        <span class="keyword">let</span> snack = <span class="string">'Friskies'</span>;</span><br><span class="line">        <span class="keyword">return</span> snack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> snack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getFood(<span class="literal">false</span>); <span class="comment">// 'Meow Mix'</span></span><br></pre></td></tr></table></figure>
<p>当我们重构使用 <code>var</code> 的老代码的时候应该注意上面的变化。盲目地使用 <code>let</code> 替换 <code>var</code> 可能会出现出乎意料的情况。</p>
<blockquote>
<p><strong>注意</strong>： <code>let</code> 和 <code>const</code> 是块级作用域，因此在变量未被定义之前使用它会产生一个 <code>ReferenceError</code>。</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x); <span class="regexp">//</span> <span class="attribute">ReferenceError</span>: x <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br><span class="line">let x = <span class="string">'hi'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>最佳实践</strong>： 在遗留代码中放弃使用 <code>var</code> 声明意味着需要很小心地重构；在新的项目代码中，使用 <code>let</code> 声明一个可以改变的变量，用 <code>const</code> 声明一个不能被重新赋值的变量。</p>
</blockquote>
<h2 id="用块级作用域代替_IIFES">用块级作用域代替 IIFES</h2><blockquote>
<p><strong>函数立即执行表达式</strong> 的通常用途是创造一个内部的作用域，在 ES6 中，我们能够创造一个块级作用域而不仅限于函数作用域：</p>
</blockquote>
<p>IIFES：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> food = <span class="string">'Meow Mix'</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(food); <span class="comment">// Reference Error</span></span><br></pre></td></tr></table></figure>
<p>使用 ES6 的块级作用域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> food = <span class="string">'Meow Mix'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(food); <span class="comment">// Reference Error</span></span><br></pre></td></tr></table></figure>
<h2 id="箭头函数">箭头函数</h2><p>我们经常需要给回调函数维护一个词法作用域的上下文 <code>this</code>。<br>看看这个栗子：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> <span class="params">(character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + character; <span class="comment">// Cannot read property 'name' of undefined</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个常用的解决办法是把 <code>this</code> 存在一个变量中：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// Store the context of this</span></span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> <span class="params">(character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> that.name + character;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以传递一个合适的 <code>this</code> 上下文：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span> <span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> <span class="params">(character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + character;</span><br><span class="line">    &#125;, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以绑定上下文：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> Person(<span class="keyword">name</span>) &#123;</span><br><span class="line">    this.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span></span> (arr) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span></span> (<span class="type">character</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> this.<span class="keyword">name</span> + <span class="type">character</span>;</span><br><span class="line">    &#125;.<span class="keyword">bind</span>(this));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 <strong>箭头函数</strong>，<code>this</code> 将不会受到影响，并且我们可以重写上面的函数：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> Person(<span class="keyword">name</span>) &#123;</span><br><span class="line">    this.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.prefixName = <span class="function"><span class="keyword">function</span></span> (arr) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.map(<span class="type">character</span> =&gt; this.<span class="keyword">name</span> + <span class="type">character</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>最佳实践</strong>：当你需要维护一个 <code>this</code> 上下文的时候使用 <strong>箭头函数</strong>。</p>
</blockquote>
<p>在我们写一个函数的时候，箭头函数更加简洁并且可以很简单地返回一个值：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> squares = arr.map(<span class="function"><span class="keyword">function</span> <span class="params">(x)</span> </span>&#123; <span class="keyword">return</span> x * x &#125;); <span class="comment">// Function Expression</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> squares = arr.<span class="built_in">map</span>(x =&gt; x * x); <span class="comment">// Arrow Function for terser implementation</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>最佳实践</strong>：尽可能使用箭头函数代替原来的写法。</p>
</blockquote>
<h2 id="字符串">字符串</h2><p>在 ES6 中，标准库升级了很多，在这些变化中有许多新的对于字符串的函数，比如 <code>.includes()</code> 和 <code>.repeat()</code>。</p>
<h3 id="-includes(_)">.includes( )</h3><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">string</span> = <span class="string">'food'</span>;</span><br><span class="line"><span class="built_in">var</span> substring = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line">console<span class="built_in">.</span><span class="keyword">log</span>(<span class="built_in">string</span><span class="built_in">.</span>indexOf(substring) &gt; -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>之前我们使用 <code>indexOf()</code> 函数的返回值是否 <code>&gt;-1</code> 来判断字符串是否包含某些字符串，现在我们更简单地使用 <code>.includes()</code> 来返回一个布尔值来判断：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">const <span class="keyword">string</span> = <span class="string">'food'</span>;</span><br><span class="line">const <span class="keyword">substring</span> = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="keyword">log</span>(<span class="keyword">string</span>.includes(<span class="keyword">substring</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="-repeat(_)">.repeat( )</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">function <span class="keyword">repeat</span>(<span class="type">string</span>, <span class="command">count</span>) &#123;</span><br><span class="line">    var strings = [];</span><br><span class="line">    <span class="keyword">while</span>(strings.<span class="property">length</span> &lt; <span class="command">count</span>) &#123;</span><br><span class="line">        strings.push(<span class="type">string</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="command">    return</span> strings.join('');</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ES6 中，可以更简便地实现：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.repeat(numberOfRepetitions)</span></span><br><span class="line"><span class="string">'meow'</span>.<span class="keyword">repeat</span><span class="comment">(3)</span>; <span class="comment">// 'meowmeowmeow'</span></span><br></pre></td></tr></table></figure>
<h3 id="模版字符串">模版字符串</h3><p>使用 <strong>模版字符串</strong> 我们就可以不用对某些特殊自负进行转义处理了：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">text</span> = <span class="string">"This string contains \"</span><span class="built_in">double</span> quotes\<span class="string">" which are escaped."</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="tag">`This</span> <span class="built_in">string</span> contains <span class="string">"double quotes"</span> which don't need <span class="keyword">to</span> be escaped anymore.`;</span><br></pre></td></tr></table></figure>
<p><strong>模版字符串</strong> 还支持插入，可以把变量值和字符串连接起来.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Tiger'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'My cat is named '</span> + name + <span class="string">' and is '</span> + age + <span class="string">' years old.'</span>);</span><br></pre></td></tr></table></figure>
<p>更简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'Tiger'</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`My cat is named <span class="subst">$&#123;name&#125;</span> and is <span class="subst">$&#123;age&#125;</span> years old.`</span>);</span><br></pre></td></tr></table></figure>
<p>在 ES5 中，需要换行时，需要这样：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">var text = (</span><br><span class="line">    <span class="symbol">'cat</span>\n' +</span><br><span class="line">    <span class="symbol">'dog</span>\n' +</span><br><span class="line">    <span class="symbol">'nickelodeon'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>或者这样：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = [</span><br><span class="line">    <span class="string">'cat'</span>,</span><br><span class="line">    <span class="string">'dog'</span>,</span><br><span class="line">    <span class="string">'nickelodeon'</span></span><br><span class="line">].<span class="keyword">join</span>(<span class="string">'\n'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>模版字符串</strong> 可以支持换行并且不需要额外的处理：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">let text = ( <span class="escape">`c</span>at</span><br><span class="line">dog</span><br><span class="line">nickelodeon<span class="escape">`</span><br><span class="line"></span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>模版字符串</strong> 还支持表达式：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> text = `The <span class="built_in">time</span> <span class="keyword">and</span> <span class="built_in">date</span> <span class="keyword">is</span> $&#123;today.toLocaleString()&#125;`;</span><br></pre></td></tr></table></figure>
<h2 id="解构">解构</h2><p>结构可以让我们用一个更简便的语法从一个数组或者对象（即使是深层的）中分离出来值，并存储他们。</p>
<h3 id="结构数组">结构数组</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> a</span> = arr[<span class="number">0</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span> = arr[<span class="number">1</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> c</span> = arr[<span class="number">2</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> d</span> = arr[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">let [a, b, c, d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">console.<span class="built_in">log</span>(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="结构对象">结构对象</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> luke</span> = &#123; occupation: 'jedi', father: 'anakin' &#125;;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> occupation</span> = luke.occupation; <span class="comment">// 'jedi'</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> father</span> = luke.father; <span class="comment">// 'anakin'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> luke = &#123; occupation: <span class="string">'jedi'</span>, father: <span class="string">'anakin'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;occupation, father&#125; = luke;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(occupation); <span class="comment">// 'jedi'</span></span><br><span class="line"><span class="built_in">console</span>.log(father); <span class="comment">// 'anakin'</span></span><br></pre></td></tr></table></figure>
<h2 id="模块">模块</h2><p>在 ES6 之前，我们使用 <code>Browserify</code> 这样的库来创建客户端的模块化，在 <code>node.js</code> 中使用 <code>require</code>。<br>在 ES6 中，我们可以直接使用所有类型的模块化（AMD 和 CommonJS）。</p>
<h3 id="使用_CommonJS_的出口">使用 CommonJS 的出口</h3><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> &#123; foo: 'bar' &#125;;</span><br><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> ['foo', 'bar'];</span><br><span class="line"><span class="function"><span class="keyword">module</span>.<span class="title">exports</span> =</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span> <span class="params">()</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用_ES6_的出口">使用 ES6 的出口</h3><p>在 ES6 中我们可以暴露多个值，使用 <code>Exports</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> name = <span class="string">'David'</span>;</span><br><span class="line"><span class="built_in">export</span> <span class="built_in">let</span> age  = <span class="number">25</span>;​​</span><br></pre></td></tr></table></figure>
<p>或者暴露一个对象列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumTwo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumThree</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; sumTwo, sumThree &#125;;</span><br></pre></td></tr></table></figure>
<p>我们还可以暴露函数、对象和其他的值，通过简单地使用 <code>export</code> 这个关键字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sumTwo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sumThree</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们还可以绑定一个默认的输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumTwo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumThree</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> api = &#123;</span><br><span class="line">    sumTwo,</span><br><span class="line">    sumThree</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> api;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Which is the same as</span><br><span class="line"> * export &#123; api as default &#125;;</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>最佳实践</strong>：总是在模块的最后面使用 <code>export default</code> 方法，这可以让暴露的东西更加清晰并且可以节省时间去找出暴露出来值的名字。尤其如此，在 CommonJS 中通常的实践就是暴露一个简单的值或者对象。坚持这种模式，可以让我们的代码更加可读，并且在 ES6 和 CommonJS 模块之间更好地兼容。</p>
</blockquote>
<h3 id="ES6_中的导入">ES6 中的导入</h3><p>在 ES6 中同样提供了多样的导入方式，我们可以这么导入一个整个文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'underscore'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要着重注意的一点是简单的导入整个文件会在那个文件的顶部执行所有的代码</p>
</blockquote>
<p>和 Python 中类似，我们可以命名导入的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sumTwo, sumThree &#125; <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br></pre></td></tr></table></figure>
<p>我们还可以重命名导入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    sumTwo <span class="keyword">as</span> addTwoNumbers,</span><br><span class="line">    sumThree <span class="keyword">as</span> sumThreeNumbers</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br></pre></td></tr></table></figure>
<p>另外，我们可以导入所有的东西（整体加载）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> util <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以从一个模块中导入一个值的列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> additionUtil <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; sumTwo, sumThree &#125; = additionUtil;</span><br></pre></td></tr></table></figure>
<p>可以像这样导入默认绑定的输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br><span class="line">// Same <span class="keyword">as</span>: <span class="keyword">import</span> &#123; default <span class="keyword">as</span> api &#125; <span class="keyword">from</span> <span class="string">'math/addition'</span>;</span><br></pre></td></tr></table></figure>
<p>虽然最好保持出口的简单，但如果需要的话我们有时可以混合默认的进口和混合进口。当我们这样出口的时候：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foos.js</span></span><br><span class="line"><span class="literal">export</span> &#123; foo <span class="literal">as</span> <span class="keyword">default</span>, foo1, foo2 &#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以这样导入它们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> foo, &#123; foo1, foo2 &#125; <span class="keyword">from</span> <span class="string">'foos'</span>;</span><br></pre></td></tr></table></figure>
<p>当我们用 commonjs 的语法导入一个模块的出口时（比如 React），我们可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; Component, PropTypes &#125; = React;</span><br></pre></td></tr></table></figure>
<p>还有更精简的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：导出的值是动态引用的，而不是拷贝。因此，在一个模块中改变一个变量的绑定将影响输出模块中的值。应该避免改变这些导出值的公共接口。（原文这里我觉得有误）</p>
</blockquote>
<h2 id="参数">参数</h2><p>在 ES5 中，在函数中我们需要各种操作去处理 <strong><em>默认参数</em></strong>、<strong><em>不定参数</em></strong> 和 <strong><em>重命名参数</em></strong> 等需求，在 ES6 中我们可以使用更简洁的语法完成这些需求：</p>
<h3 id="默认参数">默认参数</h3><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwoNumbers</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    x = x || <span class="number">0</span>;</span><br><span class="line">    y = y || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 中，函数的参数可以支持设置默认值：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTwoNumbers</span><span class="params">(x=0, y=0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">addTwoNumbers(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 6</span></span><br><span class="line">addTwoNumbers(<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line">addTwoNumbers(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h3 id="rest_参数">rest 参数</h3><p>在 ES5 中，我们需要这么处理不定参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArguments</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <strong>rest</strong> ，我们就可以处理不确定数目的参数：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArguments</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (let arg of args) &#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命名参数">命名参数</h3><p>在 ES5 中是使用配置对象的模式来处理命名参数，jQuery 中的使用：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeCanvas</span><span class="params">(options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> height = options.height || <span class="number">600</span>;</span><br><span class="line">    <span class="keyword">var</span> width  = options.width  || <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">var</span> lineStroke = options.lineStroke || <span class="string">'black'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以利用解构的一个函数的形参实现相同的功能：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeCanvas</span><span class="params">(</span><br><span class="line">    &#123; height=600, width=400, lineStroke=<span class="string">'black'</span>&#125;)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use variables height, width, lineStroke here</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想使整个值可选择，我们可以结构将一个空的对象：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initializeCanvas</span><span class="params">(</span><br><span class="line">    &#123; height=600, width=400, lineStroke=<span class="string">'black'</span>&#125; = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="展开操作">展开操作</h3><p>在 ES5 中，我们可以 <code>apply</code> <code>Math.max</code> 方法来获得一个数组中的最大值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Math.max.apply(null, [-<span class="number">1</span>, <span class="number">100</span>, <span class="number">9001</span>, -<span class="number">32</span>]); <span class="comment">// 9001</span></span><br></pre></td></tr></table></figure>
<p>在 ES6 中，我们可以通过展开操作把一个数组的值作为参数传递给一个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Math.max(...[-<span class="number">1</span>, <span class="number">100</span>, <span class="number">9001</span>, -<span class="number">32</span>]); <span class="comment">// 9001</span></span><br></pre></td></tr></table></figure>
<p>我们可以更简洁地使用这个语法来合并数组：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="atom">let</span> <span class="atom">cities</span> = [<span class="string">'San Francisco'</span>, <span class="string">'Los Angeles'</span>];</span><br><span class="line"><span class="atom">let</span> <span class="atom">places</span> = [<span class="string">'Miami'</span>, ...<span class="atom">cities</span>, <span class="string">'Chicago'</span>]; // [<span class="string">'Miami'</span>, <span class="string">'San Francisco'</span>, <span class="string">'Los Angeles'</span>, <span class="string">'Chicago'</span>]</span><br></pre></td></tr></table></figure>
<h2 id="类_Classes">类 Classes</h2><p>在 ES6 之前，我们通过构造函数来创造一个类，并且通过原型来扩展属性：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, gender)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name   = name;</span><br><span class="line">    <span class="keyword">this</span>.age    = age;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.incrementAge = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age += <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后可以这样继承类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Personal</span>(<span class="params">name, age, gender, occupation, hobby</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, age, gender);</span><br><span class="line">    <span class="keyword">this</span>.occupation = occupation;</span><br><span class="line">    <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Personal.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Personal.prototype.constructor = Personal;</span><br><span class="line">Personal.prototype.incrementAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    Person.prototype.incrementAge.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.age += <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 ES6 中，提供了更多的语法糖，可以直接创造一个类：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(name, age, gender) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name   = name;</span><br><span class="line">        <span class="keyword">this</span>.age    = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incrementAge() &#123;</span><br><span class="line">      <span class="keyword">this</span>.age += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>extends</code> 关键字来继承一个类：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Personal</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    constructor(name, age, gender, occupation, hobby) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age, gender);</span><br><span class="line">        <span class="keyword">this</span>.occupation = occupation;</span><br><span class="line">        <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incrementAge() &#123;</span><br><span class="line">        <span class="keyword">super</span>.incrementAge();</span><br><span class="line">        <span class="keyword">this</span>.age += <span class="number">20</span>;</span><br><span class="line">        console.log(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>最佳实践</strong>：虽然使用 ES6 的语法创造类的时候，js引擎是如何实现类以及如何操作原型是令人费解的，但是未来对初学者来说这是一个好的开始，同时也可以让我们写更简洁的代码。</p>
</blockquote>
<h2 id="Symbols">Symbols</h2><p><code>Symbols</code> 在 ES6 之前就已经存在，但是我们现在可以直接使用一个开发的接口了。<code>Symbols</code> 是不可改变并且是独一无二的，可以在任意哈希中作一个key。</p>
<h3 id="Symbol()">Symbol()</h3><p>调用 <code>Symbol()</code> 或者 <code>Symbol(description)</code> 可以创造一个独一无二的符号，但是在全局是看不到的。<code>Symbol()</code> 的一个使用情况是给一个类或者命名空间打上补丁，但是可以确定的是你不会去更新它。比如，你想给 <code>React.Component</code> 类添加一个 <code>refreshComponent</code> 方法，但是可以确定的是你不会在之后更新这个方法：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">const refreshComponent = Symbol();</span><br><span class="line"></span><br><span class="line">React.Component.prototype[refreshComponent] = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Symbol-for(key)">Symbol.for(key)</h3><p><code>Symbol.for(key)</code> 同样会创造一个独一无二并且不可改变的 Symbol，但是它可以全局看到，两个相同的调用 <code>Symbol.for(key)</code> 会返回同一个 <code>Symbol</code> 类：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>对于 Symbols 的普遍用法（尤其是<code>Symbol.for(key)</code>）是为了协同性。它可以通过在一个第三方插件中已知的接口中对象中的参数中寻找用 Symbol 成员来实现，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reader</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> specialRead = <span class="built_in">Symbol</span>.for(<span class="string">'specialRead'</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj[specialRead]) &#123;</span><br><span class="line">        <span class="keyword">const</span> reader = obj[specialRead]();</span><br><span class="line">        <span class="comment">// do something with reader</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'object cannot be read'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在另一个库中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> specialRead = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'specialRead'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeReadableType</span> </span>&#123;</span><br><span class="line">    [specialRead]() &#123;</span><br><span class="line">        <span class="keyword">const</span> reader = createSomeReaderFrom(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> reader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Maps">Maps</h2><p>Maps 在 JavaScript 中是一个非常必须的数据结构，在 ES6 之前，我们通过对象来实现哈希表：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">map</span> = <span class="built_in">new</span> Object();</span><br><span class="line"><span class="keyword">map</span>[key1] = <span class="string">'value1'</span>;</span><br><span class="line"><span class="keyword">map</span>[key2] = <span class="string">'value2'</span>;</span><br></pre></td></tr></table></figure>
<p>但是它并不能防止我们偶然地用一些特殊的属性名重写函数：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">&gt; getOwnProperty(&#123; <span class="attribute">hasOwnProperty</span>: <span class="string">'Hah, overwritten'</span>&#125;, <span class="string">'Pwned'</span>);</span><br><span class="line">&gt; <span class="attribute">TypeError</span>: Property <span class="string">'hasOwnProperty'</span> <span class="keyword">is</span> <span class="keyword">not</span> a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>
<p>实际上 <strong>Maps</strong> 允许我们对值进行 <code>set</code>、<code>get</code> 和 <code>search</code> 操作：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>();</span><br><span class="line">&gt; <span class="built_in">map</span><span class="built_in">.</span><span class="built_in">set</span>(<span class="string">'name'</span>, <span class="string">'david'</span>);</span><br><span class="line">&gt; <span class="built_in">map</span><span class="built_in">.</span>get(<span class="string">'name'</span>); <span class="comment">// david</span></span><br><span class="line">&gt; <span class="built_in">map</span><span class="built_in">.</span>has(<span class="string">'name'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>Maps</strong> 更令人惊奇的部分就是它不仅限于使用字符串作为 key，还可以用其他任何类型的数据作为 key：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'name'</span>, <span class="string">'david'</span>],</span><br><span class="line">    [<span class="literal">true</span>, <span class="string">'false'</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">    [&#123;&#125;, <span class="string">'object'</span>],</span><br><span class="line">    [<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="string">'function'</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> key);</span><br><span class="line">    <span class="comment">// &gt; string, boolean, number, object, function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：但我们使用 <code>map.get()</code> 方法去测试相等时，如果在 Maps 中使用 函数 或者 对象 等非原始类型值的时候测试将不起作用，所以我们应该使用 Strings, Booleans 和 Numbers 这样的原始类型的值。</p>
</blockquote>
<p>我们还可以使用 <code>.entries()</code> 来遍历迭代：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, <span class="keyword">value</span>] <span class="keyword">of</span> <span class="keyword">map</span>.entries()) &#123;</span><br><span class="line">    console.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WeakMaps">WeakMaps</h2><p>在 ES6 之前，为了存储私有变量，我们有各种各样的方法去实现，其中一种方法就是用命名约定：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(age) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _incrementAge() &#123;</span><br><span class="line">        <span class="keyword">this</span>._age += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是命名约定在代码中仍然会令人混淆并且并不会真正的保持私有变量不被访问。现在，我们可以使用 <strong>WeakMaps</strong>  来存储变量：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _age = <span class="keyword">new</span> WeakMap();</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(age) </span>&#123;</span><br><span class="line">        _age.set(<span class="keyword">this</span>, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incrementAge() &#123;</span><br><span class="line">        <span class="keyword">let</span> age = _age.get(<span class="keyword">this</span>) + <span class="number">1</span>;</span><br><span class="line">        _age.set(<span class="keyword">this</span>, age);</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">50</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Midlife crisis'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 WeakMaps 存储变量很酷的一件事是它的 key 他不需要属性名称，可以使用 <code>Reflect.ownKeys()</code> 来查看这一点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="number">50</span>);</span><br><span class="line">&gt; person.incrementAge(); <span class="comment">// 'Midlife crisis'</span></span><br><span class="line">&gt; Reflect.ownKeys(person); <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>一个更实际的实践就是可以 WeakMaps 储存 DOM 元素，而不会污染元素本身：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> WeakMap();</span><br><span class="line"><span class="keyword">let</span> el  = document<span class="built_in">.</span>getElementById(<span class="string">'someElement'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store a weak reference to the element with a key</span></span><br><span class="line"><span class="built_in">map</span><span class="built_in">.</span><span class="built_in">set</span>(el, <span class="string">'reference'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Access the value of the element</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="built_in">map</span><span class="built_in">.</span>get(el); <span class="comment">// 'reference'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove the reference</span></span><br><span class="line">el<span class="built_in">.</span>parentNode<span class="built_in">.</span>removeChild(el);</span><br><span class="line">el = <span class="built_in">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map is empty, since the element is destroyed</span></span><br></pre></td></tr></table></figure>
<p>如上所示，当一个对象被垃圾回收机制销毁的时候， WeakMap 将会自动地一处关于这个对象地键值对。</p>
<blockquote>
<p><strong>注意</strong>：为了进一步说明这个例子的实用性，可以考虑 jQuery 是如何实现缓存一个对象相关于对引用地 DOM 元素对象。使用 jQuery ，当一个特定地元素一旦在 document 中移除的时候，jQuery 会自动地释放内存。总体来说，jQuery 在任何 dom 库中都是很有用的。</p>
</blockquote>
<h2 id="Promises">Promises</h2><p>Promises 可以让我们远离平行的代码（回调地狱）：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">func1<span class="list">(<span class="keyword">function</span> <span class="list">(<span class="keyword">value1</span>)</span> &#123;</span><br><span class="line">    func2<span class="list">(<span class="keyword">value1</span>, function <span class="list">(<span class="keyword">value2</span>)</span> &#123;</span><br><span class="line">        func3<span class="list">(<span class="keyword">value2</span>, function <span class="list">(<span class="keyword">value3</span>)</span> &#123;</span><br><span class="line">            func4<span class="list">(<span class="keyword">value3</span>, function <span class="list">(<span class="keyword">value4</span>)</span> &#123;</span><br><span class="line">                func5<span class="list">(<span class="keyword">value4</span>, function <span class="list">(<span class="keyword">value5</span>)</span> &#123;</span><br><span class="line">                    // Do something with value <span class="number">5</span></span><br><span class="line">                &#125;)</span><span class="comment">;</span></span><br><span class="line">            &#125;)</span><span class="comment">;</span></span><br><span class="line">        &#125;)</span><span class="comment">;</span></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>转变成垂直代码：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">func<span class="number">1</span>(<span class="keyword">value</span><span class="number">1</span>)</span><br><span class="line">    .<span class="keyword">then</span>(func<span class="number">2</span>)</span><br><span class="line">    .<span class="keyword">then</span>(func<span class="number">3</span>)</span><br><span class="line">    .<span class="keyword">then</span>(func<span class="number">4</span>)</span><br><span class="line">    .<span class="keyword">then</span>(func<span class="number">5</span>, <span class="keyword">value</span><span class="number">5</span> =&gt; &#123;</span><br><span class="line">        <span class="comment">// Do something with value 5</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>在 ES6 之前，我们使用 <a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="external">bluebird</a> 或者 <a href="https://github.com/kriskowal/q" target="_blank" rel="external">q</a>，现在我们可以使用原生的 <strong>Promise</strong> 了。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span></span><br><span class="line">    reject(<span class="keyword">new</span> Error(<span class="string">'Failed to fulfill Promise'</span>)))</span><br><span class="line">        .<span class="keyword">catch</span>(reason =&gt; <span class="built_in">console</span>.log(reason));</span><br></pre></td></tr></table></figure>
<p>我们有两个处理器，<code>resolve</code>（当Promise是 <code>fulfilled</code> 时的回调）和 <code>reject</code>（当Promise是 <code>rejected</code> 时的回调）：。</p>
<blockquote>
<p><strong>Promises的好处</strong>：对错误的处理使用一些列回调会使代码很混乱，使用 Promise ，我看可以清晰的让错误冒泡并且在合适的时候处理它，甚至，在 Promise 确定了  resolved/rejected 之后，他的值是不可改变的－－它从来不会变化。</p>
</blockquote>
<p>这是使用 Promise 的一个实际的栗子：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">var request = require<span class="list">(<span class="quoted">'request</span>')</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">return new Promise<span class="list">(<span class="list">(<span class="keyword">resolve</span>, reject)</span> =&gt; &#123;</span><br><span class="line">  request.get<span class="list">(<span class="keyword">url</span>, <span class="list">(<span class="keyword">error</span>, response, body)</span> =&gt; &#123;</span><br><span class="line">    if <span class="list">(<span class="keyword">body</span>)</span> &#123;</span><br><span class="line">        resolve<span class="list">(<span class="keyword">JSON</span>.parse<span class="list">(<span class="keyword">body</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve<span class="list">(&#123;&#125;)</span><span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>我们还可以使用 <code>Promise.all()</code> 来 <code>并行</code> 处理多个异步函数：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">let urls = [</span><br><span class="line">  <span class="string">'/api/commits'</span>,</span><br><span class="line">  <span class="string">'/api/issues/opened'</span>,</span><br><span class="line">  <span class="string">'/api/issues/assigned'</span>,</span><br><span class="line">  <span class="string">'/api/issues/completed'</span>,</span><br><span class="line">  <span class="string">'/api/issues/comments'</span>,</span><br><span class="line">  <span class="string">'/api/pullrequests'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let promises = urls.map(<span class="function"><span class="params">(url)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    $.ajax(&#123; <span class="attribute">url</span>: url &#125;)</span><br><span class="line">      .done(<span class="function"><span class="params">(data)</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="params">(results)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> Do something with results <span class="keyword">of</span> all our promises</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Generators_生成器">Generators 生成器</h2><p>就像 Promises  可以帮我们避免回调地狱，Generators 可以帮助我们让代码风格更整洁－－用同步的代码风格来写异步代码，它本质上是一个可以暂停计算并且可以随后返回表达式的值的函数。</p>
<p>一个简单的栗子使用 generators：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">function* sillyGenerator() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var generator = sillyGenerator();</span><br><span class="line">&gt; console.log(generator.<span class="keyword">next</span>()); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="number">1</span>, <span class="symbol">done:</span> <span class="literal">false</span> &#125;</span><br><span class="line">&gt; console.log(generator.<span class="keyword">next</span>()); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="number">2</span>, <span class="symbol">done:</span> <span class="literal">false</span> &#125;</span><br><span class="line">&gt; console.log(generator.<span class="keyword">next</span>()); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="number">3</span>, <span class="symbol">done:</span> <span class="literal">false</span> &#125;</span><br><span class="line">&gt; console.log(generator.<span class="keyword">next</span>()); <span class="regexp">//</span> &#123; <span class="symbol">value:</span> <span class="number">4</span>, <span class="symbol">done:</span> <span class="literal">false</span> &#125;</span><br></pre></td></tr></table></figure>
<p><code>next</code> 可以回去到下一个 <code>yield</code> 返回的值，当然上面的代码是非常不自然的，我们可以利用 Generators 来用同步的方式来写异步操作：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hiding asynchronousity with Generators</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">    getJSON(url, <span class="function"><span class="keyword">function</span><span class="params">(response)</span> </span>&#123;</span><br><span class="line">        generator.next(response);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 generator 函数将会返回需要的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> entry1 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item1'</span>);</span><br><span class="line">    <span class="keyword">var</span> data1  = <span class="built_in">JSON</span>.parse(entry1);</span><br><span class="line">    <span class="keyword">var</span> entry2 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item2'</span>);</span><br><span class="line">    <span class="keyword">var</span> data2  = <span class="built_in">JSON</span>.parse(entry2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>yield</code>，我们可以保证 <code>entry1</code> 有 <code>data1</code> 中我们需要解析并储存的数据。</p>
<p>虽然我们可以利用 Generators 来用同步的方式来写异步操作，但是确认错误的传播变得不再清晰，我们可以在 Generators 中加上 Promise：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">        getJSON(url, resolve);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们写一个函数逐步调用 <code>next</code> 并且利用 request 方法产生一个 Promise：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterateGenerator</span><span class="params">(gen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> generator = gen();</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">iterate</span><span class="params">(val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = generator.next();</span><br><span class="line">        <span class="keyword">if</span>(!ret.done) &#123;</span><br><span class="line">            ret.value.then(iterate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Generators 中加上 Promise 之后我们可以更清晰的使用 Promise 中的 <code>.catch</code> 和 <code>reject</code>来捕捉错误，让我们使用新的 Generator，和之前的还是蛮相似的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">iterateGenerator(<span class="function"><span class="keyword">function</span>* <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> entry1 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item1'</span>);</span><br><span class="line">    <span class="keyword">var</span> data1  = <span class="built_in">JSON</span>.parse(entry1);</span><br><span class="line">    <span class="keyword">var</span> entry2 = <span class="keyword">yield</span> request(<span class="string">'http://some_api/item2'</span>);</span><br><span class="line">    <span class="keyword">var</span> data2  = <span class="built_in">JSON</span>.parse(entry2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Async_Await">Async Await</h2><p>当 ES6 真正到来的时候，<code>async await</code> 可以用更少的处理实现  Promise 和  Generators 所实现的异步处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    request(url, <span class="function"><span class="keyword">function</span>(<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">      resolve(body);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> getJSON();</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// NOT undefined!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
<p>在 js 引擎中，它所实现的和 Generators 其实是一样的，我更推荐在 <code>Generators + Promises</code> 之上使用 <code>async await</code>，更多的资源和使用 ES7 和 用 babel 转化可以<a href="http://masnun.com/2015/11/11/using-es7-asyncawait-today-with-babel.html" target="_blank" rel="external">看这里</a>。</p>
<h2 id="Getter/Setter_函数">Getter/Setter 函数</h2><p>ES6 已经开始实现了 <code>getter</code> 和 <code>setter</code> 函数，比如虾面这个栗子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line"></span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(name) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> name() &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>._name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Mr. '</span> + <span class="keyword">this</span>._name.toUpperCase();  </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> name(newName) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newName == <span class="keyword">this</span>._name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I already have this name.'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newName) &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = newName;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emp = <span class="keyword">new</span> Employee(<span class="string">"James Bond"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// uses the get method in the background</span></span><br><span class="line"><span class="keyword">if</span> (emp.name) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(emp.name);  <span class="comment">// Mr. JAMES BOND</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// uses the setter in the background</span></span><br><span class="line">emp.name = <span class="string">"Bond 007"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(emp.name);  <span class="comment">// Mr. BOND 007</span></span><br></pre></td></tr></table></figure>
<p>最新版本的浏览器也在对象中实现了 <code>getter</code> 和 <code>setter</code> 函数，我们可以使用它们来实现 <strong>计算属性</strong>，在设置和获取一个属性之前加上监听器和处理。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'James'</span>,</span><br><span class="line">  lastName: <span class="string">'Bond'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">fullName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      console.log(<span class="string">'Getting FullName'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">set</span> <span class="title">fullName</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      console.log(<span class="string">'Setting FullName'</span>);</span><br><span class="line">      <span class="keyword">var</span> words = name.toString().split(<span class="string">' '</span>);</span><br><span class="line">      <span class="keyword">this</span>.firstName = words[<span class="number">0</span>] || <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">this</span>.lastName = words[<span class="number">1</span>] || <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.fullName; <span class="comment">// James Bond</span></span><br><span class="line">person.fullName = <span class="string">'Bond 007'</span>;</span><br><span class="line">person.fullName; <span class="comment">// Bond 007</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="tip">tip</h1><p>文章是翻译，主要是很多 ES6 的用法技巧以及最佳实践～<br>原文 <a href="https://github.com/DrkSephy/es6-cheatsheet" target="_blank" rel="externa]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://qiutc.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[移动端图片上传的实践]]></title>
    <link href="http://qiutc.me/post/uploading-image-file-in-mobile-fe.html"/>
    <id>http://qiutc.me/post/uploading-image-file-in-mobile-fe.html</id>
    <published>2016-06-01T13:27:45.000Z</published>
    <updated>2016-07-28T10:54:27.000Z</updated>
    <content type="html"><![CDATA[<h1 id="TIP">TIP</h1><p>最近在一个项目中需要实现一个移动端上传图片文件的需求，主要需求的是压缩并且按照比例自动裁切图片然后上传。<br>一听是蛮简单的，因为是在移动端使用，所以完全可以使用 HTML5 的新特性以及一些 API。<br>主要的思路是这样：</p>
<ol>
<li>监听一个 <code>input (type=&#39;file&#39;)</code> 的 <code>change</code> 事件，然后拿到文件的 <code>file</code>;</li>
<li>把 <code>file</code> 转成 <code>dataURL</code>；</li>
<li>然后用 <code>canvas</code> 绘制图片，绘制的时候经过算法按比例裁剪;</li>
<li>然后再把 <code>canvas</code> 转成 <code>dataURL</code>;</li>
<li>再把 <code>dataURL</code> 转成 <code>blob</code>;</li>
<li>接着把 <code>blob</code> <code>append</code> 到 <code>FormData</code> 的实例对象。</li>
<li>最后上传。</li>
</ol>
<p>主要用到的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" target="_blank" rel="external"><code>FileReader</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Canvas" target="_blank" rel="external"><code>canvas</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData" target="_blank" rel="external"><code>FormData</code></a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob" target="_blank" rel="external"><code>Blob</code></a> 这几个 API。</p>
<p>开发过程遇到了蛮多坑，特别是在android下的微信浏览器内。</p>
<h1 id="监听_input(type=file)_获取文件内容。">监听 input(type=file) 获取文件内容。</h1><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html 片段</span></span><br><span class="line"></span><br><span class="line">&lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"file"</span> id=<span class="string">"file-input"</span> name=<span class="string">"image"</span> accept=<span class="string">"image/gif, image/jpeg, image/png"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>对于 <code>type</code> 为 <code>file</code> 的 <code>input</code> 我们可以设置 <code>accept</code> 属性来现在我们要上传的文件类型，这里的目的是上传图片文件，所以我们可以设置：<code>accept=&quot;image/gif, image/jpeg, image/png&quot;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'file-input'</span>).onchange= <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 event.target 回去 input 元素对象，然后拿到 files list，取第一个 file</span></span><br><span class="line">  <span class="keyword">let</span> file = event.target.files[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// compressImage 在下面解释，它接受三个参数，文件、裁剪的长宽比例，回调函数（回调函数获得一个 FormData 对象，文件已经存在里面了）；</span></span><br><span class="line">  compressImage(file, [<span class="number">1</span>, <span class="number">1</span>], (targetFormData) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...... 这里获取到了 targetFormData，就可以直接使用它上传了</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="fileToDataURL：_file_转成_dataURL">fileToDataURL： file 转成 dataURL</h1><p>这里用到的是 <code>FileReader</code> 这个 API。<br><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/API/FileReader</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * file 转成 dataURL</span><br><span class="line"> * <span class="doctag">@param</span> file 文件</span><br><span class="line"> * <span class="doctag">@param</span> callback 回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileToDataURL</span> <span class="params">(file, callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> window.FileReader();</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span><br><span class="line">    callback(e.target.result);</span><br><span class="line">  &#125;;</span><br><span class="line">  reader.readAsDataURL(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="compressDataURL：dataURL_图片绘制_canvas，然后经过处理（裁剪_&amp;_压缩）再转成_dataURL">compressDataURL：dataURL 图片绘制 canvas，然后经过处理（裁剪 &amp; 压缩）再转成 dataURL</h1><p>一开始是这样的</p>
<ol>
<li>我们需要创建一个 <code>Image</code> 对象，然后把 <code>src</code> 设置成 <code>dataURL</code> ，获取到这张图片；</li>
<li>我们需要创建一个 <code>canvas</code> 元素，用来处理绘制图片；</li>
<li>获取裁剪的长宽比例，然后判断图片的实际长宽比例，按照最大化偏小的长或宽然后另一边采取中间部分，和 css 把 background 设置 center / cover 一个道理；</li>
<li>调用<code>ctx.drawImage</code>绘制图片；</li>
<li>使用 <code>canvas.toDataURL</code> 把 <code>canvans</code> 转成 <code>dataURL</code>。</li>
</ol>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 使用 canvas 压缩处理 dataURL</span><br><span class="line"> * <span class="doctag">@param</span> dataURL</span><br><span class="line"> * <span class="doctag">@param</span> ratio 比例</span><br><span class="line"> * <span class="doctag">@param</span> callback</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressDataURL</span> <span class="params">(dataURL, ratio, callback)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> window.Image();</span><br><span class="line">  img.src = dataURL;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">const</span> canvas = document.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  canvas.width = <span class="number">100</span> * ratio[<span class="number">0</span>];</span><br><span class="line">  canvas.height = <span class="number">100</span> * ratio[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">const</span> RATIO = canvas.width / canvas.height;</span><br><span class="line">  <span class="keyword">let</span> cutx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> cuty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> cutw = img.width;</span><br><span class="line">  <span class="keyword">let</span> cuth = img.height;</span><br><span class="line">  <span class="keyword">if</span> (cutw / cuth &gt; RATIO) &#123;</span><br><span class="line">    <span class="comment">// 宽超过比例了]]</span></span><br><span class="line">    <span class="keyword">let</span> realw = cuth * RATIO;</span><br><span class="line">    cutx = (cutw - realw) / <span class="number">2</span>;</span><br><span class="line">    cutw = realw;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cutw / cuth &lt; RATIO) &#123;</span><br><span class="line">    <span class="comment">// 长超过比例了]]</span></span><br><span class="line">    <span class="keyword">let</span> realh = cutw / RATIO;</span><br><span class="line">    cuty = (cuth - realh) / <span class="number">2</span>;</span><br><span class="line">    cuth = realh;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  ctx.drawImage(img, cutx, cuty, cutw, cuth, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  <span class="keyword">const</span> ndata = canvas.toDataURL(<span class="string">'image/jpeg'</span>, <span class="number">1</span>);</span><br><span class="line">  callback(ndata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切的运行在pc端的chrome浏览器下模拟都很好，但是在移动端测试的时候发现 <code>canvas</code> 无法绘制出图片，发现是 <code>img</code> 设置 <code>src</code> 有延迟，导致还没获取到图片图像就开始绘制。<br><strong>改进：监听 <code>img.onload</code> 事件来处理之后的操作：</strong><br><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 使用 canvas 压缩 dataURL</span><br><span class="line"> * <span class="doctag">@param</span> dataURL</span><br><span class="line"> * <span class="doctag">@param</span> ratio</span><br><span class="line"> * <span class="doctag">@param</span> callback</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressDataURL</span> <span class="params">(dataURL, ratio, callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> img = <span class="keyword">new</span> window.Image();</span><br><span class="line">  img.src = dataURL;</span><br><span class="line">  <span class="comment">// onload</span></span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> canvas = document.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">    <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    canvas.width = <span class="number">100</span> * ratio.width;</span><br><span class="line">    canvas.height = <span class="number">100</span> * ratio.height;</span><br><span class="line">    <span class="keyword">const</span> RATIO = canvas.width / canvas.height;</span><br><span class="line">    <span class="keyword">let</span> cutx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> cuty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> cutw = img.width;</span><br><span class="line">    <span class="keyword">let</span> cuth = img.height;</span><br><span class="line">    <span class="keyword">if</span> (cutw / cuth &gt; RATIO) &#123;</span><br><span class="line">      <span class="comment">// 宽超过比例了]]</span></span><br><span class="line">      <span class="keyword">let</span> realw = cuth * RATIO;</span><br><span class="line">      cutx = (cutw - realw) / <span class="number">2</span>;</span><br><span class="line">      cutw = realw;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cutw / cuth &lt; RATIO) &#123;</span><br><span class="line">      <span class="comment">// 长超过比例了]]</span></span><br><span class="line">      <span class="keyword">let</span> realh = cutw / RATIO;</span><br><span class="line">      cuty = (cuth - realh) / <span class="number">2</span>;</span><br><span class="line">      cuth = realh;</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.drawImage(img, cutx, cuty, cutw, cuth, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">    <span class="keyword">const</span> ndata = canvas.toDataURL(<span class="string">'image/jpeg'</span>, <span class="number">1</span>);</span><br><span class="line">    callback(ndata);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="dataURLtoBlob：dataURL_转成_Blob">dataURLtoBlob：dataURL 转成 Blob</h1><p>这一步我们把 <code>dataURL</code> 转成 <code>Blob</code></p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * dataURL 转成 blob</span><br><span class="line"> * @param dataURL</span><br><span class="line"> * @<span class="keyword">return</span> blob</span><br><span class="line"> */</span><br><span class="line">function dataURLtoBlob (dataURL) &#123;</span><br><span class="line">  <span class="keyword">let</span> binaryString = atob(dataURL.split(',')[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> arrayBuffer = new <span class="type">ArrayBuffer</span>(binaryString.length);</span><br><span class="line">  <span class="keyword">let</span> intArray = new <span class="type">Uint8Array</span>(arrayBuffer);</span><br><span class="line">  <span class="keyword">let</span> mime = dataURL.split(',')[<span class="number">0</span>].match(/:(.*?);/)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = binaryString.length; i &lt; j; i++) &#123;</span><br><span class="line">    intArray[i] = binaryString.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> data = [intArray];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="literal">result</span> = new <span class="type">Blob</span>(data, &#123; <span class="keyword">type</span>: mime &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很完美了吗，在pc端模拟成功，在移动端chrome浏览器测试成功，但是在微信浏览器中失败，经过 <code>try...catch</code> 发现是在 new <code>Blob</code> 的时候失败。<br>查看之后发现是这个 API 对 Android 的支持还不明。<br>解决方法是利用 <code>BlobBuilder</code> 这个老 API 来解决：<a href="https://developer.mozilla.org/en-US/docs/Web/API/BlobBuilder" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/API/BlobBuilder</a><br>因为这个 API 已经被遗弃，不同机型和安卓版本兼容性不一致，所以需要一个判断。<br><strong>解决方法：</strong><br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * dataURL 转成 blob</span><br><span class="line"> * @param dataURL</span><br><span class="line"> * @<span class="keyword">return</span> blob</span><br><span class="line"> */</span><br><span class="line">function dataURLtoBlob (dataURL) &#123;</span><br><span class="line">  <span class="keyword">let</span> binaryString = atob(dataURL.split(',')[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> arrayBuffer = new <span class="type">ArrayBuffer</span>(binaryString.length);</span><br><span class="line">  <span class="keyword">let</span> intArray = new <span class="type">Uint8Array</span>(arrayBuffer);</span><br><span class="line">  <span class="keyword">let</span> mime = dataURL.split(',')[<span class="number">0</span>].match(/:(.*?);/)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = binaryString.length; i &lt; j; i++) &#123;</span><br><span class="line">    intArray[i] = binaryString.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> data = [intArray];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="literal">result</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="literal">result</span> = new <span class="type">Blob</span>(data, &#123; <span class="keyword">type</span>: mime &#125;);</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    window.<span class="type">BlobBuilder</span> = window.<span class="type">BlobBuilder</span> ||</span><br><span class="line">      window.<span class="type">WebKitBlobBuilder</span> ||</span><br><span class="line">      window.<span class="type">MozBlobBuilder</span> ||</span><br><span class="line">      window.<span class="type">MSBlobBuilder</span>;</span><br><span class="line">    <span class="keyword">if</span> (error.name === '<span class="type">TypeError</span>' &amp;&amp; window.<span class="type">BlobBuilder</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> builder = new <span class="type">BlobBuilder</span>();</span><br><span class="line">      builder.append(arrayBuffer);</span><br><span class="line">      <span class="literal">result</span> = builder.getBlob(<span class="keyword">type</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      throw new <span class="type">Error</span>('没救了');</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="把获取到的_blob_append_到_FormData_实例，执行回调">把获取到的 blob append 到 FormData 实例，执行回调</h1><p>这一步使用到我们之前的东西。<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 压缩图片</span><br><span class="line"> * <span class="doctag">@param</span> file 图片文件</span><br><span class="line"> * <span class="doctag">@param</span> ratio 比例</span><br><span class="line"> * <span class="doctag">@param</span> callback 回调，得到一个 包含文件的 FormData 实例</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressImage</span> <span class="params">(file, ratio, callback)</span> </span>&#123;</span><br><span class="line">  fileToDataURL(file, (dataURL) =&gt; &#123;</span><br><span class="line">    compressDataURL(dataURL, ratio, (newDataURL) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> newBlob = dataURLtoBlob(newDataURL);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> oData = <span class="keyword">new</span> FormData();</span><br><span class="line">      oData.append(<span class="string">'file'</span>, blob);</span><br><span class="line"></span><br><span class="line">      callback(oData);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="回到第一步，上传文件">回到第一步，上传文件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'file-input'</span>).onchange= <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 event.target 回去 input 元素对象，然后拿到 files list，取第一个 file</span></span><br><span class="line">  <span class="keyword">let</span> file = event.target.files[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 接受三个参数，文件、裁剪的长宽比例，回调函数（回调函数获得一个 FormData 对象，文件已经存在里面了）；</span></span><br><span class="line">  compressImage(file, [<span class="number">1</span>, <span class="number">1</span>], (targetFormData) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度监听</span></span><br><span class="line">    <span class="comment">// xhr.upload.addEventListener('progress', progFoo, false);</span></span><br><span class="line">    <span class="comment">// 加载监听</span></span><br><span class="line">    <span class="comment">// xhr.addEventListener('load', loadFoo, false);</span></span><br><span class="line">    <span class="comment">// 错误监听</span></span><br><span class="line">    <span class="comment">// xhr.addEventListener('error', errorFoo, false);</span></span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">// 上传成功，获取到结果 results</span></span><br><span class="line">          <span class="keyword">let</span> results = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">          <span class="comment">// ......</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 上传失败</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(<span class="string">'POST'</span>, <span class="string">'/api/upload'</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.send(targetFormData);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一切似乎都很完美，pc 端模拟测试通过，但是到移动端却发现上传了一个空文件，这不科学！！！<br>查文档后发现这么一句话：</p>
<blockquote>
<p>Note: XHR in Android 4.0 sends empty content for FormData with blob.</p>
</blockquote>
<p>简直蒙蔽。<br>在 上找到了解决方案：<a href="http://stackoverflow.com/questions/15639070/empty-files-uploaded-in-android-native-browser/28809955#28809955" target="_blank" rel="external">http://stackoverflow.com/questions/15639070/empty-files-uploaded-in-android-native-browser/28809955#28809955</a></p>
<p>通过自己包装 <code>FormDataShim</code> 和重写 <code>XMLHttpRequest.prototype.send</code> 函数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android上的AppleWebKit 534以前的内核存在一个Bug，</span></span><br><span class="line"><span class="comment">// 导致FormData加入一个Blob对象后，上传的文件是0字节</span></span><br><span class="line"><span class="comment">// QQ X5浏览器也有这个BUG</span></span><br><span class="line"><span class="keyword">var</span> needsFormDataShim = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bCheck = ~navigator.userAgent.indexOf(<span class="string">'Android'</span>) &amp;&amp;</span><br><span class="line">               ~navigator.vendor.indexOf(<span class="string">'Google'</span>) &amp;&amp;</span><br><span class="line">              !~navigator.userAgent.indexOf(<span class="string">'Chrome'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bCheck &amp;&amp; navigator.userAgent.match(<span class="regexp">/AppleWebKit\/(\d+)/</span>).pop() &lt;= <span class="number">534</span> || <span class="regexp">/MQQBrowser/g</span>.test(navigator.userAgent);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 Blob 构造函数，在 XMLHttpRequest.prototype.send 中会使用到</span></span><br><span class="line"><span class="keyword">var</span> BlobConstructor = ((<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> Blob();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()) ? <span class="built_in">window</span>.Blob : <span class="function"><span class="keyword">function</span> (<span class="params">parts, opts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bb = <span class="keyword">new</span> (</span><br><span class="line">    <span class="built_in">window</span>.BlobBuilder ||</span><br><span class="line">    <span class="built_in">window</span>.WebKitBlobBuilder ||</span><br><span class="line">    <span class="built_in">window</span>.MSBlobBuilder ||</span><br><span class="line">    <span class="built_in">window</span>.MozBlobBuilder</span><br><span class="line">  );</span><br><span class="line">  parts.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">    bb.append(p);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> bb.getBlob(opts ? opts.type : <span class="literal">undefined</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动包装 FormData 同时重写 XMLHttpRequest.prototype.send</span></span><br><span class="line"><span class="keyword">var</span> FormDataShim = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> formDataShimNums = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">FormDataShim</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Data to be sent</span></span><br><span class="line">    <span class="keyword">let</span> parts = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boundary parameter for separating the multipart values</span></span><br><span class="line">    <span class="keyword">let</span> boundary = <span class="built_in">Array</span>(<span class="number">21</span>).join(<span class="string">'-'</span>) + (+<span class="keyword">new</span> <span class="built_in">Date</span>() * (<span class="number">1e16</span> * <span class="built_in">Math</span>.random())).toString(<span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the current XHR send method so we can safely override it</span></span><br><span class="line">    <span class="keyword">let</span> oldSend = XMLHttpRequest.prototype.send;</span><br><span class="line">    <span class="keyword">this</span>.getParts = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> parts.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span> (<span class="params">name, value, filename</span>) </span>&#123;</span><br><span class="line">      parts.push(<span class="string">'--'</span> + boundary + <span class="string">'\r\nContent-Disposition: form-data; name="'</span> + name + <span class="string">'"'</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Blob) &#123;</span><br><span class="line">        parts.push(<span class="string">'; filename="'</span> + (filename || <span class="string">'blob'</span>) + <span class="string">'"\r\nContent-Type: '</span> + value.type + <span class="string">'\r\n\r\n'</span>);</span><br><span class="line">        parts.push(value);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parts.push(<span class="string">'\r\n\r\n'</span> + value);</span><br><span class="line">      &#125;</span><br><span class="line">      parts.push(<span class="string">'\r\n'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    formDataShimNums++;</span><br><span class="line">    XMLHttpRequest.prototype.send = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> fr;</span><br><span class="line">      <span class="keyword">let</span> data;</span><br><span class="line">      <span class="keyword">let</span> oXHR = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (val === o) &#123;</span><br><span class="line">        <span class="comment">// Append the final boundary string</span></span><br><span class="line">        parts.push(<span class="string">'--'</span> + boundary + <span class="string">'--\r\n'</span>);</span><br><span class="line">        <span class="comment">// Create the blob</span></span><br><span class="line">        data = <span class="keyword">new</span> BlobConstructor(parts);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up and read the blob into an array to be sent</span></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader();</span><br><span class="line">        fr.onload  = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          oldSend.call(oXHR, fr.result);</span><br><span class="line">        &#125;;</span><br><span class="line">        fr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;;</span><br><span class="line">        fr.readAsArrayBuffer(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the multipart content type and boudary</span></span><br><span class="line">        <span class="keyword">this</span>.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'multipart/form-data; boundary='</span> + boundary);</span><br><span class="line">        formDataShimNums--;</span><br><span class="line">        <span class="keyword">if</span> (formDataShimNums === <span class="number">0</span>) &#123;</span><br><span class="line">          XMLHttpRequest.prototype.send = oldSend;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldSend.call(<span class="keyword">this</span>, val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h2 id="SUCCESS">SUCCESS</h2><p><strong>重写 <code>compressImage</code></strong><br><figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 压缩图片</span><br><span class="line"> * <span class="doctag">@param</span> file 图片文件</span><br><span class="line"> * <span class="doctag">@param</span> ratio 比例</span><br><span class="line"> * <span class="doctag">@param</span> callback 回调，得到一个 包含文件的 FormData 实例</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressImage</span> <span class="params">(file, ratio, callback)</span> </span>&#123;</span><br><span class="line">  fileToDataURL(file, (dataURL) =&gt; &#123;</span><br><span class="line">    compressDataURL(dataURL, ratio, (newDataURL) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> newBlob = dataURLtoBlob(newDataURL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是否需要我们之前的重写</span></span><br><span class="line">      <span class="keyword">let</span> NFormData = needsFormDataShim() ? FormDataShim : window.FormData;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> oData = <span class="keyword">new</span> NFormData();</span><br><span class="line">      oData.append(<span class="string">'file'</span>, blob);</span><br><span class="line"></span><br><span class="line">      callback(oData);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这一步总算成功。</p>
<hr>
<p>参考：<br><a href="http://stackoverflow.com/questions/15639070/empty-files-uploaded-in-android-native-browser/28809955#28809955" target="_blank" rel="external">http://stackoverflow.com/questions/15639070/empty-files-uploaded-in-android-native-browser/28809955#28809955</a><br><a href="http://www.alloyteam.com/2015/04/ru-he-zai-yi-dong-web-shang-shang-chuan-wen-jian/" target="_blank" rel="external">http://www.alloyteam.com/2015/04/ru-he-zai-yi-dong-web-shang-shang-chuan-wen-jian/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="TIP">TIP</h1><p>最近在一个项目中需要实现一个移动端上传图片文件的需求，主要需求的是压缩并且按照比例自动裁切图片然后上传。<br>一听是蛮简单的，因为是在移动端使用，所以完全可以使用 HTML5 的新特性以及一些 API。<br>主要的思路是这样：<]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://qiutc.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端跨域的整理]]></title>
    <link href="http://qiutc.me/post/cross-domain-collections.html"/>
    <id>http://qiutc.me/post/cross-domain-collections.html</id>
    <published>2016-05-16T18:09:20.000Z</published>
    <updated>2016-08-10T11:35:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="跨域整理">跨域整理</h1><h1 id="跨域资源共享_CORS">跨域资源共享 CORS</h1><p>对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些hack的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CORS－”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>首先来说 CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是ie10+，其它现代浏览器都是支持的。<br><a href="http://caniuse.com/#feat=cors" target="_blank" rel="external">http://caniuse.com/#feat=cors</a><br><img src="/img/cross-domain-cors.png" alt="cross-domain-cors"><br>使用 CORS 跨域的时候其实和普通的 ajax 过程是一样的，只是浏览器在发现这是一个跨域请求的时候会自动帮我们处理一些事，比如验证等等，所以说只要服务端提供支持，前端是不需要做额外的事情的。</p>
<h2 id="两种请求">两种请求</h2><p>CORS 的请求分两种，这也是浏览器为了安全做的一些处理，不同情况下浏览器执行的操作也是不一样的，主要分为两种请求，当然这一切我们是不需要做额外处理的，浏览器会自动处理的。</p>
<h2 id="简单请求（simple_request）">简单请求（simple request）</h2><p>只要同时满足以下两大条件，就属于简单请求。</p>
<h3 id="条件">条件</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">1) 请求方法是以下三种方法中的一个：</span><br><span class="line">HEAD</span><br><span class="line"><span class="literal">GET</span></span><br><span class="line"><span class="keyword">POST</span></span><br><span class="line">2）HTTP的头信息不超出以下几种字段：</span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-<span class="keyword">Type</span>：只限于三个值application/x-www-<span class="keyword">form</span>-urlencoded、multipart/<span class="keyword">form</span>-data、text/plain</span><br></pre></td></tr></table></figure>
<h3 id="过程">过程</h3><p>对于简单的跨域请求，浏览器会自动在请求的头信息加上 <code>Origin</code> 字段，表示本次请求来自哪个源（协议 + 域名 + 端口），服务端会获取到这个值，然后判断是否同意这次请求并返回。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求</span></span><br><span class="line">GET <span class="regexp">/cors HTTP/</span><span class="number">1.1</span></span><br><span class="line"><span class="string">Origin:</span> <span class="string">http:</span><span class="comment">//api.qiutc.me</span></span><br><span class="line"><span class="string">Host:</span> api.alice.com</span><br><span class="line">Accept-<span class="string">Language:</span> en-US</span><br><span class="line"><span class="string">Connection:</span> keep-alive</span><br><span class="line">User-<span class="string">Agent:</span> Mozilla/<span class="number">5.0</span>...</span><br></pre></td></tr></table></figure>
<h4 id="1-服务端允许">1.服务端允许</h4><p>如果服务端许可本次请求，就会在返回的头信息多出几个字段：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回</span></span><br><span class="line">Access-Control-Allow-<span class="string">Origin:</span> <span class="string">http:</span><span class="comment">//api.qiutc.me</span></span><br><span class="line">Access-Control-Allow-<span class="string">Credentials:</span> <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-<span class="string">Headers:</span> Info</span><br><span class="line">Content-<span class="string">Type:</span> text/html; charset=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>这三个带有 <code>Access-Control</code> 开头的字段分别表示：</p>
<ul>
<li>Access-Control-Allow-Origin<br>必须。它的值是请求时Origin字段的值或者 <code>*</code>，表示接受任意域名的请求。</li>
<li>Access-Control-Allow-Credentials；<br>可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。<br>再需要发送cookie的时候还需要注意要在AJAX请求中打开withCredentials属性：<code>var xhr = new XMLHttpRequest(); xhr.withCredentials = true;</code><br><strong>需要注意的是</strong>，如果要发送Cookie，Access-Control-Allow-Origin就不能设为<code>*</code>，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</li>
<li>Access-Control-Expose-Headers<br>可选。CORS请求时，XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，<code>getResponseHeader(&#39;Info&#39;)</code>可以返回Info字段的值。</li>
</ul>
<h4 id="2-服务端拒绝">2.服务端拒绝</h4><p>当然我们为了防止接口被乱调用，需要限制源，对于不允许的源，服务端还是会返回一个正常的HTTP回应，但是不会带上 <code>Access-Control-Allow-Origin</code> 字段，浏览器发现这个跨域请求的返回头信息没有该字段，就会抛出一个错误，会被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调捕获到。<br><strong>这种错误无法通过 HTTP 状态码判断，因为回应的状态码有可能是200</strong></p>
<h2 id="非简单请求">非简单请求</h2><h3 id="条件-1">条件</h3><p>出了简单请求以外的CORS请求。<br>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<h3 id="过程-1">过程</h3><h4 id="1）预检请求">1）预检请求</h4><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>预检请求的发送请求：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="request">OPTIONS <span class="string">/cors</span> HTTP/1.1</span></span><br><span class="line"><span class="attribute">Origin</span>: <span class="string">http://api.qiutc.me</span></span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: <span class="string">PUT</span></span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: <span class="string">X-Custom-Header</span></span><br><span class="line"><span class="attribute">Host</span>: <span class="string">api.qiutc.com</span></span><br><span class="line"><span class="attribute">Accept-Language</span>: <span class="string">en-US</span></span><br><span class="line"><span class="attribute">Connection</span>: <span class="string">keep-alive</span></span><br><span class="line"><span class="attribute">User-Agent</span>: <span class="string">Mozilla/5.0...</span></span><br></pre></td></tr></table></figure>
<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。<br>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>
<ul>
<li>Access-Control-Request-Method<br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li><p>Access-Control-Request-Headers<br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。<br>预检请求的返回：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="status">HTTP/1.1 <span class="number">200</span> OK</span></span><br><span class="line"><span class="attribute">Date</span>: <span class="string">Mon, 01 Dec 2008 01:15:39 GMT</span></span><br><span class="line"><span class="attribute">Server</span>: <span class="string">Apache/2.0.61 (Unix)</span></span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: <span class="string">http://api.qiutc.me</span></span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: <span class="string">GET, POST, PUT</span></span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: <span class="string">X-Custom-Header</span></span><br><span class="line"><span class="attribute">Content-Type</span>: <span class="string">text/html; charset=utf-8</span></span><br><span class="line"><span class="attribute">Content-Encoding</span>: <span class="string">gzip</span></span><br><span class="line"><span class="attribute">Content-Length</span>: <span class="string">0</span></span><br><span class="line"><span class="attribute">Keep-Alive</span>: <span class="string">timeout=2, max=100</span></span><br><span class="line"><span class="attribute">Connection</span>: <span class="string">Keep-Alive</span></span><br><span class="line"><span class="attribute">Content-Type</span>: <span class="string">text/plain</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Access-Control-Allow-Methods<br>必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
</li>
<li>Access-Control-Allow-Headers<br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li>
<li>Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。<h4 id="2）浏览器的正常请求和回应">2）浏览器的正常请求和回应</h4>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</li>
</ul>
<p><strong>参考：</strong><a href="">《跨域资源共享 CORS 详解》</a><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/04/cors.html</a><br>)<br>阮大神的文章，复制粘贴了不少。</p>
<h1 id="jsonp">jsonp</h1><p>jsonp = json + padding<br>其实对于常用性来说，jsonp应该是使用最经常的一种跨域方式了，他不受浏览器兼容性的限制。但是他也有他的局限性，只能发送 GET 请求，需要服务端和前端规定好，写法丑陋。<br>它的原理在于浏览器请求 script 资源不受同源策略限制，并且请求到 script 资源后立即执行。<br>主要做法是这样的：</p>
<ul>
<li><p>在浏览器端：<br>首先全局注册一个callback回调函数，记住这个函数名字（比如：resolveJson），这个函数接受一个参数，参数是期望的到的服务端返回数据，函数的具体内容是处理这个数据。<br>然后动态生成一个 script 标签，src 为：请求资源的地址＋获取函数的字段名＋回调函数名称，这里的获取函数的字段名是要和服务端约定好的，是为了让服务端拿到回调函数名称。（如：<code>www.qiute.com?callbackName=resolveJson</code>）。</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">function resolveJosn(<span class="literal">result</span>) &#123;</span><br><span class="line">	console.log(<span class="literal">result</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonpScript= document.createElement(<span class="string">"script"</span>);</span><br><span class="line">jsonpScript.<span class="keyword">type</span> = <span class="string">"text/javascript"</span>;</span><br><span class="line">jsonpScript.src = <span class="string">"http://www.qiute.com?callbackName=resolveJson"</span>;</span><br><span class="line">document.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(jsonpScript);</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端<br>在接受到浏览器端 script 的请求之后，从url的query的callbackName获取到回调函数的名字，例子中是<code>resolveJson</code>。<br>然后动态生成一段javascript片段去给这个函数传入参数执行这个函数。比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">resolveJson</span>(<span class="rules">&#123;<span class="rule"><span class="attribute">name</span>:<span class="value"> <span class="string">'qiutc'</span></span></span></span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<br>服务端返回这个 script 之后，浏览器端获取到 script 资源，然后会立即执行这个 javascript，也就是上面那个片段。这样就能根据之前写好的回调函数处理这些数据了。</p>
</li>
</ul>
<p>在一些第三方库往往都会封装jsonp的操作，比如 jQuery 的<code>$.getJSON</code>。</p>
<h1 id="document-domain">document.domain</h1><p>一个页面框架（iframe／frame）之间（父子或同辈），是能够获取到彼此的window对象的，但是这个 window 不能拿到方法和属性（尼玛这有什么用，甩脸）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 当前页面域名 http://blog.qiutc.me/a.html</span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> iframe =<span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">	<span class="keyword">var</span> iframeWindow = iframe.contentWindow; <span class="comment">// 这里可以获取 iframe 里面 window 对象，但是几乎没用</span></span><br><span class="line">	<span class="keyword">var</span> doc = iframeWindow.document; <span class="comment">// 获取不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">iframe</span> <span class="attribute">src</span>=<span class="value">"http://www.qiutc.me/b.html"</span> <span class="attribute">onload</span>=<span class="value">"onLoad()"</span><span class="value">&lt;</span>/<span class="attribute">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个时候，<code>document.domain</code> 就可以派上用场了，我们只要把 <code>http://blog.qiutc.me/a.html</code> 和 <code>http://www.qiutc.me/b.html</code> 这两个页面的 <code>document.domain</code> 都设成相同的域名就可以了。<br>前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致。<br>但要注意的是，<code>document.domain</code> 的设置是有限制的，我们只能把 <code>document.domain</code> 设置成自身或更高一级的父域，且主域必须相同。例如：<code>a.b.example.com</code> 中某个文档的 <code>document.domain</code> 可以设成<code>a.b.example.com</code>、<code>b.example.com</code>、<code>example.com</code>中的任意一个，但是不可以设成 <code>c.a.b.example.com</code>,因为这是当前域的子域，也不可以设成<code>baidu.com</code>,因为主域已经不相同了。<br>这样我们就可以通过js访问到iframe中的各种属性和对象了。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 主页面：http://blog.qiutc.me/a.html</span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'qiutc.me'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> iframe =<span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">	<span class="keyword">var</span> iframeWindow = iframe.contentWindow; <span class="comment">// 这里可以获取 iframe 里面 window 对象并且能得到方法和属性</span></span><br><span class="line">	<span class="keyword">var</span> doc = iframeWindow.document; <span class="comment">// 获取到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">iframe</span> <span class="attribute">src</span>=<span class="value">"http://www.qiutc.me/b.html"</span> <span class="attribute">onload</span>=<span class="value">"onLoad()"</span><span class="value">&lt;</span>/<span class="attribute">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// iframe 里面的页面</span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'qiutc.me'</span>;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="window-name">window.name</h1><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 <code>window.name</code> 的，每个页面对 <code>window.name</code> 都有读写的权限，<code>window.name</code> 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<br>比如有一个<code>www.qiutc.me/a.html</code>页面，需要通过a.html页面里的js来获取另一个位于不同域上的页面<code>www.qiutc.com/data.html</code>里的数据。<br>data.html页面里的代码很简单，就是给当前的window.name设置一个a.html页面想要得到的数据值。data.html里的代码：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'我是被期望得到的数据'</span>;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>那么在 <code>a.html</code> 页面中，我们怎么把 <code>data.html</code> 页面载入进来呢？显然我们不能直接在 <code>a.html</code> 页面中通过改变 <code>window.location</code> 来载入data.html页面（这简直扯蛋）因为我们想要即使 <code>a.html</code>页面不跳转也能得到 <code>data.html</code> 里的数据。<br>答案就是在 <code>a.html</code> 页面中使用一个隐藏的 <code>iframe</code> 来充当一个中间人角色，由 <code>iframe</code> 去获取 <code>data.html</code> 的数据，然后 <code>a.html</code> 再去得到 <code>iframe</code> 获取到的数据。<br>充当中间人的 <code>iframe</code> 想要获取到<code>data.html</code>的通过<code>window.name</code>设置的数据，只需要把这个<code>iframe</code>的src设为<code>www.qiutc.com/data.html</code>就行了。然后<code>a.html</code>想要得到<code>iframe</code>所获取到的数据，也就是想要得到<code>iframe</code>的<code>window.name</code>的值，还必须把这个<code>iframe</code>的<code>src</code>设成跟<code>a.html</code>页面同一个域才行，不然根据前面讲的同源策略，<code>a.html</code>是不能访问到<code>iframe</code>里<code>的window.name</code>属性的。这就是整个跨域过程。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// a.html</span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> iframe =<span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">		iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> data = iframe.contentWindow.name; <span class="comment">// 得到</span></span><br><span class="line">		&#125;</span><br><span class="line">		iframe.src = <span class="string">'b.html'</span>;  <span class="comment">// 这里b和a同源</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">iframe</span> <span class="attribute">src</span>=<span class="value">"http://www.qiutc.com/data.html"</span> <span class="attribute">style</span>=<span class="value">"display:none"</span> <span class="attribute">onload</span>=<span class="value">"getData()"</span><span class="value">&lt;</span>/<span class="attribute">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="window-postMessage">window.postMessage</h1><p><code>window.postMessage(message, targetOrigin)</code>  方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。兼容性：<br><img src="/img/cross-domain-postmessage.png" alt="cross-domain-postmessage"><br><a href="http://caniuse.com/#search=postMessage" target="_blank" rel="external">http://caniuse.com/#search=postMessage</a></p>
<p>调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 *  。<br>需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。<br>上面所说的向其他window对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个window对象。在讨论第种方法的时候，我们说过，不同域的框架间是可以获取到对方的window对象的，虽然没什么用，但是有一个方法是可用的－<code>window.postMessage</code>。下面看一个简单的示例，有两个页面：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 主页面  blog.qiutc.com</span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> iframe =<span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">	<span class="keyword">var</span> iframeWindow = iframe.contentWindow;</span><br><span class="line">	iframeWindow.postMessage(<span class="string">"I'm message from main page."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">iframe</span> <span class="attribute">src</span>=<span class="value">"http://www.qiutc.me/b.html"</span> <span class="attribute">onload</span>=<span class="value">"onLoad()"</span><span class="value">&lt;</span>/<span class="attribute">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// b 页面</span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	e = e || event;</span><br><span class="line">	<span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="CSST_(CSS_Text_Transformation)">CSST (CSS Text Transformation)</h1><p>一种用 CSS 跨域传输文本的方案。<br>优点：相比 JSONP 更为安全，不需要执行跨站脚本。<br>缺点：没有 JSONP 适配广，CSST 依赖支持 CSS3 的浏览器。<br>原理：通过读取 CSS3 content 属性获取传送内容。<br>具体可以参考：<a href="https://github.com/zswang/csst" target="_blank" rel="external">CSST (CSS Text Transformation)</a></p>
<h1 id="利用flash">利用flash</h1><p>flash 嘛，这个东西注定灭亡，不想说了。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="跨域整理">跨域整理</h1><h1 id="跨域资源共享_CORS">跨域资源共享 CORS</h1><p>对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些hack的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CO]]>
    </summary>
    
      <category term="跨域" scheme="http://qiutc.me/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="跨域" scheme="http://qiutc.me/categories/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript 中的数组使用]]></title>
    <link href="http://qiutc.me/post/javascript-array.html"/>
    <id>http://qiutc.me/post/javascript-array.html</id>
    <published>2016-04-29T12:49:51.000Z</published>
    <updated>2016-05-10T03:50:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tip">tip</h1><p>系统学习 Array 对象的笔记。</p>
<p><img src="/img/js.jpeg" alt="js"></p>
<h1 id="定义">定义</h1><p>数组的标准定义：一个存储元素的线性集合，元素可以通过索引来任意存取，索引通常是数字，用来计算元素之间存储位置的偏移量。<br>在javascript中的数组有些不同，他们其实是特殊的对象，表示偏移量的索引是数组对象的属性（字符串）。效率上不如其他语言高。</p>
<h1 id="使用数组">使用数组</h1><h2 id="创建数组">创建数组</h2><ul>
<li>通过  <code>var arr1 = [1,2,3]</code></li>
<li>使用 new <code>var arr2 = new Array(1,2,3)</code>（注意：如果里面传入的是一个数字，比如 10 ，是定义一个 length 为10的数组，每一个元素都是 <code>undefined</code>）</li>
</ul>
<p>在这里创造的数组实际上都是一个对象，然后把对象的引用赋值给变量，实质上我们对数组的操作都是对引用进行操作。</p>
<h2 id="读写数组">读写数组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取数组</span></span><br><span class="line">var arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">	console.<span class="built_in">log</span>(arr1[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改变数组值</span></span><br><span class="line">var arr2 = [];</span><br><span class="line"><span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	arr2[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用<code>[]</code>读取到索引的数组，同时也可以对他进行赋值改变的操作。</p>
<h2 id="由字符串生成数组">由字符串生成数组</h2><p>可以调用字符串对象的 <code>split()</code> 方法通过一个字符串生成一个数组。<br><figure class="highlight cal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sentence = <span class="string">'hello world haha hahahha'</span>;</span><br><span class="line"><span class="keyword">var</span> words = sentence.split(<span class="string">' '</span>);</span><br><span class="line">console.log(words);</span><br><span class="line">// [<span class="variable">"hello"</span>, <span class="variable">"world"</span>, <span class="variable">"haha"</span>, <span class="variable">"hahahha"</span>]</span><br></pre></td></tr></table></figure></p>
<p>我们用空格号来切分了<code>sentence</code>这个字符串。</p>
<h2 id="对数组进行整体性操作">对数组进行整体性操作</h2><p>把一个数组赋给另一个数组。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">var arr2 = arr1;</span><br></pre></td></tr></table></figure></p>
<p>这里 arr2 等于 arr1 了，但是别忘了，在 javascript 里面数组是一个对象，所以赋值的只是一个新的引用！如果我们修改了 arr2 会怎么样呢？<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">var arr2 = arr1;</span><br><span class="line">arr2[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">console.<span class="built_in">log</span>(arr1);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p>
<p>看见没有，arr2 改变了 arr1 也改变了，他们都是指向同一个数组对象，这种复制叫做浅复制。<br>现在我们有一个更好的方案－深复制：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">copyArr</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">	var _arr = [];</span><br><span class="line">	<span class="keyword">for</span>(var i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		_arr[i] = arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _arr;</span><br><span class="line">&#125;</span><br><span class="line">var arr0 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">var arr1 = copyArr(arr0);</span><br><span class="line">console.<span class="built_in">log</span>(arr1);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">arr1[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">console.<span class="built_in">log</span>(arr0);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">console.<span class="built_in">log</span>(arr1);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到我们用循环遍历把 arr0 的元素复制给 arr1 的对应索引量的元素，改变 arr1，arr0 不改变。<br>当然这还是存在一些问题，比如这是个二维数组呢？数组嵌套再嵌套数组呢？可以在for循环里面判断元素是否数组，然后递归。</p>
<h1 id="存取函数">存取函数</h1><h2 id="查找元素">查找元素</h2><p><code>indexOf()</code>是最常用的了，他接受一个参数，然后查找数组中元素等于这个参数值的第一个元素，返回对应的索引值，如果没有找到这个参数，返回<code>-1</code>，如果由多个，返回第一个的索引值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">console.<span class="built_in">log</span>( arr.indexOf(<span class="number">2</span>) );</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">console.<span class="built_in">log</span>( arr.indexOf(<span class="number">6</span>) );</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">console.<span class="built_in">log</span>( arr.indexOf(<span class="number">3</span>) );</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>还有一个对应的函数是<code>lastIndexOf()</code>他是从后面查找起的，对于多个，会返回查找到的第一个的索引值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">console.<span class="built_in">log</span>( arr.lastIndexOf(<span class="number">2</span>) );</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">console.<span class="built_in">log</span>( arr.lastIndexOf(<span class="number">6</span>) );</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line">console.<span class="built_in">log</span>( arr.lastIndexOf(<span class="number">3</span>) );</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<h2 id="数组的字符串表示">数组的字符串表示</h2><p>把数组转换成一个字符串有两个方法：<code>toString()</code> 和<code>join()</code>前者是生成用<code>,</code>分割开每个元素的字符串，后者可以传入一个参数来指导用这个参数值来隔开，上代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log( arr.toString() ); <span class="comment">// a,b,c</span></span><br><span class="line"><span class="built_in">console</span>.log( arr.join(<span class="string">'-'</span>) ); <span class="comment">// a-b-c</span></span><br></pre></td></tr></table></figure></p>
<h2 id="由已有的数组创建新数组">由已有的数组创建新数组</h2><p>方法有 <code>concat()</code>和<code>splice()</code>和<code>slice()</code></p>
<ul>
<li><code>concat()</code> 接受多个数组作为参数，返回和他们合并的一个数组；</li>
<li><code>splice()</code>截取一个数组的子集返回一个新数组；（会改变原数组）</li>
<li><code>slice()</code>截取一个数组的子集：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">var arr2 = [<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">var arr3 = [<span class="number">8</span>];</span><br><span class="line">var arr4 = arr1.concat(arr2, arr3);</span><br><span class="line">console.<span class="built_in">log</span>(arr4);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 8]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">var arr2 = arr1.splice(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// 第一个参数是截取位置开始的索引值，第二个是截取的长度</span></span><br><span class="line">console.<span class="built_in">log</span>(arr2);</span><br><span class="line"><span class="comment">// [3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">var arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">var arr4 = arr3.slice(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
<h1 id="可变函数">可变函数</h1><h2 id="为数组增减元素">为数组增减元素</h2><h3 id="添加">添加</h3><ul>
<li><code>push()</code>将一个元素添加到数组的末尾，返回被添加的元素；</li>
<li><code>unshift()</code>将一个元素添加到数组开头，返回被添加的元素；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">arr.push(<span class="number">5</span>); <span class="comment">// 5</span></span><br><span class="line">console.<span class="built_in">log</span>(arr);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">arr.unshift(<span class="number">0</span>); <span class="comment">// 0</span></span><br><span class="line">console.<span class="built_in">log</span>(arr);</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="删除">删除</h3><ul>
<li><code>pop()</code>删除数组末尾的一个元素，返回这个元素值；</li>
<li><code>shift()</code>删除数组开头的一个元素，返回这个元素值；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">arr.pop(); <span class="comment">// 4</span></span><br><span class="line">console.<span class="built_in">log</span>(arr);</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line">arr.shift(); <span class="comment">// 1</span></span><br><span class="line">console.<span class="built_in">log</span>(arr);</span><br><span class="line"><span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="在数组中间添加或者删除元素">在数组中间添加或者删除元素</h3><p>还是 <code>splice</code>方法，他接受参数：</p>
<ul>
<li>启始索引</li>
<li>需要删除的数组个数（添加元素的时候可以是0）</li>
<li>需要添加进数组的元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加</span></span><br><span class="line">var arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr1.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">console.<span class="built_in">log</span>(arr1);</span><br><span class="line"><span class="comment">// [1, 2, 10, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">var arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr2.splice(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">console.<span class="built_in">log</span>(arr2);</span><br><span class="line"><span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h2 id="为数组排序">为数组排序</h2><ul>
<li><code>reverse()</code>可以使数组反转；</li>
<li><code>sort()</code>排序，可以接受一个排序规则函数作为参数；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">arr.reverse();</span><br><span class="line">console.<span class="built_in">log</span>(arr);</span><br><span class="line"><span class="comment">// [4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">23</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">55</span>, <span class="number">43</span>];</span><br><span class="line">arr.sort(function(a1, a2) &#123;</span><br><span class="line">	<span class="keyword">return</span> a1 - a2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [8, 11, 23, 24, 43, 55]</span></span><br></pre></td></tr></table></figure>
<h1 id="迭代方法">迭代方法</h1><h2 id="不生成新的数组的迭代器方法">不生成新的数组的迭代器方法</h2><ul>
<li><p><code>forEach()</code>，他接受一个函数作为参数，函数接受两个参数：当前元素值、当前元素索引，单纯遍历数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>];</span><br><span class="line">arr.forEach(function(item, idx) &#123;</span><br><span class="line">	console.<span class="built_in">log</span>(item);</span><br><span class="line">	console.<span class="built_in">log</span>(idx);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>every()</code>接受一个返回值为布尔类型的函数为参数，对数组中每个元素使用该函数，如果全都是返回<code>true</code>则该方法返回<code>true</code>，如果有一个以上返回<code>false</code>，那么该方法返回<code>false</code>；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> b1 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, idx</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item &gt;= <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(b1); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> b2 = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, idx</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item &gt;= <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(b2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>some()</code>方法，其实和<code>every()</code>方法很像，顾名思义，如果返回的有一个结果是<code>true</code>则返回<code>true</code>，如果全是<code>false</code>，则返回<code>false</code>;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> b1 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, idx</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item &gt; <span class="number">5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(b1); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> b2 = arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, idx</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item &gt; <span class="number">8</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(b2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reduce()</code>方法，他接受两个参数：一个函数、一个初始值（可不传），函数接受4个参数：之前一次遍历的返回值（第一次的话就是初始值）、当前元素值、当前元素索引、被遍历的数组，函数返回一个值。他会从一个累加之开始不断对后面的元素调用该函数；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">var sum = arr.reduce(function(runningTotal, currentValue) &#123;</span><br><span class="line">	<span class="keyword">return</span> runningTotal + currentValue;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line">console.<span class="built_in">log</span>(sum); <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>reduceRight()</code>方法，它其实和<code>reduce()</code>方法一样，区别是他是从数组的右边开始累加到左边的。</p>
</li>
</ul>
<h2 id="生成新数组的方法">生成新数组的方法</h2><ul>
<li><p><code>map()</code>方法接受一个函数，这个函数处理每一个元素并返回一个新的值，然后方法会返回这些值组成的一个新数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">var arr2 = arr.<span class="built_in">map</span>(function(item, idx) &#123;</span><br><span class="line">	<span class="keyword">return</span> item + idx;</span><br><span class="line">&#125;);</span><br><span class="line">console.<span class="built_in">log</span>(arr2);</span><br><span class="line"><span class="comment">// [1, 3, 5, 7, 9]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>filter()</code>方法接受一个函数，函数返回一个布尔类型的值，最后方法返回的数组是被函数返回<code>true</code>的元素的集合，顾名思义，就是过滤。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">var arr2 = arr.filter(function(item, idx) &#123;</span><br><span class="line">	<span class="keyword">return</span> item % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line">console.<span class="built_in">log</span>(arr2);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="二维数组和多维数组">二维数组和多维数组</h1><h2 id="创建二维数组">创建二维数组</h2><p>二维数组类似于一种行和列组成的数据表格。<br>在javascript里面定义二维数组，可以扩展javascript的数组对象：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.matrix = <span class="function"><span class="keyword">function</span>(<span class="params">numrows, numcols, initial</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numrows; i++) &#123;</span><br><span class="line">		<span class="keyword">var</span> colnums = [];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; numcols; j++) &#123;</span><br><span class="line">			colnums[j] = initial;</span><br><span class="line">		&#125;</span><br><span class="line">		arr[i] = colnums;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nums = <span class="built_in">Array</span>.matrix(<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="处理二位数组中的元素">处理二位数组中的元素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arrs = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>], [<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>], [<span class="number">999</span>, <span class="number">000</span>, <span class="number">666</span>]];</span><br><span class="line">var total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(var row = <span class="number">0</span>; row &lt; arrs.length; row++) &#123;</span><br><span class="line">	<span class="keyword">for</span>(var col = <span class="number">0</span>; col &lt; arrs[row].length; col++) &#123;</span><br><span class="line">		total += arrs[row][col];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(total); <span class="comment">// 1872</span></span><br></pre></td></tr></table></figure>
<h1 id="是否改变原数组">是否改变原数组</h1><ul>
<li>1.不改变原有数组：<ul>
<li>indexOf</li>
<li>lastIndexOf</li>
<li>toString</li>
<li>join</li>
<li>concat</li>
<li>slice</li>
<li>some</li>
<li>forEach</li>
<li>every</li>
<li>filter</li>
<li>map</li>
<li>reduce</li>
<li>reduceRight<br><br></li>
</ul>
</li>
<li>2.改变数组：<ul>
<li>splice</li>
<li>push</li>
<li>pop</li>
<li>shift</li>
<li>unshift</li>
<li>reverse</li>
<li>sort</li>
</ul>
</li>
</ul>
<h1 id="es6_中的新特性">es6 中的新特性</h1><h3 id="Array-from()">Array.from()</h3><p><code>Array.from</code>方法可以将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。<br>下面是一个类似数组的对象，Array.from将它转为真正的数组。<br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = Array.<span class="keyword">from</span>(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Array-of()">Array.of()</h3><p><code>Array.of</code>方法用于将一组值，转换为数组。<br>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。<br>就是之前说的在用 new 构造一个数组的时候，如果传入的是一个数字，那么返回的是一个该长度的数组：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr0 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr0);</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line">arr0.length; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>如果使用 <code>Array.of</code>:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var arr0 = Array.of(<span class="number">2</span>);</span><br><span class="line">console.<span class="built_in">log</span>(arr0);</span><br><span class="line"><span class="comment">// [2]</span></span><br><span class="line"></span><br><span class="line">var arr1 = Array.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">console.<span class="built_in">log</span>(arr1);</span><br><span class="line"><span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数组实例的copyWithin()">数组实例的copyWithin()</h3><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<p>它接受三个参数：</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="数组实例的find()和findIndex()">数组实例的find()和findIndex()</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find((n) =&gt; n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure></p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find((n) =&gt; n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数组实例的fill()">数组实例的fill()</h3><p><code>fill</code>方法使用给定值，填充一个数组。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].<span class="function"><span class="title">fill</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line">new <span class="function"><span class="title">Array</span><span class="params">(<span class="number">3</span>)</span></span>.<span class="function"><span class="title">fill</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure></p>
<p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数组实例的entries()，keys()和values()">数组实例的entries()，keys()和values()</h3><p>ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数组实例的includes()">数组实例的includes()</h3><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, NaN].includes(NaN); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, -<span class="number">1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="tip">tip</h1><p>系统学习 Array 对象的笔记。</p>
<p><img src="/img/js.jpeg" alt="js"></p>
<h1 id="定义">定义</h1><p>数组的标准定义：一个存储元素的线性集合，元素可以通过索引来任意]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://qiutc.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Promise 对象初尝试]]></title>
    <link href="http://qiutc.me/post/promise-learn-note.html"/>
    <id>http://qiutc.me/post/promise-learn-note.html</id>
    <published>2016-03-27T07:06:49.000Z</published>
    <updated>2016-06-02T06:53:23.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/promise-1.png" alt="Promise"></p>
<h1 id="浏览器支持">浏览器支持</h1><p><img src="/img/promise-3.jpg" alt="Promise"><br><a href="http://caniuse.com/promises/embed/agents=desktop" target="_blank" rel="external">http://caniuse.com/promises/embed/agents=desktop</a></p>
<h1 id="What_is_Promise?">What is Promise?</h1><p>Promise是抽象异步处理对象以及对其进行各种操作的组件。</p>
<p>说到 javascript 异步操作，可能想到的是这样：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 jQuery 的 ajax 为例</span></span><br><span class="line">$.<span class="keyword">get</span>(<span class="string">'/get_url'</span>, <span class="function"><span class="keyword">function</span><span class="params">(result, status)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(status == <span class="string">'success'</span>) &#123;</span><br><span class="line">		alert(<span class="string">'success'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(status == <span class="string">'error'</span>) &#123;</span><br><span class="line">		alert(<span class="string">'error'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>对于 ajax 的 get 操作来说，是一个异步的过程，通过回调函数，在得到返回的时候才会去执行操作。</p>
<p>但是试想一下当操作越来越多，回调里面还要回调的时候，一层层回调函数是不是让人抓狂，不论在代码可读性还是编写效率来看都是很麻烦的。<br>看一下我们用 Promise 可以怎么做一个异步的操作：<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">// 这个 getData 是我们预先实例好的一个 <span class="type">Promise</span> 对象，如何处理这个对象我们这里不讨论</span><br><span class="line"><span class="keyword">var</span> promise = getData('/get_url');</span><br><span class="line">promise.then(function(<span class="literal">result</span>) &#123;</span><br><span class="line">	console.log(<span class="literal">result</span>);</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样的风格是不是会更好呢，执行一个 promise，然后 then 里面传入回调函数，如果愿意，我们可以在 then 后面再更很多个 then，catch 可以捕捉错误，看起来代码清晰简明多了。<br>所以，promise的功能是可以将复杂的异步处理轻松地进行模式化。</p>
<p>#构造函数 Constructor<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(executor);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>executor</code> 是我们实例化一个 promise 对象时应该传入的参数，这个参数只一个函数，这个函数接受两个参数 <code>resolve</code>和<code>reject</code>。<br>两个方法：</p>
<ul>
<li><code>resolve(result)</code> 在 promise 中执行这个方法表示成功，会在执行之后执行后面的 then 所传入的函数，它接受到的参数也会被 then 里面的函数接受到，一般来说参数为执行结果成功时候的数据；</li>
<li><code>reject(error)</code> 在 promise 中执行这个方法表示失败，他一般接受一个 error 错误参数，会被后面的 catch 捕捉到错误执行。<br>demo：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testFoo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="string">'success'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">testFoo().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在这里我们定义了一个 <code>testFoo</code> 函数，这个函数返回一个<code>Promise</code>的实例化对象，两秒之后会执行<code>resolve(&#39;success&#39;);</code>，表示成功，传入一个参数，在两秒之后，我们then里面传入的函数执行了，接收到了刚刚那个参数；但是catch里面的函数并没有执行，因为我们没有在 promise 里面执行拒绝操作。</p>
<p>如果我们在四秒之后执行 <code>reject</code> 操作呢：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testFoo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(<span class="string">'success'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">'error'</span>);</span><br><span class="line">    &#125;, <span class="number">4000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">testFoo().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>貌似只出现<code>resolve</code>的结果，因为一个 promise 没办法做多次结果操作。<br>我们就这样：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testFoo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">'error'</span>);</span><br><span class="line">    &#125;, <span class="number">4000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">testFoo().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>现在结果如我们所预料了。</p>
<h1 id="PromiseStatus_状态">PromiseStatus 状态</h1><p>状态分为三种：</p>
<ul>
<li><code>fulfilled</code> - Fulfilled 已完成，在 <code>resolve</code>时，调用 then 的 <code>onFulfilled</code>函数；</li>
<li><code>Rejected</code> - Rejected 拒绝，在<code>reject</code>时，调用 then 的 <code>onRejected</code>函数，或者 catch 里面的函数；</li>
<li><code>unresolved</code> - Pending 等待，是 promise 初始化的时候的状态。</li>
</ul>
<p>promise 的 初始化状态为 unresolved，根据异步结果变为 fulfilled 或者 Rejected，一旦变为其中一个就不可改变，这也是我们之前上面为什么执行了 resolve 之后再执行 reject 而没有结果的原因了。</p>
<h1 id="方法概述">方法概述</h1><h2 id="快捷方法">快捷方法</h2><ul>
<li><code>Promise.resolve()</code> 这个是promise的静态方法<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Promise.resolve(<span class="number">10</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span></span>&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">value</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个方法会让 Promise 立即进入 fulfilled 状态，一般用来测试用。</p>
<ul>
<li><code>Promise.reject()</code>相应着我们有这个方法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'err'</span>).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="实例方法">实例方法</h2><ul>
<li><code>then(onFulfilled, onRejected)</code>这个方法具体是这样的，传入两个函数，一个处理fulfilled状态，另一个处理Rejected状态，一般使用我们只传入第一个函数，第二个放在 catch 来处理。</li>
<li><code>catch(onRejected)</code>处理Rejected状态，可以这么理解<code>catch(onRejected)</code>=<code>promise.then(undefined, onRejected)</code>。</li>
</ul>
<h1 id="链式调用">链式调用</h1><p>看看这个 demo:<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testFoo = function() &#123;</span><br><span class="line">	<span class="keyword">return</span> new <span class="type">Promise</span>(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">testFoo().then(function(<span class="literal">result</span>) &#123;</span><br><span class="line">  console.log(<span class="literal">result</span>);</span><br><span class="line">  <span class="keyword">return</span> ++<span class="literal">result</span>;</span><br><span class="line">&#125;).then(function(<span class="literal">result</span>) &#123;</span><br><span class="line">  console.log(<span class="literal">result</span>);</span><br><span class="line">  <span class="keyword">return</span> ++<span class="literal">result</span>;</span><br><span class="line">&#125;).then(function(<span class="literal">result</span>) &#123;</span><br><span class="line">  console.log(<span class="literal">result</span>);</span><br><span class="line">  <span class="keyword">return</span> ++<span class="literal">result</span>;</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// <span class="number">1</span></span><br><span class="line">// <span class="number">2</span></span><br><span class="line">// <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>可以看见结果，这个方法的流程是什么样的呢？<br><img src="/img/promise-2.png" alt="task"><br>第一个 then 函数和之前讲的一样，处理 promise 的 fulfilled，第二个 then 的函数是处理前一个 then 函数处理完的结果，他们之间参数传递的途径是前一个 then 函数 return 一个数据，然后后一个 then 函数接受到这个参数。<br>如果你愿意，可以再后面加很多很多个 then，他们的流程主要是这样。</p>
<p>如果我们把 catch 提前呢？<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testFoo = function() &#123;</span><br><span class="line">	<span class="keyword">return</span> new <span class="type">Promise</span>(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">testFoo().then(function(<span class="literal">result</span>) &#123;</span><br><span class="line">  console.log(<span class="literal">result</span>);</span><br><span class="line">  <span class="keyword">return</span> ++<span class="literal">result</span>;</span><br><span class="line">&#125;).then(function(<span class="literal">result</span>) &#123;</span><br><span class="line">  console.log(<span class="literal">result</span>);</span><br><span class="line">  <span class="keyword">return</span> ++<span class="literal">result</span>;</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;).then(function(<span class="literal">result</span>) &#123;</span><br><span class="line">  console.log(<span class="literal">result</span>);</span><br><span class="line">  <span class="keyword">return</span> ++<span class="literal">result</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// <span class="number">1</span></span><br><span class="line">// <span class="number">2</span></span><br><span class="line">// <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出，结果一样，说明catch只会在发生 reject 的时候调用。<br>那如果在中间的一个 then 中抛出一个异常呢？<br><figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testFoo = function() &#123;</span><br><span class="line">	<span class="keyword">return</span> new <span class="type">Promise</span>(function(resolve, reject) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">testFoo().then(function(<span class="literal">result</span>) &#123;</span><br><span class="line">  console.log(<span class="literal">result</span>);</span><br><span class="line">  <span class="keyword">return</span> ++<span class="literal">result</span>;</span><br><span class="line">&#125;).then(function(<span class="literal">result</span>) &#123;</span><br><span class="line">  console.log(<span class="literal">result</span>);</span><br><span class="line">  throw new <span class="type">Error</span>(<span class="string">"throw Error"</span>)</span><br><span class="line">  <span class="keyword">return</span> ++<span class="literal">result</span>;</span><br><span class="line">&#125;).then(function(<span class="literal">result</span>) &#123;</span><br><span class="line">  console.log(<span class="literal">result</span>);</span><br><span class="line">  <span class="keyword">return</span> ++<span class="literal">result</span>;</span><br><span class="line">&#125;).catch(function(error) &#123;</span><br><span class="line">  console.log(error);</span><br><span class="line">&#125;);</span><br><span class="line">// <span class="number">1</span></span><br><span class="line">// <span class="number">2</span></span><br><span class="line">// <span class="type">Error</span>: throw <span class="type">Error</span></span><br></pre></td></tr></table></figure></p>
<p>我们在第二个then中抛出一个异常，而后立即被 catch 捕捉到，第三个 then 并没有执行。</p>
<p>到这里我们想一下从then的传参和捕捉异常来看，新加一个 then 只是注册了一个回调函数那么简单吗？<br>不不不，每次调用then都会返回一个新创建的promise对象，这就解释了上面的一切原因。</p>
<h1 id="并发调用">并发调用</h1><p>试想一个场景，我们执行多个异步操作（ajax等等），但是我们想在这几个操作都完成的时候才去执行一个函数。<br>如果按照传统的方法来做，代码会很乱很散，关键不优雅。让我们尝试用 promise 。<br>先看这个 demo<br><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">var testFoo = <span class="function"><span class="keyword">function</span><span class="params">(time, value)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> new Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span></span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">      resolve(<span class="keyword">value</span>);</span><br><span class="line">    &#125;, time * <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">var tasks = &#123;</span><br><span class="line">  task1: <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  task2: <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1.3</span>, <span class="number">3</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  task3: <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1.5</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var main = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span></span> recordValue(results, <span class="keyword">value</span>) &#123;</span><br><span class="line">    results.push(<span class="keyword">value</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="keyword">value</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(results);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  var pushValue = recordValue.<span class="keyword">bind</span>(null, []);</span><br><span class="line">  <span class="keyword">return</span> tasks.task1().<span class="keyword">then</span>(pushValue).<span class="keyword">then</span>(tasks.task2).<span class="keyword">then</span>(pushValue).<span class="keyword">then</span>(tasks.task3).<span class="keyword">then</span>(pushValue);</span><br><span class="line">&#125;;</span><br><span class="line">main().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="keyword">value</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>这么实现明显看起来凌乱，特别对于 main 函数，可读性也比较差。<br>那么有没有更优雅的方法呢，答案：有！😄。</p>
<h2 id="Promise-all">Promise.all</h2><p><code>Promise.all</code> 方法接受一个以 promise 对象为元素的数组，在全部执行操作完成后才回调用then里面的方法，看代码:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testFoo = <span class="function"><span class="keyword">function</span>(<span class="params">time, value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;, time * <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> tasks = &#123;</span><br><span class="line">  task1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  task2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1.3</span>, <span class="number">3</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  task3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1.5</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> main = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([tasks.task1(), tasks.task2(), tasks.task3()]);</span><br><span class="line">&#125;</span><br><span class="line">main().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2, 3, 1]</span></span><br></pre></td></tr></table></figure></p>
<p>我们吧要执行的 promise 对象作为数组的元素传给 <code>Promise.all()</code>，<code>Promise.all().then()</code>里面定义的函数接受到一个数组，元素是这几个操作返回的值，顺序和 promise 对象放入的顺序一样，比如第一个 promise 对象返回的值是2，那么结果的第一个元素就是2。<br>并且每一个promise是同时执行的－－并发。<br>在所有 promise 的状态为 FulFilled 的时候才会去执行 then 里面的函数。<br>那么捕捉异常呢？<br>修改一下例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testFoo = <span class="function"><span class="keyword">function</span>(<span class="params">time, value, err</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(err) &#123;</span><br><span class="line">	    reject(err);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;, time * <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> tasks = &#123;</span><br><span class="line">  task1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'error'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  task2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1.3</span>, <span class="number">3</span>, <span class="string">'error1'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  task3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1.5</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> main = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([tasks.task1(), tasks.task2(), tasks.task3()]);</span><br><span class="line">&#125;</span><br><span class="line">main().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2, 3, 1]</span></span><br></pre></td></tr></table></figure></p>
<p>我们让其中2 promise 个抛出异常，看到捕捉到了那个异常，而且是捕捉到第一个异常就停止了。<br>说明 all 的操作是当所有 promise 状态为 FulFilled 的时候才会执行 then 的操作。而一旦有一个 Rejected 就catch这个异常，并且停止。</p>
<h2 id="Promise-race">Promise.race</h2><p>他和 Promise.all 一样，接受一个 promise 对象组成的数组，也是并发执行，但是 Promise.race 是只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testFoo = <span class="function"><span class="keyword">function</span>(<span class="params">time, value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(value);</span><br><span class="line">    &#125;, time * <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> tasks = &#123;</span><br><span class="line">  task1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  task2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1.3</span>, <span class="number">3</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  task3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> testFoo(<span class="number">1.5</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> main = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([tasks.task1(), tasks.task2(), tasks.task3()]);</span><br><span class="line">&#125;</span><br><span class="line">main().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，task1 最先完成，然后就拿到他的值进行 then 操作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/promise-1.png" alt="Promise"></p>
<h1 id="浏览器支持">浏览器支持</h1><p><img src="/img/promise-3.jpg" alt="Promise"><br><a href="htt]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="Note" scheme="http://qiutc.me/tags/Note/"/>
    
      <category term="JavaScript" scheme="http://qiutc.me/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 React 实现一个轮播组件]]></title>
    <link href="http://qiutc.me/post/%E4%BD%BF%E7%94%A8-React-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%AE%E6%92%AD%E7%BB%84%E4%BB%B6.html"/>
    <id>http://qiutc.me/post/使用-React-实现一个轮播组件.html</id>
    <published>2016-02-19T06:03:49.000Z</published>
    <updated>2016-05-10T03:51:51.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/react.png" alt="React"></p>
<h1 id="tip">tip</h1><p>React 刚出来不久，组件还比较少，不像 jquery 那样已经有很多现成的插件了，当是就自己写了一个基于 React 的轮播组件，当然只是一个小 demo，刚刚有用 es6 的语法重新改了改，就想着写一个小教程给新手，如何实现一个 React 的小组件。<br>先放上仓库地址，可以先 clone 来看看代码：<a href="https://github.com/TongchengQiu/react-slider" target="_blank" rel="external">https://github.com/TongchengQiu/react-slider</a>。<br>react-slider 是一个图片轮播的组件，支持的配置有 图片（必须好不好，要不然轮播毛）、轮播图片的速度、是否自动轮播、自动轮播的时候鼠标放上去是否暂停、自动轮播速度、是否需要前后箭头、是否需要 dot （我不知道怎么表述好，反正意思你懂）。</p>
<h1 id="第一步，需求">第一步，需求</h1><p>首先，写一个组件必须先考虑改组件的需求有哪些，支持的配置需要哪些。<br>如上已经说了改组件的需求：</p>
<ul>
<li>轮播的图片</li>
<li>配置轮播图片切换的速度</li>
<li>可配置是否自动轮播</li>
<li>可配置自动轮播的时候鼠标放上去是否暂停</li>
<li>可配置自动轮播的速度</li>
<li>可配置是否需要前后箭头</li>
<li>可配置是否需要 dot （我不知道怎么表述好，反正意思你懂）<br>这一步先到此为止～～～</li>
</ul>
<h1 id="第二步，构建项目">第二步，构建项目</h1><p>这里我们是使用 React 框架，当然也是用它的好搭档 webpack 来构建自动化流程咯～😏<br>不懂 webpack 的配置可以看我的博客关于 webpack 使用的文章，谢谢～😄<br>这是项目开发目录的文件结构：<br><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── Slider              <span class="comment">#Slider组件</span></span><br><span class="line">|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   ├──SliderItem          </span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   ├──SliderItem.jsx</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   └──SliderItem.scss</span><br><span class="line"></span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   ├──SliderDots        </span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   ├──SliderItem.jsx</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   └──SliderItem.scss</span><br><span class="line"></span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   ├──SliderArrows         </span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   ├──SliderItem.jsx</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   └──SliderItem.scss</span><br><span class="line"></span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   ├──Slider.jsx         </span><br><span class="line"></span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   └──Slider.scss</span><br><span class="line"></span>|</span><br><span class="line">├──images              <span class="comment">#存放demo用的图片文件</span></span><br><span class="line">|<span class="string"></span><br><span class="line">└── index.js           #demo的入口文件</span></span><br></pre></td></tr></table></figure></p>
<p>看目录结构我们应该明白了，我们主要关注 Slider 文件夹。</p>
<h1 id="第三步，基于需求的开发">第三步，基于需求的开发</h1><p>这里我们开发组件的模式是按照需求驱动型，回到第一步的需求，我们先不管组件内代码，先写出我们想怎么样配置使用组件：<br><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; from <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Slider from <span class="string">'./Slider/Slider'</span>;</span><br><span class="line"></span><br><span class="line">const IMAGE_DATA = [</span><br><span class="line">  &#123;</span><br><span class="line">    src: require(<span class="string">'./images/demo1.jpg'</span>),</span><br><span class="line">    alt: <span class="string">'images-1'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    src: require(<span class="string">'./images/demo2.jpg'</span>),</span><br><span class="line">    alt: <span class="string">'images-2'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    src: require(<span class="string">'./images/demo3.jpg'</span>),</span><br><span class="line">    alt: <span class="string">'images-3'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Slider</span><br><span class="line">    items=&#123;IMAGE_DATA&#125;</span><br><span class="line">    speed=&#123;<span class="number">1.2</span>&#125;</span><br><span class="line">    delay=&#123;<span class="number">2.1</span>&#125;</span><br><span class="line">    pause=&#123;true&#125;</span><br><span class="line">    autoplay=&#123;true&#125;</span><br><span class="line">    dots=&#123;true&#125;</span><br><span class="line">    arrows=&#123;true&#125;</span><br><span class="line">  /&gt;,</span><br><span class="line">  document.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在使用 Slider 组件的时候，根据需求，我们可以传入这些属性来配置组件。<br>一个 <code>items</code> 数组，决定了需要轮播的内容，items 里面每个元素都是一个对象，有 src 和 alt 属性，分别是轮播图片的 src 地址和 alt 内容；<br><code>speed</code> 是图片切换的时候的速度时间，需要配置一个 number 类型的数据，决定时间是几秒；<br><code>autoplay</code> 是配置是否需要自动轮播，是一个布尔值；<br><code>delay</code> 是在需要自动轮播的时候，每张图片停留的时间，一个 number 值；<br><code>pause</code> 是在需要自动轮播的时候，鼠标停留在图片上，是否暂停轮播，是一个布尔值；<br><code>dots</code> 是配置是否需要轮播下面的小点；<br><code>arrows</code> 是配置是否需要轮播的前后箭头；</p>
<h1 id="第四步，编写组件">第四步，编写组件</h1><p>首先我们来考虑一下需要多少个组件，最外层的 Slider 组件是毋庸置疑的了。<br>根据需求我们可以分出一个 SliderItem 组件，一个 SliderDots，一个 SliderArrows 组件，分别是 轮播每个图片的item，轮播下面dots的组件，左右箭头组件。<br>我们先来编写每个小组件，组件是对外封闭独立的，所以它只需要对外暴漏属性的配置即可。</p>
<h2 id="SliderItem">SliderItem</h2><p>因为 SliderItem 是展示轮播图片的每个内容的，所以它需要的属性有，src 和 alt，因为之前我们已经把每个轮播项写成一个对象了，所以把 src 和 alt 作为属性放在 item，我们只需要一个 item 属性即可；它还需要决定它在父组件中大小，因为在未使用组件的时候我们是不知道轮播项的数目的，所以它的宽度需要根据父组件传给它count（图片数目）来计算。<br>所以它需要的属性有：</p>
<ul>
<li>item (有 src 和 alt 属性)</li>
<li>count （轮播项总数目，计算每个轮播项的宽度）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span> &#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SliderItem</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    let &#123; count, item &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    let width = <span class="number">100</span> / count + '%';</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li className=<span class="string">"slider-item"</span> style=&#123;&#123;width: width&#125;&#125;&gt;</span><br><span class="line">        &lt;img src=&#123;item.src&#125; alt=&#123;item.alt&#125; /&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>let width = 100 / count + &#39;%&#39;;</code> 即是计算它占父组件的宽度百分比。</p>
<h2 id="SliderDots">SliderDots</h2><p>对于 SliderDots 组件，我们需要一个 count（轮播项总数目）来决定显示几个 dot，还需要一个 nowLocal 属性来判断哪个 dot 对应当前显示的轮播项，点击每个 dot 的是否需要一个回调函数 turn 来做出响应。<br>所以它需要的属性有：</p>
<ul>
<li>count（轮播项总数目）</li>
<li>nowLocal（当前的轮播项）</li>
<li>turn（点击 dot 回调函数）</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span> &#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SliderDots</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleDotClick(i) &#123;</span><br><span class="line">    <span class="keyword">var</span> option = i - <span class="keyword">this</span>.props.nowLocal;</span><br><span class="line">    <span class="keyword">this</span>.props.turn(option);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    let dotNodes = [];</span><br><span class="line">    let &#123; count, nowLocal &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">for</span>(let i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      dotNodes[i] = (</span><br><span class="line">        &lt;span</span><br><span class="line">          key=&#123;<span class="symbol">'do</span>t' + i&#125;</span><br><span class="line">          className=&#123;<span class="string">"slider-dot"</span> + (i === <span class="keyword">this</span>.props.nowLocal?<span class="string">" slider-dot-selected"</span>:<span class="string">""</span>)&#125;</span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.handleDotClick.bind(<span class="keyword">this</span>, i)&#125;&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"slider-dots-wrap"</span>&gt;</span><br><span class="line">        &#123;dotNodes&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码可以看出，我们用 for 循环根据 count 来决定了需要多少个 dot，然后在每个 dot 绑定函数传入一个 i 值，并且如果这个 dot 对于当前显示的轮播项，就多加一个class slider-dot-selected。<br>每个 dot click 绑定的函数还需要计算需要向前或者向后移动多少个轮播项，然后回调 turn 函数。</p>
<h2 id="SliderArrows">SliderArrows</h2><p>对于 SliderArrows 组件，我们只需要一个 turn 函数作出回调。<br>废话不多少，代码如下：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span> &#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SliderArrows</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleArrowClick(option) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.turn(option);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"slider-arrows-wrap"</span>&gt;</span><br><span class="line">        &lt;span</span><br><span class="line">          className=<span class="string">"slider-arrow slider-arrow-left"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.handleArrowClick.bind(<span class="keyword">this</span>, -<span class="number">1</span>)&#125;&gt;</span><br><span class="line">          &amp;lt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;span</span><br><span class="line">          className=<span class="string">"slider-arrow slider-arrow-right"</span></span><br><span class="line">          onClick=&#123;<span class="keyword">this</span>.handleArrowClick.bind(<span class="keyword">this</span>, <span class="number">1</span>)&#125;&gt;</span><br><span class="line">          &amp;gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个组件下面有两个箭头，分别是向前和向后，回调的 turn 是 1 和 －1。</p>
<h2 id="Slider_组件">Slider 组件</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span> &#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"></span><br><span class="line">require('./<span class="type">Slider</span>.scss');</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">SliderItem</span> from './<span class="type">SliderItem</span>/<span class="type">SliderItem</span>';</span><br><span class="line"><span class="keyword">import</span> <span class="type">SliderDots</span> from './<span class="type">SliderDots</span>/<span class="type">SliderDots</span>';</span><br><span class="line"><span class="keyword">import</span> <span class="type">SliderArrows</span> from './<span class="type">SliderArrows</span>/<span class="type">SliderArrows</span>';</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Slider</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Component</span> &#123;</span></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      nowLocal: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向前向后多少</span></span><br><span class="line">  turn(n) &#123;</span><br><span class="line">    <span class="keyword">var</span> _n = <span class="keyword">this</span>.state.nowLocal + n;</span><br><span class="line">    <span class="keyword">if</span>(_n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      _n = _n + <span class="keyword">this</span>.props.items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_n &gt;= <span class="keyword">this</span>.props.items.length) &#123;</span><br><span class="line">      _n = _n - <span class="keyword">this</span>.props.items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;nowLocal: _n&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始自动轮播</span></span><br><span class="line">  goPlay() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.props.autoplay) &#123;</span><br><span class="line">      <span class="keyword">this</span>.autoPlayFlag = setInterval(() =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.turn(<span class="number">1</span>);</span><br><span class="line">      &#125;, <span class="keyword">this</span>.props.delay * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暂停自动轮播</span></span><br><span class="line">  pausePlay() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.autoPlayFlag);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.goPlay();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    let count = <span class="keyword">this</span>.props.items.length;</span><br><span class="line"></span><br><span class="line">    let itemNodes = <span class="keyword">this</span>.props.items.map((item, idx) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;<span class="type">SliderItem</span> item=&#123;item&#125; count=&#123;count&#125; key=&#123;<span class="symbol">'ite</span>m' + idx&#125; /&gt;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let arrowsNode = &lt;<span class="type">SliderArrows</span> turn=&#123;<span class="keyword">this</span>.turn.bind(<span class="keyword">this</span>)&#125;/&gt;;</span><br><span class="line"></span><br><span class="line">    let dotsNode = &lt;<span class="type">SliderDots</span> turn=&#123;<span class="keyword">this</span>.turn.bind(<span class="keyword">this</span>)&#125; count=&#123;count&#125; nowLocal=&#123;<span class="keyword">this</span>.state.nowLocal&#125; /&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div</span><br><span class="line">        className=<span class="string">"slider"</span></span><br><span class="line">        onMouseOver=&#123;<span class="keyword">this</span>.props.pause?<span class="keyword">this</span>.pausePlay.bind(<span class="keyword">this</span>):<span class="literal">null</span>&#125; onMouseOut=&#123;<span class="keyword">this</span>.props.pause?<span class="keyword">this</span>.goPlay.bind(<span class="keyword">this</span>):<span class="literal">null</span>&#125;&gt;</span><br><span class="line">          &lt;ul style=&#123;&#123;</span><br><span class="line">              left: -<span class="number">100</span> * <span class="keyword">this</span>.state.nowLocal + <span class="string">"%"</span>,</span><br><span class="line">              transitionDuration: <span class="keyword">this</span>.props.speed + <span class="string">"s"</span>,</span><br><span class="line">              width: <span class="keyword">this</span>.props.items.length * <span class="number">100</span> + <span class="string">"%"</span></span><br><span class="line">            &#125;&#125;&gt;</span><br><span class="line">              &#123;itemNodes&#125;</span><br><span class="line">          &lt;/ul&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.arrows?arrowsNode:<span class="literal">null</span>&#125;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.dots?dotsNode:<span class="literal">null</span>&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Slider</span>.defaultProps = &#123;</span><br><span class="line">  speed: <span class="number">1</span>,</span><br><span class="line">  delay: <span class="number">2</span>,</span><br><span class="line">  pause: <span class="literal">true</span>,</span><br><span class="line">  autoplay: <span class="literal">true</span>,</span><br><span class="line">  dots: <span class="literal">true</span>,</span><br><span class="line">  arrows: <span class="literal">true</span>,</span><br><span class="line">  items: [],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Slider</span>.autoPlayFlag = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这里我们先是 import 依赖，以及 需要的 子组件。</li>
<li>Slider 有一个状态 nowLocal，是表明当前轮播的第几项。</li>
<li>前面一直讲 turn 函数，我们就先分析一下这个函数：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">turn(n) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>();</span><br><span class="line">  var _n = <span class="keyword">this</span>.state.nowLocal + n;</span><br><span class="line">  <span class="keyword">if</span>(_n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    _n = _n + <span class="keyword">this</span>.props.items.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(_n &gt;= <span class="keyword">this</span>.props.items.length) &#123;</span><br><span class="line">    _n = _n - <span class="keyword">this</span>.props.items.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;nowLocal: _n&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>它传入一个 参数 n ，决定向前或者向后移动多少个轮播项，向前和向后分别对于 － 和 ＋。<br>turn 函数内，声明一个 <code>_n</code> 变量表示下一个轮播的第几项。<br>如果 <code>_n</code> 小于 0 ，那当然是不行的，所以就会让 <code>_n</code> 变成最后一项；<br>如果 <code>_n</code> 大于 items 的长度 ，那当然也是不行的，所以就会让 <code>_n</code> 变成第一项；<br>最后改变状态 <code>nowLocal</code> 等于 <code>_n</code>。</p>
<ul>
<li>下面是一个开始自动轮播的函数 goPlay：<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">goPlay() &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.props.autoplay) &#123;</span><br><span class="line">    <span class="keyword">this</span>.autoPlayFlag = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.turn(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="keyword">this</span>.props.delay * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果 autoplay 是 true，则执行 setInterval 来自动调用 this.turn(1) 向前移动轮播项，<code>this.props.delay * 1000</code>就是根据配置的 delay 来决定多久移动一次。<br>这里我们需要一个 autoPlayFlag 参数来保存 setInterval 的回调，用来在鼠标停放在图片上停止自动轮播，我们把这个 autoPlayFlag 作为组件的一个属性来保存。<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Slider.autoPlayFlag = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后在组件初始化 componentDidMount 的时候调用这个函数：<br><figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line"><span class="component">componentDidMount() &#123;</span><br><span class="line">  this<span class="string">.goPlay()</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>我们还需要一个 pausePlay 函数来暂停自动轮播。</p>
<figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line"><span class="component">pausePlay() &#123;</span><br><span class="line">  clearInterval(this<span class="string">.autoPlayFlag)</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后就是 render 了，根据属性配置哪些函数和组件需要～</p>
</li>
<li>默认属性，这个是需要的，在使用属性的时候如果忘了一些配置项也不会出错。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Slider.defaultProps = &#123;</span><br><span class="line">  speed: <span class="number">1</span>,</span><br><span class="line">  delay: <span class="number">2</span>,</span><br><span class="line">  pause: <span class="literal">true</span>,</span><br><span class="line">  autoplay: <span class="literal">true</span>,</span><br><span class="line">  dots: <span class="literal">true</span>,</span><br><span class="line">  arrows: <span class="literal">true</span>,</span><br><span class="line">  items: [],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="样式">样式</h2><p>什么，你告诉我显示在页面上的都是什么鬼？<br>来写 scss 吧：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class">.slider</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">&amp;</span>&gt;<span class="tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transition</span>: left <span class="number">1s</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class">.slider-item</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">&amp;</span>&gt;<span class="tag">img</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: block;</span><br><span class="line">      <span class="attribute">height</span>: auto;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class">.slider-arrow</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">color</span>: <span class="hexcolor">#fff</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">&amp;</span><span class="pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">background</span>: <span class="function">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">&amp;</span><span class="class">.slider-arrow-right</span> &#123;</span><br><span class="line">      <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">&amp;</span><span class="class">.slider-arrow-left</span> &#123;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class">.slider-dots-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">99</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class">.slider-dot</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: inline-block;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">6px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">6px</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="hexcolor">#ccc</span>;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">6px</span>;</span><br><span class="line">      <span class="attribute">cursor</span>: pointer;</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">&amp;</span><span class="pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">3px</span> solid <span class="hexcolor">#868686</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">&amp;</span><span class="class">.slider-dot-selected</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="hexcolor">#ccc</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里不多说了，样式就这样～<br>有疑问可以 call me。</p>
<h1 id="谢谢谢谢，谢谢各位客官光看_～_😄_😄_啊哈_😁">谢谢谢谢，谢谢各位客官光看 ～  😄 😄 啊哈 😁</h1><p> 😄 😄 😁 🐶 🐩</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/react.png" alt="React"></p>
<h1 id="tip">tip</h1><p>React 刚出来不久，组件还比较少，不像 jquery 那样已经有很多现成的插件了，当是就自己写了一个基于 React 的轮播组件，当然只]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="React" scheme="http://qiutc.me/tags/React/"/>
    
      <category term="React" scheme="http://qiutc.me/categories/React/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[webpack 2 的新特性 - What's new in webpack 2]]></title>
    <link href="http://qiutc.me/post/webpack-2-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-What-s-new-in-webpack-2.html"/>
    <id>http://qiutc.me/post/webpack-2-的新特性-What-s-new-in-webpack-2.html</id>
    <published>2016-02-02T09:31:32.000Z</published>
    <updated>2016-05-10T03:52:07.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/webpack.png" alt="webpack"></p>
<p>原文 <a href="https://gist.github.com/sokra/27b24881210b56bbaff7" target="_blank" rel="external">What’s new in webpack 2</a></p>
<h1 id="webpack_2_中的新特性">webpack 2 中的新特性</h1><p>创造永无止境，现在 webpack 2 的版本已经更新到了 2.0.5-beta+ 。</p>
<h1 id="主要的变化">主要的变化</h1><h2 id="ES6_Modules">ES6 Modules</h2><p>webpack 2 已经支持原生的 ES6 的模块加载器了，这意味着 webpack 2 能够理解和处理 <code>import</code>和<code>export</code>了，而不用把他们转化成 CommonJS 来处理了。<br><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">import &#123; currentPage, readPage &#125; from "./book"<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">currentPage === 0<span class="comment">;</span></span><br><span class="line">readPage()<span class="comment">;</span></span><br><span class="line">currentPage === 1<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// book.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> currentPage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">readPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    currentPage++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">"This is a book"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="用_ES6_来做代码拆分">用 ES6 来做代码拆分</h3><p>ES6 的模块加载器定义了<code>System.import</code>这一个方法，<code>System.import</code>能够在运行时动态加载 ES6 模块。<br>webpack 把<code>System.import</code>线程作为一个交叉指针然后把被要求的模块放到一个分离的代码块里面。（这里真心看不懂，乱来了😂，反正意思就是那样）<br><code>System.import</code>函数把模块名作为参数，然后返回一个异步回调函数。<br><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span><span class="params">()</span> &#123;</span></span><br><span class="line">    System.<span class="built_in">import</span>(<span class="string">"./module"</span>).then(<span class="function"><span class="keyword">module</span> =</span>&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">module</span>.<span class="title">default</span>;</span><br><span class="line">    &#125;).<span class="title">catch</span><span class="params">(err =&gt; &#123;</span><br><span class="line">        console.log<span class="params">(<span class="string">"Chunk loading failed"</span>)</span>;</span><br><span class="line">    &#125;)</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>好消息：模块加载失败可以被捕捉到错误了。</p>
<h3 id="动态表达（异步请求js）">动态表达（异步请求js）</h3><p>可以可以把部分代码传递给 <code>System.import</code> ，它的操作其实和 CommonJS 是类似的，给所有可能的文件创建一个环境。意思就是说当你传递那部分代码的模块还不确定的时候，webpack 会自动生成所有可能的模块，然后根据需求加载。<br>这个特性在前端路由的时候很有用，可以实现按需加载资源。<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span><span class="params">(path, query)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> System.<span class="keyword">import</span>(<span class="string">"./routes/"</span> + path + <span class="string">"/route"</span>)</span><br><span class="line">        .then(route =&gt; <span class="keyword">new</span> route.Route(query));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This creates a separate chunk for each possible route</span></span><br></pre></td></tr></table></figure></p>
<h3 id="混合使用_ES6_和_AMD_和_CommonJS_(Mixing_ES6_with_AMD_and_CommonJS)">混合使用 ES6 和 AMD 和 CommonJS (Mixing ES6 with AMD and CommonJS)</h3><p>在 AMD 和 CommonJS 模块加载器中，你可以混合使用所有（三种）的模块类型（即使是在同一个文件里面）。在下面的情况中 webpack 的处理时类似的。<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">// CommonJS consuming ES6 Module</span><br><span class="line"><span class="label">var</span> <span class="keyword">book </span>= <span class="preprocessor">require</span>(<span class="string">"./book"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">book.currentPage;</span><br><span class="line"></span><span class="keyword">book.readPage();</span><br><span class="line"></span><span class="keyword">book.default </span>=== <span class="string">"This is a book"</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 Module consuming CommonJS</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">"fs"</span>; <span class="comment">// module.exports map to default</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync &#125; <span class="keyword">from</span> <span class="string">"fs"</span>; <span class="comment">// named exports are read from returned object+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> fs.readFileSync === <span class="string">"function"</span>;</span><br><span class="line"><span class="keyword">typeof</span> readFileSync === <span class="string">"function"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="babel_和_webpack">babel 和 webpack</h3><p><code>es2015</code> balel 的默认预处理会把 ES6 模块加载器转化成 CommonJS 模块加载。要是想使用 webpack 新增的对原生 ES6 模块加载器的支持，你需要使用 <code>es2015-webpack</code> 来代替。</p>
<h3 id="对_ES6_优化细述">对 ES6 优化细述</h3><p>ES6 底层支持一些新的优化。比如在很多情况下它可以查明哪些 exports 是使用过的，哪些是未使用过的。<br>很多情况下，当 webpack 可以肯定地认为一个 export 它没有使用过，他会忽略暴漏 export 给其他模块的的声明，这样可以极小成本地标志一个 export 未使用过并且忽略它。<br><br><br>在以下的情况中很可能查明使用状况：</p>
<ul>
<li>named import</li>
<li>default import</li>
<li>reexport</li>
</ul>
<p>在以下的情况中不大可能查明使用状况：</p>
<ul>
<li>import * as …</li>
<li>CommonJS or AMD consuming ES6 module</li>
<li>System.import</li>
</ul>
<h2 id="结构配置">结构配置</h2><p>在过去，由于环境的不同需要去处理不同环境下的结构配置，webpack 2 带来了一种新的方式去配置。<br>配置文件可以暴漏一个返回结构配置的函数，这个函数被 CLI 调用，然后值通过 <code>--env</code> 传递给结构配置的函数。<br>你可以传递一个字符串（–env dev =&gt; “dev”）或者一个复杂的配置对象 (–env.minimize –env.server localhost =&gt; {minimize: true, server: “localhost”}) 给这个函数。我推荐大家使用对象，因为它更具有可扩展性，当是这取决于你。<br>例子：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.babel.js</span></span><br><span class="line">exports <span class="keyword">default</span> <span class="function"><span class="keyword">function</span><span class="params">(options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        devtool: options.dev ? <span class="string">"cheap-module-eval-source-map"</span> : <span class="string">"hidden-source-map"</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="配置项">配置项</h2><p>这里是一些主要的重构<a href="https://github.com/webpack/enhanced-resolve" target="_blank" rel="external">https://github.com/webpack/enhanced-resolve</a>。它意味着配置项也改变了。<br>大多数是简化了配置，或者是让配置更不容易出错。<br>新的配置：<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    modules: [path.<span class="built_in">resolve</span>(__dirname, <span class="string">"app"</span>), <span class="string">"node_modules"</span>]</span><br><span class="line">   <span class="comment"> // (was split into `root`, `modulesDirectories` and `fallback` in the old options)</span></span><br><span class="line">   <span class="comment"> // In which folders the resolver look for modules</span></span><br><span class="line">   <span class="comment"> // relative paths are looked up in every parent folder (like node_modules)</span></span><br><span class="line">   <span class="comment"> // absolute paths are looked up directly</span></span><br><span class="line">   <span class="comment"> // the order is respected</span></span><br><span class="line"></span><br><span class="line">    descriptionFiles: [<span class="string">"package.json"</span>, <span class="string">"bower.json"</span>],</span><br><span class="line">   <span class="comment"> // These JSON files are read in directories</span></span><br><span class="line"></span><br><span class="line">    mainFields: [<span class="string">"main"</span>, <span class="string">"browser"</span>],</span><br><span class="line">   <span class="comment"> // These fields in the description files are looked up when trying to resolve the package directory</span></span><br><span class="line"></span><br><span class="line">    mainFiles: [<span class="string">"index"</span>]</span><br><span class="line">   <span class="comment"> // These files are tried when trying to resolve a directory</span></span><br><span class="line"></span><br><span class="line">    aliasFields: [<span class="string">"browser"</span>],</span><br><span class="line">   <span class="comment"> // These fields in the description files offer aliasing in this package</span></span><br><span class="line">   <span class="comment"> // The content of these fields is an object where requests to a key are mapped to the corresponding value</span></span><br><span class="line"></span><br><span class="line">    extensions: [<span class="string">".js"</span>, <span class="string">".json"</span>],</span><br><span class="line">   <span class="comment"> // These extensions are tried when resolving a file</span></span><br><span class="line"></span><br><span class="line">    enforceExtension: <span class="constant">false</span>,</span><br><span class="line">   <span class="comment"> // If false it will also try to use no extension from above</span></span><br><span class="line"></span><br><span class="line">    moduleExtensions: [<span class="string">"-loader"</span>],</span><br><span class="line">   <span class="comment"> // These extensions are tried when resolving a module</span></span><br><span class="line"></span><br><span class="line">    enforceModuleExtension: <span class="constant">false</span>,</span><br><span class="line">   <span class="comment"> // If false it's also try to use no module extension from above</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alias</span>: &#123;</span><br><span class="line">        jquery: path.<span class="built_in">resolve</span>(__dirname, <span class="string">"vendor/jquery-2.0.0.js"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment"> // These aliasing is used when trying to resolve a module</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="一些大变化">一些大变化</h1><h2 id="Promise_polyfill">Promise polyfill</h2><h2 id="Loaders_的配置">Loaders 的配置</h2><p>在 loaders 的配置中使用了 <code>resourcePath</code> 来替代原来的 <code>resource</code><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">loaders:</span> [</span><br><span class="line">    &#123;</span><br><span class="line"><span class="label">        test:</span> <span class="regexp">/\.css$/</span>,</span><br><span class="line"><span class="label">        loaders:</span> [</span><br><span class="line">            <span class="string">"style-loader"</span>,</span><br><span class="line">            &#123; <span class="string">loader:</span> <span class="string">"css-loader"</span>, <span class="string">query:</span> &#123; <span class="string">modules:</span> <span class="literal">true</span> &#125; &#125;,</span><br><span class="line">            &#123;</span><br><span class="line"><span class="label">                loader:</span> <span class="string">"sass-loader"</span>,</span><br><span class="line"><span class="label">                query:</span> &#123;</span><br><span class="line"><span class="label">                    includePaths:</span> [</span><br><span class="line">                        path.resolve(__dirname, <span class="string">"some-folder"</span>)</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h2 id="Minimize">Minimize</h2><p>在 UglifyJsPlugin 中不再支持让 Loaders 最小化文件的模式了，<code>debug</code> 配置也被移除了，Loaders 不能从 webpack 的配置中读取到他们的配置项了，取代的方案是：<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>, <span class="comment">// optionally pass test, include and exclude, default affects all loaders</span></span><br><span class="line">    minimize: <span class="keyword">true</span>,</span><br><span class="line">    debug: <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">options</span>: &#123;</span><br><span class="line">        <span class="comment">// pass stuff to the loader</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/webpack.png" alt="webpack"></p>
<p>原文 <a href="https://gist.github.com/sokra/27b24881210b56bbaff7" target="_blank" rel="ex]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="webpack" scheme="http://qiutc.me/tags/webpack/"/>
    
      <category term="webpack" scheme="http://qiutc.me/categories/webpack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redux 大法好 —— 入门实例 TodoList]]></title>
    <link href="http://qiutc.me/post/redux-%E5%A4%A7%E6%B3%95%E5%A5%BD-%E2%80%94%E2%80%94-%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B-TodoList.html"/>
    <id>http://qiutc.me/post/redux-大法好-——-入门实例-TodoList.html</id>
    <published>2015-12-21T06:24:43.000Z</published>
    <updated>2016-05-10T03:53:46.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/redux.jpeg" alt="redux"></p>
<h1 id="Tip">Tip</h1><p>前端技术真是日新月异，搞完 React 不搭配个数据流都不好意思了。<br>满怀期待的心去翻了翻 flux，简直被官方那意识流的文档折服了，真是又臭又长还是我智商问题？😖<br>转战 redux ，越看越有意思，跟着文档做了个 TodoList 的入门小例子。</p>
<p>废话不多说，先贴上文章用到例子的源码 <a href="https://github.com/TongchengQiu/TodoList-as-redux-demo" target="_blank" rel="external">https://github.com/TongchengQiu/TodoList-as-redux-demo</a><br>redux 的 Github 仓库 <a href="https://github.com/rackt/redux" target="_blank" rel="external">https://github.com/rackt/redux</a><br>还有个中文的 gitbook 翻译文档 <a href="http://camsong.github.io/redux-in-chinese/index.html" target="_blank" rel="external">http://camsong.github.io/redux-in-chinese/index.html</a></p>
<h1 id="advantage">advantage</h1><p>随着spa（不是SPA，是单页应用）的发展，以 react 来说，组件化和状态机的思想真是解放了烦恼的 dom 操作，一切都为状态。state 来操纵 views 的变化。<br>然而，因为页面的组件化，导致每个组件都必须维护自身的一套状态，对于小型应用还好。<br>但是对于比较大的应用来说，过多的状态显得错综复杂，到最后难以维护，很难清晰地组织所有的状态，在多人开发中也是如此，导致经常会出现一些不明所以的变化，越到后面调试上也是越麻烦，很多时候 state 的变化已经不受控制。对于组件间通行、服务端渲染、路由跳转、更新调试，我们很需要一套机制来清晰的组织整个应用的状态，redux 应然而生，这种数据流的思想真是了不起。</p>
<h1 id="state_根对象的结构">state 根对象的结构</h1><p>在 react 中，我们尽量会把状态放在顶层的组件，在顶层组件使用 redux 或者 router。<br>这就把组件分为了两种：容器组件和展示组件。<br>容器组件：和 redux 和 router 交互，维护一套状态和触发 action。<br>展示组件：展示组件是在容器组件的内部，他们不维护状态，所有数据通过 props 传给他们，所有操作也是通过回调完成。<br>这样，我们整套应用的架构就显得清晰了。</p>
<h1 id="part">part</h1><p>redux 分为三大部分，store ， action ，reducer 。</p>
<h2 id="store">store</h2><p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。<br>或者这么说 store 的指责有这些：</p>
<ul>
<li>维护整个应用的 state</li>
<li>提供 getState() 方法获取 state；</li>
<li>提供 dispatch(action) 方法更新 state；</li>
<li>通过 subscribe(listener) 注册监听器。</li>
</ul>
<p>这么解释一下，整个应用的 state 都储存在 store 中，容器组件可以从 store 中获取所需要的状态。<br>容器组件同时也可以发送给 store 一个 action，告诉他改变某个状态的值，所以说容器组件只要发送一个指令，就可以叫 store 去 setState，然后 store 的 state 改变，回过来容器组件获取到的 state 改变，导致 views 的更新。</p>
<h2 id="action">action</h2><p>action 可以理解为一种指令，store 数据的唯一由来就是 action，action 是一个对象，它需要至少一个元素，type，type 是这个指令的唯一标识，其它元素是传送这个指令的 state 值<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">type</span>:<span class="value"> ACTION_TYPE,</span><br><span class="line">  text: “content”,</span><br><span class="line"></span></span></span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个指令由组件触发，然后传到 reducer。</p>
<h2 id="reducer">reducer</h2><p>action 只是说明了要去做什么，和做这件事情需要的参数值。<br>具体去改变 store 中的 state 是由 reducer 来做的。<br>reducer 其实是一个包含 switch 的函数，前面不是说组件触发的 action 会传递到 reducer，reducer 接收这个参数 action，他通过 switch(action.type) 然后做不同操作，前面说了，这个 type 是指令的标识，reducer 根据这个标识来作出不同的操作。<br>这个操作是什么呢？<br>reducer 还接收另一个参数 state，这个是旧的 state。从 action 里面还可以获取到做这个操作需要的 参数值。<br>这个操作其实就是对原有的 state 和 从 action 中的到的值，来进行操作（结合，删除，…）然后返回一个 新的 state 到 store。</p>
<h2 id="数据流">数据流</h2><p>把前面的语言组织一下，整个操作的数据流其实是这样的：</p>
<ol>
<li>store 把整个应用的 state，getState()，dispatch()，subscribe() 传给顶层容器组件；</li>
<li>容器组件和三个部分交互：<ul>
<li>内部的展示组件：容器把状态分发给各个组件，把 dispatch（操作数据的函数）以回调的形式分发给各个组件；</li>
<li>action：容器获取 action；</li>
<li>reducer：容器可以调用 dispatch(action)，这个上面说了，会以回调的形式给下面的子组件，这样就可以根据不同的用户操作，调用不同的 dispatch(action)，执行了这个函数之后，就把 action 传给 reducer，然后看 reducer；</li>
</ul>
</li>
<li>reducer 得到容器组件传来的 action 之后，根据 action.type 这个参数执行不同操作，他还会接收到 store 里面的原 state，然后把原 state 和 action 对象里面的其它参数进行操作，然后 return 一个新的对象。</li>
<li>reducer return 一个新的对象到 store，store 根据这个新对象，更新应用状态。</li>
</ol>
<p>－－－－一个循环 ♻️</p>
<h1 id="connect">connect</h1><p>Redux 和 React 之间没有关系，他们并补互相依赖，但是 Redux 和 React 搭配起来简直完美。<br>我们可以通过 react-redux 这个库把他们绑定起来<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> <span class="comment">--save react-redux</span></span></span><br></pre></td></tr></table></figure></p>
<p>react-redux 提供两个东西 Provider 和 connect。</p>
<h2 id="Provider">Provider</h2><p>这个 Provider 其实就是一个中间件，他是在原有 App Container 上面再包一层，他的作用就是接收 store 里面的 store 作为 props，将store放在context里，给下面的connect用的。</p>
<h2 id="connect-1">connect</h2><p>这个组件才是真正连接 Redux 和 React，他包在我们的容器组件的外一层，他接收上面 Provider 提供的 store 里面的 state 和 dispatch，传给一个构造函数，返回一个对象，以属性形式床给我们的容器组件。</p>
<h1 id="实战_TodoList">实战 TodoList</h1><p>这个项目使用 webpack 来构建，想要了解 webpack 的配置可以看我的其它两篇文章：<br><a href="http://qiutc.me/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8webpack%E2%80%94webpack-howto.html">如何使用webpack—webpack-howto</a>;<br><a href="http://qiutc.me/post/webpack-best-practice-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E9%83%A8%E7%BD%B2%E7%94%9F%E4%BA%A7.html">webpack-best-practice-最佳实践-部署生产</a>.</p>
<h2 id="目录结构">目录结构</h2><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── app                 <span class="comment">#开发目录</span></span><br><span class="line">|<span class="string">   </span>|<span class="string">   </span><br><span class="line"></span>|<span class="string">   ├──actions          #action的文件</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   </span><br><span class="line"></span>|<span class="string">   ├──components       #内部组件</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   </span><br><span class="line"></span>|<span class="string">   ├──containers       #容器组件</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   </span><br><span class="line"></span>|<span class="string">   ├──reducers         #reducer文件</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   </span><br><span class="line"></span>|<span class="string">   ├──stores           #store配置文件</span><br><span class="line"></span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   └──index.js         #入口文件</span><br><span class="line"></span>|<span class="string">      </span><br><span class="line">├── dist                #发布目录</span><br><span class="line">├── node_modules        #包文件夹</span><br><span class="line">├── .gitignore     </span><br><span class="line">├── .jshintrc      </span><br><span class="line">├── server.js           #本地静态服务器      </span><br><span class="line">├── webpack.config.js   #webpack配置文件</span><br><span class="line">└── package.json</span></span><br></pre></td></tr></table></figure>
<p>这里，我们只关注我们的 app 开发目录。</p>
<h2 id="index-js_入口文件">index.js 入口文件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./containers/App'</span>;</span><br><span class="line"><span class="keyword">import</span> configureStore <span class="keyword">from</span> <span class="string">'./stores/configureStore'</span>;</span><br><span class="line"><span class="keyword">const</span> store = configureStore();</span><br><span class="line">render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="title">Provider</span> <span class="attribute">store</span>=<span class="value">&#123;store&#125;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">App</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">Provider</span>&gt;</span>,</span><br><span class="line">  document.getElementById('root')</span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<p>这里我们从 react-redux 中获取了一个 Provider 组件，我们把它渲染到应用的最外层。<br>他需要一个属性 store ，他把这个 store 放在context里，给App(connect)用。</p>
<h2 id="store-1">store</h2><p><code>app/stores.configureStore.js</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'../reducers'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = createStore(rootReducer, initialState);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'../reducers'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> nextReducer = <span class="built_in">require</span>(<span class="string">'../reducers'</span>);</span><br><span class="line">      store.replaceReducer(nextReducer);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他从 redux 拿到 createStore 这个函数，再获取到 rootReducer ；<br>createStore 函数接收两个参数，(reducer, [initialState])，reducer 毋庸置疑，他需要从 store 获取 state，以及连接到 reducer 交互。<br>initialState 是可以自定义的一个初始化 state，可选参数。<br><code>module.hot</code>这个可以不用管，这是 webpack 热加载的处理，你也可以不要他。</p>
<h2 id="容器组件">容器组件</h2><p><code>containers/App.jsx</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  addTodo,</span><br><span class="line">  completeTodo,</span><br><span class="line">  setVisibilityFilter,</span><br><span class="line">  VisibilityFilters</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../actions'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> AddTodo <span class="keyword">from</span> <span class="string">'../components/AddTodo'</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../components/TodoList'</span>;</span><br><span class="line"><span class="keyword">import</span> Footer <span class="keyword">from</span> <span class="string">'../components/Footer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, visibleTodos, visibilityFilter &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">AddTodo</span></span><br><span class="line">          <span class="attribute">onAddClick</span>=<span class="value">&#123;text</span> =&gt;</span></span><br><span class="line">            dispatch(addTodo(text))</span><br><span class="line">          &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="title">TodoList</span></span><br><span class="line">          <span class="attribute">todos</span>=<span class="value">&#123;visibleTodos&#125;</span></span><br><span class="line">          <span class="attribute">onTodoClick</span>=<span class="value">&#123;index</span> =&gt;</span> dispatch(completeTodo(index))&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="title">Footer</span></span><br><span class="line">          <span class="attribute">filter</span>=<span class="value">&#123;visibilityFilter&#125;</span></span><br><span class="line">          <span class="attribute">onFilterChange</span>=<span class="value">&#123;nextFilter</span> =&gt;</span> dispatch(setVisibilityFilter(nextFilter))&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    )</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App.propTypes = &#123;</span><br><span class="line">  visibleTodos: PropTypes.arrayOf(PropTypes.shape(&#123;</span><br><span class="line">    text: PropTypes.string.isRequired,</span><br><span class="line">    completed: PropTypes.bool.isRequired</span><br><span class="line">  &#125;)),</span><br><span class="line">  visibilityFilter: PropTypes.oneOf([</span><br><span class="line">    <span class="string">'SHOW_ALL'</span>,</span><br><span class="line">    <span class="string">'SHOW_COMPLETED'</span>,</span><br><span class="line">    <span class="string">'SHOW_ACTIVE'</span></span><br><span class="line">  ]).isRequired</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectTodos</span>(<span class="params">todos, filter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (filter) &#123;</span><br><span class="line">    <span class="keyword">case</span> VisibilityFilters.SHOW_ALL:</span><br><span class="line">      <span class="keyword">return</span> todos;</span><br><span class="line">    <span class="keyword">case</span> VisibilityFilters.SHOW_COMPLETED:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(todo =&gt; todo.completed);</span><br><span class="line">    <span class="keyword">case</span> VisibilityFilters.SHOW_ACTIVE:</span><br><span class="line">      <span class="keyword">return</span> todos.filter(todo =&gt; !todo.completed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 state 是 Connect 的组件的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    visibleTodos: selectTodos(state.todos, state.visibilityFilter),</span><br><span class="line">    visibilityFilter: state.visibilityFilter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(select)(App);</span><br></pre></td></tr></table></figure></p>
<p>他从 react-redux 获取 connect 连接组件，通过 <code>connect(select)(App)</code> 连接 store 和 App 容器组件。<br>select 是一个函数，他能接收到一个 state 参数，这个就是 store 里面的 state，然后通过这个函数的处理，返回一个对象，把对象里面的参数以属性传送给 App，以及附带一个 dispatch。<br>所以在 App 里面可以：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; dispatch, visibleTodos, visibilityFilter &#125; = <span class="keyword">this</span>.props;</span><br></pre></td></tr></table></figure></p>
<p>所以 App 通过 connect 的到 state 和 dispatch，把 state 传递给子组件。<br>dispatch 这个函数可以接收一个 action 参数，然后就会执行 reducer 里面的操作。<br>比如：<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">text =&gt;</span><br><span class="line">  dispatch<span class="list">(<span class="keyword">addTodo</span><span class="list">(<span class="keyword">text</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p><code>addTodo(text)</code>，这个函数是在 action 里面的到的，可以看 action 的代码，他其实返回一个 action 对象，所以其实就是<code>dispatch(action)</code> 。</p>
<h2 id="action-1">action</h2><p><code>app/actions/index.js</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> COMPLETE_TODO = <span class="string">'COMPLETE_TODO'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_VISIBILITY_FILTER = <span class="string">'SET_VISIBILITY_FILTER'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> VisibilityFilters = &#123;</span><br><span class="line">  SHOW_ALL: <span class="string">'SHOW_ALL'</span>,</span><br><span class="line">  SHOW_COMPLETED: <span class="string">'SHOW_COMPLETED'</span>,</span><br><span class="line">  SHOW_ACTIVE: <span class="string">'SHOW_ACTIVE'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">completeTodo</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: COMPLETE_TODO,</span><br><span class="line">    index</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setVisibilityFilter</span>(<span class="params">filter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: SET_VISIBILITY_FILTER,</span><br><span class="line">    filter</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在声明每一个返回 action 函数的时候，我们需要在头部声明这个 action 的 type，以便好组织管理。<br>每个函数都会返回一个 action 对象，所以在 容器组件里面 调用<br><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">text =&gt;</span><br><span class="line">  dispatch<span class="list">(<span class="keyword">addTodo</span><span class="list">(<span class="keyword">text</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>就是调用<code>dispatch(action)</code> 。</p>
<h2 id="reducer-1">reducer</h2><p><code>app/reducers/visibilityFilter.js</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  SET_VISIBILITY_FILTER,</span><br><span class="line">  VisibilityFilters</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../actions'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; SHOW_ALL &#125; = VisibilityFilters;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">visibilityFilter</span>(<span class="params">state = SHOW_ALL, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SET_VISIBILITY_FILTER:</span><br><span class="line">      <span class="keyword">return</span> action.filter;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> visibilityFilter;</span><br></pre></td></tr></table></figure></p>
<p>这里我们从 actions 获得各个 type 的参数，以便和 action 做好映射对应。<br>整个函数其实就是执行 switch，根据不同的 action.type，返回不同的对象状态。<br>但是如果我们需要 type 很多，比如除了 visibilityFilter，还有 todos，难道要写一个长长的switch，当然不。<br>redux 提供一个 combineReducers 辅助函数，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。<br>我们把不同的 reducer 放在不同文件下。<br><code>app/reducers/todo.js</code><br><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  ADD_TODO,</span><br><span class="line">  COMPLETE_TODO</span><br><span class="line">&#125; <span class="keyword">from</span> '../actions';</span><br><span class="line"></span><br><span class="line">function todos(<span class="keyword">state</span> = [], action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case ADD_TODO:</span><br><span class="line">      return [</span><br><span class="line">        ...<span class="keyword">state</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          text: action.text,</span><br><span class="line">          completed: false</span><br><span class="line">        &#125;</span><br><span class="line">      ];</span><br><span class="line">    case COMPLETE_TODO:</span><br><span class="line">      return [</span><br><span class="line">        ...<span class="keyword">state</span>.slice(<span class="number">0</span>, action.index),</span><br><span class="line">        Object.assign(&#123;&#125;, <span class="keyword">state</span>[action.index], &#123;</span><br><span class="line">          completed: true</span><br><span class="line">        &#125;),</span><br><span class="line">        ...<span class="keyword">state</span>.slice(action.index + <span class="number">1</span>)</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      return <span class="keyword">state</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> todos;</span><br></pre></td></tr></table></figure></p>
<p>然后通过一个 index.js 把他们合并。<br><code>app/reducers/index.js</code><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> todos <span class="keyword">from</span> <span class="string">'./todos'</span>;</span><br><span class="line"><span class="keyword">import</span> visibilityFilter <span class="keyword">from</span> <span class="string">'./visibilityFilter'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  todos,</span><br><span class="line">  visibilityFilter</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer;</span><br></pre></td></tr></table></figure></p>
<h2 id="展示组件">展示组件</h2><p><code>app/components/AddTodo/index.jsx</code><br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span>, <span class="type">PropTypes</span> &#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"><span class="keyword">import</span> &#123; findDOMNode &#125; from <span class="symbol">'react</span>-dom';</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">AddTodo</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input <span class="class"><span class="keyword">type</span>=</span><span class="symbol">'tex</span>t' ref=<span class="symbol">'inpu</span>t' /&gt;</span><br><span class="line">        &lt;button onClick=&#123; e =&gt; <span class="keyword">this</span>.handleClick(e) &#125;&gt;</span><br><span class="line">          <span class="type">Add</span></span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    const inputNode = findDOMNode(<span class="keyword">this</span>.refs.input);</span><br><span class="line">    const text = inputNode.value.trim();</span><br><span class="line">    <span class="keyword">this</span>.props.onAddClick(text);</span><br><span class="line">    inputNode.value = '';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">AddTodo</span>.propTypes = &#123;</span><br><span class="line">  onAddClick: <span class="type">PropTypes</span>.func.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>app/components/Todo/index.jsx</code><br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span>, <span class="type">PropTypes</span> &#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Todo</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; onClick, completed, text &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li</span><br><span class="line">        onClick=&#123;onClick&#125;</span><br><span class="line">        style=&#123;&#123;</span><br><span class="line">          textDecoration: completed ? <span class="symbol">'line</span>-through' : <span class="symbol">'non</span>e',</span><br><span class="line">          cursor: completed ? <span class="symbol">'defaul</span>t' : <span class="symbol">'pointe</span>r'</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;text&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Todo</span>.propTypes = &#123;</span><br><span class="line">  onClick: <span class="type">PropTypes</span>.func.isRequired,</span><br><span class="line">  text: <span class="type">PropTypes</span>.string.isRequired,</span><br><span class="line">  completed: <span class="type">PropTypes</span>.bool.isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>app/components/TodoList/index.jsx</code><br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span>, <span class="type">PropTypes</span> &#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"><span class="keyword">import</span> <span class="type">Todo</span> from '../<span class="type">Todo</span>';</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Component</span> &#123;</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">this</span>.props.todos.map((todo, index) =&gt;</span><br><span class="line">            &lt;<span class="type">Todo</span></span><br><span class="line">              &#123;...todo&#125;</span><br><span class="line">              onClick=&#123;() =&gt; <span class="keyword">this</span>.props.onTodoClick(index)&#125;</span><br><span class="line">              key=&#123;index&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">TodoList</span>.propTypes = &#123;</span><br><span class="line">  onTodoClick: <span class="type">PropTypes</span>.func.isRequired,</span><br><span class="line">  todos: <span class="type">PropTypes</span>.arrayOf(<span class="type">PropTypes</span>.shape(&#123;</span><br><span class="line">    text: <span class="type">PropTypes</span>.string.isRequired,</span><br><span class="line">    completed: <span class="type">PropTypes</span>.bool.isRequired</span><br><span class="line">  &#125;).isRequired).isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>app/components/Footer/index.jsx</code><br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span>, <span class="type">PropTypes</span> &#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Footer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Component</span> &#123;</span></span><br><span class="line">  renderFilter(filter, name) &#123;</span><br><span class="line">    <span class="keyword">if</span>(filter == <span class="keyword">this</span>.props.filter) &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;a</span><br><span class="line">        href=<span class="string">"#"</span></span><br><span class="line">        onClick=&#123;e =&gt; &#123;</span><br><span class="line">          e.preventDefault();</span><br><span class="line">          <span class="keyword">this</span>.props.onFilterChange(filter);</span><br><span class="line">        &#125;&#125;&gt;</span><br><span class="line">        &#123;name&#125;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        <span class="type">SHOW</span></span><br><span class="line">        &#123;' '&#125;</span><br><span class="line">        &#123;<span class="keyword">this</span>.renderFilter(<span class="symbol">'SHOW_AL</span>L', <span class="symbol">'Al</span>l')&#125;</span><br><span class="line">        &#123;', '&#125;</span><br><span class="line">        &#123;<span class="keyword">this</span>.renderFilter(<span class="symbol">'SHOW_COMPLETE</span>D', <span class="symbol">'Complete</span>d')&#125;</span><br><span class="line">        &#123;', '&#125;</span><br><span class="line">        &#123;<span class="keyword">this</span>.renderFilter(<span class="symbol">'SHOW_ACTIV</span>E', <span class="symbol">'Activ</span>e')&#125;</span><br><span class="line">        .</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Footer</span>.propTypes = &#123;</span><br><span class="line">  onFilterChange: <span class="type">PropTypes</span>.func.isRequired,</span><br><span class="line">  filter: <span class="type">PropTypes</span>.oneOf([</span><br><span class="line">    <span class="symbol">'SHOW_AL</span>L',</span><br><span class="line">    <span class="symbol">'SHOW_COMPLETE</span>D',</span><br><span class="line">    <span class="symbol">'SHOW_ACTIV</span>E'</span><br><span class="line">  ]).isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，所有的展示组件需要的 state 和 数据，都从属性中获取的，所有的操作，都是通过容器组件给的回调函数来操作的。<br>他们尽可能地不拥有自己的状态，做无状态组件。</p>
<h1 id="end">end</h1><p>关于 redux 的用法，这只是基础入门的部分，还有的多的搞基操作，比如异步数据流、Middleware、和 router 配合。<br>敬请期待～～～～<br>🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶🐶</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/redux.jpeg" alt="redux"></p>
<h1 id="Tip">Tip</h1><p>前端技术真是日新月异，搞完 React 不搭配个数据流都不好意思了。<br>满怀期待的心去翻了翻 flux，简直被官方那意识流的文档折服了]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="React" scheme="http://qiutc.me/tags/React/"/>
    
      <category term="redux" scheme="http://qiutc.me/tags/redux/"/>
    
      <category term="React" scheme="http://qiutc.me/categories/React/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谈谈 react-router]]></title>
    <link href="http://qiutc.me/post/%E8%B0%88%E8%B0%88-react-router.html"/>
    <id>http://qiutc.me/post/谈谈-react-router.html</id>
    <published>2015-12-11T01:33:12.000Z</published>
    <updated>2016-05-10T03:53:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="谈谈">谈谈</h1><p>最近使用的 React + webpack 来开发项目，感觉确实是爽的飞起，然而总感觉还是少了点什么。😫<br>😏对，是多页面，每次请求页面还要后端路由给你？😄多不爽啊，试试 react-router ，简直掌控一切的感觉，只开放一个页面路由接口，其他全给数据接口就👌了，😂可以和后端哥哥说拜拜了。<br>👋👋👋👋👋👋👋👋👋👋👋 啪啪啪啪啪～</p>
<p><img src="/img/react-router.png" alt="react-router"></p>
<h1 id="概述">概述</h1><p>先贴上官方文档 <a href="https://github.com/rackt/react-router/tree/master/docs" target="_blank" rel="external">https://github.com/rackt/react-router/tree/master/docs</a>.<br>对了这里还有一份中文文档（不过不是很全）<a href="http://react-guide.github.io/react-router-cn/" target="_blank" rel="external">http://react-guide.github.io/react-router-cn/</a>.<br>react-router 是 React 的完整前端路由解决方案，特别在做一个 spa 应用的时候，他能实现 url 和 视图ui 的同步，并且支持后端渲染，异步按需加载等等😄。<br>由于 react-router 文档的多变，这里的例子以当前版本 1.0.1 为准。（1.0之前文档每一个版本的变动都很大，索多了都是泪）</p>
<h1 id="浏览器支持">浏览器支持</h1><p>所有支持 React 的浏览器。<br>倡议！建议大家也劝说身边的人用<strong><em>现代化</em></strong>浏览器，关爱前端开发者。</p>
<h1 id="安装">安装</h1><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install react-router<span class="property">@latest</span></span><br></pre></td></tr></table></figure>
<p>同时，react-router 是基于 history 开发的，这里你需要安装 history。<br>注意 react-router 当前版本 1.0.1 依赖的是 history 1.13.1 请不要安装最新版。<br>不要问我为什么知道，被坑惨了；有同学问，那没有办法用 history 的最新版本嘛？毕竟这只是暂缓之计，解决方案还是有的，那就是等 react-router 作者解决咯 😂。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">npm install history@<span class="number">1.13</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<p>构建工具的话，我依然建议是 webpack ， React 和 webpack 是一对好兄弟。<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> webpack</span><br></pre></td></tr></table></figure></p>
<p>webpack的使用方法可以看我的前两篇文章：</p>
<ul>
<li><a href="http://qiutc.me/post/webpack-best-practice-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E9%83%A8%E7%BD%B2%E7%94%9F%E4%BA%A7.html">webpack-best-practice-最佳实践-部署生产</a></li>
<li><a href="http://qiutc.me/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8webpack%E2%80%94webpack-howto.html">如何使用webpack—webpack-howto</a><br>(求赞！！！)</li>
</ul>
<h1 id="小例子">小例子</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 加载依赖包，这是 es6 的语法（我好啰嗦）。</span><br><span class="line">import React from 'react'</span><br><span class="line">import &#123; render &#125; from 'react-dom'</span><br><span class="line">// 这里从 react-router 引入了三个组件，先不解释。</span><br><span class="line">import &#123; Router, Route, Link &#125; from 'react-router'</span><br><span class="line"></span><br><span class="line">const App = React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>App<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">Link</span> <span class="attribute">to</span>=<span class="value">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="title">Link</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">Link</span> <span class="attribute">to</span>=<span class="value">"/inbox"</span>&gt;</span>Inbox<span class="tag">&lt;/<span class="title">Link</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Inbox = React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">        Inbox</span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const About = React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">        About</span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">render((</span><br><span class="line">  <span class="tag">&lt;<span class="title">Router</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"/"</span> <span class="attribute">component</span>=<span class="value">&#123;App&#125;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"about"</span> <span class="attribute">component</span>=<span class="value">&#123;About&#125;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"inbox"</span> <span class="attribute">component</span>=<span class="value">&#123;Inbox&#125;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">Route</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">Router</span>&gt;</span></span><br><span class="line">), document.getElementById('root'));</span><br></pre></td></tr></table></figure>
<p>我就偷个懒把官方文档的demo直接copy了。<br>直接先来看 render 下面的内容，这里是用 jsx 语法。 最外层组件是 Router（可以把他看作是react-router提供的最外层容器） , 下一层是 Route，这个是路由组件。对应关系如下：<br><code>/ ---&gt; &lt;App /&gt;</code><br><code>/about ---&gt; &lt;App&gt;&lt;About /&gt;&lt;/App&gt;</code><br><code>/inbox ---&gt; &lt;App&gt;&lt;Inbox /&gt;&lt;/App&gt;</code><br>path 对应路径，component 对应当前路径渲染的组件。<br>Route 里面的 Route 表示在父组件路由的 path 路径下面的一级 path 对应的路由，这里的路由是父子嵌套，对应的组件也同样是父子嵌套的。<br>如果是多级嵌套也同样如此。</p>
<h1 id="不想用_jsx_来写，换个方式吧～">不想用 jsx 来写，换个方式吧～</h1><p>以上例子可以改写成：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">const routerConfig = [</span><br><span class="line">  &#123;</span><br><span class="line"><span class="label">    path:</span> <span class="string">'/'</span>,</span><br><span class="line"><span class="label">    component:</span> App,</span><br><span class="line"><span class="label">    childrenRoutes:</span> [</span><br><span class="line">      &#123; <span class="string">path:</span> <span class="string">'about'</span>, <span class="string">component:</span> About &#125;,</span><br><span class="line">      &#123; <span class="string">path:</span> <span class="string">'inbox'</span>, <span class="string">component:</span> Inbox &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line">render((</span><br><span class="line">  &lt;Router routes=&#123;routeConfig&#125; /&gt;</span><br><span class="line">), document.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure></p>
<p>这里的结构就更清晰了，我是比较喜欢这种方式。</p>
<h1 id="默认的路由">默认的路由</h1><p>比如上面的例子，/ 对于的组件是 App , 如果 App 只是渲染了一个导航条，却没有自组件，那打开 比如 qiutc.me/ 的时候不是就没有内容了吗。<br>把上面例子改一下<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 添加组件 Index</span></span><br><span class="line">const Index = React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Index</span><br><span class="line">        Index</span><br><span class="line">        Index</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改配置</span></span><br><span class="line">const routerConfig = [</span><br><span class="line">  &#123;</span><br><span class="line"><span class="label">    path:</span> <span class="string">'/'</span>,</span><br><span class="line"><span class="label">    component:</span> App,</span><br><span class="line"><span class="label">    indexRoute:</span> &#123; <span class="string">component:</span> Index &#125;,</span><br><span class="line"><span class="label">    childrenRoutes:</span> [</span><br><span class="line">      &#123; <span class="string">path:</span> <span class="string">'about'</span>, <span class="string">component:</span> About &#125;,</span><br><span class="line">      &#123; <span class="string">path:</span> <span class="string">'inbox'</span>, <span class="string">component:</span> Inbox &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>这里加了一个 <code>indexRoute</code> ，表示他在没有匹配子路由的时候，在 / 路由下渲染默认的子组件 Index。<br>路由组件嵌套也是一样的，比如：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="rules">&#123; <span class="rule"><span class="attribute">path</span>:<span class="value"> <span class="string">'about'</span>, component: About, indexRoute: &#123;component: AboutIndex</span></span></span>&#125; &#125;,</span><br></pre></td></tr></table></figure></p>
<p>以此类推。</p>
<h1 id="404_NotFound">404  NotFound</h1><p>如果我们打开了一个没有设置路由的链接，就必然需要一个友好的 404 页面。配置如下：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 添加 404 组件</span></span><br><span class="line">const NotFound = React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        <span class="number">404</span></span><br><span class="line">        NotFound</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 修改配置</span></span><br><span class="line">const routerConfig = [</span><br><span class="line">  &#123;</span><br><span class="line"><span class="label">    path:</span> <span class="string">'/'</span>,</span><br><span class="line"><span class="label">    component:</span> App,</span><br><span class="line"><span class="label">    indexRoute:</span> &#123; <span class="string">component:</span> Index &#125;,</span><br><span class="line"><span class="label">    childrenRoutes:</span> [</span><br><span class="line">      &#123; <span class="string">path:</span> <span class="string">'about'</span>, <span class="string">component:</span> About &#125;,</span><br><span class="line">      &#123; <span class="string">path:</span> <span class="string">'inbox'</span>, <span class="string">component:</span> Inbox &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line"><span class="label">    path:</span> <span class="string">'*'</span>,</span><br><span class="line"><span class="label">    component:</span> NotFound,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>如此简单。</p>
<h1 id="绝对路径与重定向">绝对路径与重定向</h1><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">const routerConfig = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    component: App,</span><br><span class="line">    indexRoute: &#123; component: Index &#125;,</span><br><span class="line">    childrenRoutes: [</span><br><span class="line">      &#123; path: <span class="string">'about'</span>, component: About &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'inbox'</span>,</span><br><span class="line">        component: Inbox,</span><br><span class="line">        childrenRoutes: [</span><br><span class="line">          &#123;</span><br><span class="line">            path: <span class="string">'message/:id'</span>,</span><br><span class="line">            component: Message,</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'*'</span>,</span><br><span class="line">    component: NotFound,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>在这里我们访问 /inbox/message/1 对于渲染 Message 组件，这个链接太长了，我们想直接 /message/1 那怎么办，改路由结构？太麻烦了！绝对路径可以帮你做到这个。<br>把 <code>path: &#39;message/:id&#39;,</code> 改为 <code>path: &#39;/message/:id&#39;,</code> 就好了。<br>等等如果用户之前收藏的链接是 /inbox/message/1 ，那不是就打不开了嘛，和后端路由一样，react-router 也有重定向：redirect<br><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">const routerConfig = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    component: App,</span><br><span class="line">    indexRoute: &#123; component: Index &#125;,</span><br><span class="line">    childrenRoutes: [</span><br><span class="line">      &#123; path: <span class="string">'about'</span>, component: About &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'inbox'</span>,</span><br><span class="line">        component: Inbox,</span><br><span class="line">        childrenRoutes: [</span><br><span class="line">          &#123;</span><br><span class="line">            path: <span class="string">'/message/:id'</span>,</span><br><span class="line">            component: Message,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            path: <span class="string">'message/:id'</span>,</span><br><span class="line">            onEnter: function (nextState, replaceState) &#123;</span><br><span class="line">              replaceState(null, <span class="string">'/messages/'</span> + nextState.params.id);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'*'</span>,</span><br><span class="line">    component: NotFound,</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<h2 id="onEnter_方法表示进入这个路由前执行的方法，在进入_/inbox/messages/:id_的前，执行">onEnter 方法表示进入这个路由前执行的方法，在进入 /inbox/messages/:id 的前，执行</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">(nextState, replaceState)</span> </span>&#123;</span><br><span class="line">  replaceState(<span class="literal">null</span>, <span class="string">'/messages/'</span> + nextState.params.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>nextState</code>表示要进入的下一个路由，这里就是 /inbox/messages/:id ，<code>replaceState</code> 表示替换路由状态的方法，把 /inbox/messages/:id 替换成 /messages/:id，然后就可以重定向到 /messages/:id。</p>
<h2 id="同样的也有_onLeave_这个方法">同样的也有 onLeave 这个方法</h2><p>表示在离开路由前执行。<br>———————————————————<br>当然如果你用的是 jsx 语法，有更简单的组件可以实现：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">import &#123; Redirect &#125; from 'react-router'</span><br><span class="line"></span><br><span class="line">React.render((</span><br><span class="line">  <span class="tag">&lt;<span class="title">Router</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"/"</span> <span class="attribute">component</span>=<span class="value">&#123;App&#125;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">IndexRoute</span> <span class="attribute">component</span>=<span class="value">&#123;Index&#125;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"about"</span> <span class="attribute">component</span>=<span class="value">&#123;About&#125;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"inbox"</span> <span class="attribute">component</span>=<span class="value">&#123;Inbox&#125;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"/messages/:id"</span> <span class="attribute">component</span>=<span class="value">&#123;Message&#125;</span> /&gt;</span></span><br><span class="line">        &#123;/* 跳转 /inbox/messages/:id 到 /messages/:id */&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="title">Redirect</span> <span class="attribute">from</span>=<span class="value">"messages/:id"</span> <span class="attribute">to</span>=<span class="value">"/messages/:id"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">Route</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">Route</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">Router</span>&gt;</span></span><br><span class="line">), document.getElementById('root'))</span><br></pre></td></tr></table></figure></p>
<h1 id="路径匹配原理">路径匹配原理</h1><h2 id="嵌套关系">嵌套关系</h2><blockquote>
<p>React Router 使用路由嵌套的概念来让你定义 view 的嵌套集合，当一个给定的 URL 被调用时，整个集合中（命中的部分）都会被渲染。嵌套路由被描述成一种树形结构。React Router 会深度优先遍历整个理由配置来寻找一个与给定的 URL 相匹配的路由。</p>
</blockquote>
<p>简单来讲，就是说，匹配的时候会先匹配到外层路径，然后依次遍历到内层。<br>比如 /inbox/messages/:id 会先匹配 /，渲染 / 对应的组件 App，然后再到 / 的下一层寻找 /inbox ，同样渲染 /inbox 对应的组件 Inbox，依次类推，直到到 message/:id。</p>
<p>tip：使用绝对路径可以忽略嵌套关系，如上面例子。</p>
<h2 id="路径语法">路径语法</h2><p>路由路径是匹配一个（或一部分）URL 的 一个字符串模式。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号：</p>
<ul>
<li>/:paramName – 匹配一段位于 /、? 或 # 之后的 URL。 命中的部分将被作为一个参数</li>
<li>(/) – 在它内部的内容被认为是可选的</li>
<li><p>/* – 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个 splat 参数</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">&lt;<span class="constant">Route </span>path=<span class="string">"/hello/:name"</span>&gt;         <span class="regexp">//</span> 匹配 /hello/michael 和 /hello/ryan</span><br><span class="line">&lt;<span class="constant">Route </span>path=<span class="string">"/hello(/:name)"</span>&gt;       <span class="regexp">//</span> 匹配 /hello, <span class="regexp">/hello/michael</span> 和 /hello/ryan</span><br><span class="line">&lt;<span class="constant">Route </span>path=<span class="string">"/files/*.*"</span>&gt;           <span class="regexp">//</span> 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="优先级">优先级</h2><p>最后，路由算法会根据定义的顺序自顶向下匹配路由。因此，当你拥有两个兄弟路由节点配置时，你必须确认前一个路由不会匹配后一个路由中的路径。例如：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Route</span> <span class="attribute">path</span>=<span class="value">"/comments"</span> <span class="attribute">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">Redirect</span> <span class="attribute">from</span>=<span class="value">"/comments"</span> <span class="attribute">...</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>第二个是不会被执行的。</p>
<h1 id="拿到参数路径的">拿到参数路径的</h1><p>比如上面的 /messages/:id ，这个id可能是我们在 Message 获取数据时需要的 id。<br>他会被当做一个参数传给 params，parmas 会传给 Message 组件的 props：<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Message = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;&#123; <span class="keyword">this</span>.props.params.id &#125;&lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样就可以获取到了。</p>
<h1 id="history_配置">history 配置</h1><p>React Router 是建立在 history 之上的。 简而言之，一个 history 知道如何去监听浏览器地址栏的变化， 并解析这个 URL 转化为 location 对象， 然后 router 使用它匹配到路由，最后正确地渲染对应的组件。<br>常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。</p>
<ul>
<li>createHashHistory</li>
<li>createBrowserHistory</li>
<li>createMemoryHistory</li>
</ul>
<h2 id="这三个有什么区别呢：">这三个有什么区别呢：</h2><h3 id="createHashHistory">createHashHistory</h3><p>这是一个你会获取到的默认 history ，如果你不指定某个 history 。它用到的是 URL 中的 hash（#）部分去创建形如 example.com/#/some/path 的路由。<br>这个 支持 ie8＋ 的浏览器，但是因为是 hash 值，所以不推荐使用。</p>
<h3 id="createBrowserHistory">createBrowserHistory</h3><p>Browser history 是由 React Router 创建浏览器应用推荐的 history。它使用 History API 在浏览器中被创建用于处理 URL，新建一个像这样真实的 URL example.com/some/path。</p>
<h3 id="Memoryhistory">Memoryhistory</h3><p>不会在地址栏被操作或读取。</p>
<h2 id="使用">使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory, useBasename &#125; <span class="keyword">from</span> <span class="string">'history'</span>;</span><br><span class="line"><span class="keyword">const</span> historyConfig = useBasename(createHistory)(&#123;</span><br><span class="line">  basename: <span class="string">'/'</span>        <span class="comment">// 根目录名</span></span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">render((</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="title">Router</span> <span class="attribute">routes</span>=<span class="value">&#123;routeConfig&#125;</span> <span class="attribute">History</span>=<span class="value">&#123;historyConfig&#125;</span> /&gt;</span></span><br><span class="line">)</span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>
<h1 id="Link&amp;IndexLink">Link&amp;IndexLink</h1><h2 id="Link">Link</h2><p>我们在最开头看到这样一个东西：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">const App = React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">h1</span>&gt;</span>App<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">Link</span> <span class="attribute">to</span>=<span class="value">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="title">Link</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">Link</span> <span class="attribute">to</span>=<span class="value">"/inbox"</span>&gt;</span>Inbox<span class="tag">&lt;/<span class="title">Link</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Link 会被渲染成 a ，to 其实就是 href ，<br>但是 react-router 会阻止默认跳转页面，而改成 history 路由的变换。</p>
<p>参数：</p>
<ul>
<li>to<br>切换到的路由地址</li>
<li>query<br>跟在 url 的 query 参数，比如<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">query=<span class="expansion">&#123;&#123;<span class="symbol">q:</span> <span class="string">"que"</span>&#125;&#125;</span> 对应 <span class="string">`/example?a=que</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里的 query 同样可以像 params 会被传入下一个路由组件的 props</p>
<ul>
<li>hash<br>跟在 url 的 hash 参数，比如<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hash=&#123;<span class="number">111</span>&#125; 对应 `/example<span class="preprocessor">#<span class="number">111</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里的 query 同样可以像 params 会被传入下一个路由组件的 props</p>
<ul>
<li><p>activeClassName<br>当前 url 路径如果和 Link 的 to 匹配 这个 Link 就会有一个定义的属性，比如：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">在 /index 下</span><br><span class="line">&lt;<span class="constant">Link</span> to=<span class="string">"/index"</span> activeClassName=&#123;<span class="string">"active"</span>&#125; activeStyle=<span class="expansion">&#123;&#123;<span class="symbol">color:</span> <span class="string">'red'</span>&#125;&#125;</span> &gt;<span class="regexp">/&lt;/</span><span class="constant">Link</span>&gt;</span><br><span class="line">这里渲染出来的 a 标签会有一个激活的 active 类名，还会有一个颜色 red</span><br><span class="line">&lt;<span class="constant">Link</span> to=<span class="string">"/about"</span> activeClassName=&#123;<span class="string">"active"</span>&#125; activeStyle=<span class="expansion">&#123;&#123;<span class="symbol">color:</span> <span class="string">'red'</span>&#125;&#125;</span> &gt;<span class="regexp">/&lt;/</span><span class="constant">Link</span>&gt;</span><br><span class="line">这里渲染出来的 a 标签就不会有以上属性</span><br></pre></td></tr></table></figure>
</li>
<li><p>activeStyle<br>同上</p>
</li>
<li>onClick<br>点击的时候执行的函数，会传入一个 e 事件对象，你可以 <code>e.stopPropagation()</code> 阻止默认路由切换。</li>
</ul>
<h2 id="IndexLink">IndexLink</h2><p>在上面有一个问题如果：<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">在 / 下 和 /index</span><br><span class="line">&lt;<span class="constant">Link</span> to=<span class="string">"/"</span> activeClassName=&#123;<span class="string">"active"</span>&#125; activeStyle=<span class="expansion">&#123;&#123;<span class="symbol">color:</span> <span class="string">'red'</span>&#125;&#125;</span> &gt;<span class="regexp">/&lt;/</span><span class="constant">Link</span>&gt;</span><br><span class="line">这个 <span class="constant">Link</span> 渲染出来的 a 标签都会激活 active 属性，并且会带上 <span class="symbol">color:</span> <span class="string">'red'</span></span><br><span class="line">因为 / 和 /index 和 ／ 都是匹配的</span><br></pre></td></tr></table></figure></p>
<p>这时候就可以用:<br><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">&lt;<span class="constant">IndexLink</span> to=<span class="string">"/"</span> activeClassName=&#123;<span class="string">"active"</span>&#125; activeStyle=<span class="expansion">&#123;&#123;<span class="symbol">color:</span> <span class="string">'red'</span>&#125;&#125;</span> &gt;<span class="regexp">/&lt;/</span><span class="constant">IndexLink</span>&gt;</span><br><span class="line">只会在 / 下呗激活，在 /index 或者其他下面，不会被激活</span><br></pre></td></tr></table></figure></p>
<h1 id="未完待续">未完待续</h1><p>关于 <strong><em>根据路由按需异步加载js</em></strong> 和 <strong><em>服务器端渲染路由视图</em></strong> 以及 <strong><em>react-router的更高级用法</em></strong> 会在下一篇文章来探讨。<br>毕竟哥也需要去深入研究一下才敢献丑。😂😂😂<br>🐶</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="谈谈">谈谈</h1><p>最近使用的 React + webpack 来开发项目，感觉确实是爽的飞起，然而总感觉还是少了点什么。😫<br>😏对，是多页面，每次请求页面还要后端路由给你？😄多不爽啊，试试 react-router ，简直掌控一切的感觉，只开放]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="React" scheme="http://qiutc.me/tags/React/"/>
    
      <category term="react-router" scheme="http://qiutc.me/tags/react-router/"/>
    
      <category term="React" scheme="http://qiutc.me/categories/React/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[webpack-best-practice-最佳实践-部署生产]]></title>
    <link href="http://qiutc.me/post/webpack-best-practice-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E9%83%A8%E7%BD%B2%E7%94%9F%E4%BA%A7.html"/>
    <id>http://qiutc.me/post/webpack-best-practice-最佳实践-部署生产.html</id>
    <published>2015-12-02T02:56:39.000Z</published>
    <updated>2016-05-10T03:51:59.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/webpack.png" alt="webpack"></p>
<h1 id="tip">tip</h1><p>webpack的入门篇可以看我的这一片博文。<br><a href="http://qiutc.me/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8webpack%E2%80%94webpack-howto.html">《如何使用webpack—webpack-howto》</a>.</p>
<h1 id="前言">前言</h1><p>最近一段时间在项目中使用了webpack和React来开发，总之来说也是遇到了许多坑，webpack毕竟还是比较新的技术，而且也很难有一个很好的构建案例来适应所有的项目，总之，在看了许多项目demo和官方文档以及官方推荐的tutorials之后，也算是自己总结出的一套最佳实践吧。</p>
<h2 id="代码">代码</h2><p>代码可以在我的<a href="https://github.com/TongchengQiu/webpack-best-practice" target="_blank" rel="external">Github</a>上。<br><a href="https://github.com/TongchengQiu/webpack-best-practice" target="_blank" rel="external">可以戳这里～～</a>。</p>
<h1 id="package-json_命令配置">package.json 命令配置</h1><p>既然是需要用到的是实际项目的构建，那么必然就要考虑开发环境和生产环境下的配置项了：<br><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack --progress --colors --watch"</span>,</span><br><span class="line">    <span class="string">"watch"</span>: <span class="string">"webpack-dev-server --hot --progress --colors"</span>,</span><br><span class="line">    <span class="string">"dist"</span>: <span class="string">"NODE_ENV=production webpack --progress --colors"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以在目录下执行 <code>npm run build</code> , <code>npm run watch</code> , <code>npm run dist</code><br>解释一下:</p>
<ul>
<li>build 是在我们开发环境下执行的构建命令;</li>
<li>watch 也是在开发环境下执行，但是加了webpack最强大的功能－－搭建静态服务器和热插拔功能（这个在后面介绍;</li>
<li>dist 是项目在要部署到生产环境时打包发布。</li>
</ul>
<p>dist 里面的<code>NODE_ENV=production</code>是声明了当前执行的环境是production－生产环境<br><br><br>后面跟着几个命令：</p>
<ul>
<li>–colors 输出的结果带彩色</li>
<li>–progress 输出进度显示</li>
<li>–watch 动态实时监测依赖文件变化并且更新</li>
<li>–hot 是热插拔</li>
<li>–display-error-details 错误的时候显示更多详细错误信息</li>
<li>–display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块</li>
<li>-w 动态实时监测依赖文件变化并且更新</li>
<li>-d 提供sorcemap</li>
<li>-p 对打包文件进行压缩</li>
</ul>
<h1 id="目录结构">目录结构</h1><p>现在前端模块化的趋势导致目录结构也发生了很大的改变和争议，这只是我自己用到的一种形式，可以参考。<br><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── app                 <span class="comment">#开发目录</span></span><br><span class="line">|<span class="string">   ├──assets           #存放静态资源</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   ├──datas        #存放数据 json 文件</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   ├──images       #存放图片资源文件</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   └──styles       #存放全局sass变量文件和reset文件</span><br><span class="line"></span>|<span class="string">   ├──lib</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   ├──components   #存放数据 模块组件 文件</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">   └──Header</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">       ├──Header.jsx</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">       └──Header.scss</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   </span>|<span class="string">       </span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">   └──utils        #存放utils工具函数文件</span><br><span class="line"></span>|<span class="string">   </span>|</span><br><span class="line">|<span class="string">   └──views</span><br><span class="line"></span>|<span class="string">       ├──Index        #入口文件</span><br><span class="line"></span>|<span class="string">       </span>|<span class="string">   ├──Index.html #html文件</span><br><span class="line"></span>|<span class="string">       </span>|<span class="string">   ├──Index.jsx</span><br><span class="line"></span>|<span class="string">       </span>|<span class="string">   └──Index.scss</span><br><span class="line"></span>|<span class="string">       └──Index2</span><br><span class="line">├── dist                #发布目录</span><br><span class="line">├── node_modules        #包文件夹</span><br><span class="line">├── .gitignore     </span><br><span class="line">├── .jshintrc      </span><br><span class="line">├── webpack.config.js   #webpack配置文件</span><br><span class="line">└── package.json</span></span><br></pre></td></tr></table></figure></p>
<p>具体可以到Github上看demo。</p>
<h1 id="webpack-config-js">webpack.config.js</h1><h2 id="引入包">引入包</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br></pre></td></tr></table></figure>
<p>这个毋庸置疑吧。</p>
<h2 id="判断是否是在当前生产环境">判断是否是在当前生产环境</h2><p>定义函数判断是否是在当前生产环境，这个很重要，一位开发环境和生产环境配置上有一些区别<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isProduction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> process.env.NODE_ENV === <span class="string">'production'</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="声明文件夹">声明文件夹</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义输出文件夹</span></span><br><span class="line"><span class="keyword">var</span> outputDir = <span class="string">'./dist'</span>;</span><br><span class="line"><span class="comment">// 定义开发文件夹</span></span><br><span class="line"><span class="keyword">var</span> entryPath = <span class="string">'./app/views'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="定义插件">定义插件</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">var plugins = [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: <span class="string">'commons'</span>,</span><br><span class="line">    filename: <span class="string">'js/commons.js'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    React: <span class="string">'react'</span>,</span><br><span class="line">    ReactDOM: <span class="string">'react-dom'</span>,</span><br><span class="line">    reqwest: <span class="string">'reqwest'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">];</span><br><span class="line"><span class="keyword">if</span>( isProduction() ) &#123;</span><br><span class="line">  plugins.<span class="keyword">push</span>(</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      test: <span class="regexp">/(\.jsx|\.js)$/</span>,</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="keyword">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>CommonsChunkPlugin 插件可以打包所有文件的共用部分生产一个commons.js文件。</li>
<li>ProvidePlugin 插件可以定义一个共用的入口，比如 下面加的 React ,他会在每个文件自动require了react，所以你在文件中不需要 require(‘react’)，也可以使用 React。</li>
<li>如果是在生产环境下，则加入插件 UglifyJsPlugin ，执行代码压缩，并且去除 warnings。</li>
</ol>
<h2 id="自动遍历多文件入口">自动遍历多文件入口</h2><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">var entris = fs.readdirSync(entryPath).reduce(function (o, <span class="keyword">filename</span>) &#123;</span><br><span class="line">    !/\./.test(<span class="keyword">filename</span>) &amp;&amp;</span><br><span class="line">    (o[<span class="keyword">filename</span>] = <span class="string">'./'</span> + path.<span class="keyword">join</span>(entryPath, <span class="keyword">filename</span>, <span class="keyword">filename</span> + <span class="string">'.jsx'</span>));</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">  &#125;, &#123;&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>函数会自动遍历开发的入口文件夹下面的文件，然后一一生产入口并且返回一个对象－－入口。</p>
<h2 id="如果在这一步不需要多页面多入口">如果在这一步不需要多页面多入口</h2><p>那么可以使用<a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="external">html-webpack-plugin</a>插件，它可以自动为入口生成一个html文件，配置如下：<br><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line">plugins.push(<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  <span class="attribute">title</span>: <span class="string">'index'</span>,</span><br><span class="line">  <span class="attribute">filename</span>: outputDir+<span class="string">'/index.html'</span>,  <span class="comment">#生成html的位置</span></span><br><span class="line">  <span class="attribute">inject</span>: <span class="string">'body'</span>,                     <span class="comment">#插入script在body标签里</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></p>
<p>entry 就可以自定义一个入口就够了</p>
<h2 id="config的具体配置">config的具体配置</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> config = &#123;</span><br><span class="line">  target: <span class="string">'web'</span>,</span><br><span class="line">  cache: <span class="literal">true</span>,</span><br><span class="line">  entry: entris,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: outputDir,</span><br><span class="line">    filename: <span class="string">'js/[name].bundle.js'</span>,</span><br><span class="line">    publicPath: isProduction()? <span class="string">'http://******'</span> : <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="module"><span class="keyword">module</span>: </span>&#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/(\.jsx|\.js)$/</span>,</span><br><span class="line">        loaders: [<span class="string">'babel?presets[]=es2015&amp;presets[]=react'</span>],</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        loaders: [<span class="string">'style'</span>, <span class="string">'css?root='</span>+__dirname, <span class="string">'resolve-url'</span>, <span class="string">'sass'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.json$/</span>,</span><br><span class="line">        loader: <span class="string">'json'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(jpe?g|png|gif|svg)$/</span>,</span><br><span class="line">        loader: <span class="string">'url?limit=1024&amp;name=img/[name].[ext]'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|otf|eot|svg|ttf)$/i</span>,</span><br><span class="line">        loader: <span class="string">'url?name=fonts/[name].[ext]'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">        loader: <span class="string">'file?name=views/[name].[ext]'</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: plugins,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'jsx'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: isProduction()?<span class="literal">null</span>:<span class="string">'source-map'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里来一一说明：</p>
<h3 id="对于output">对于output</h3><p>path和filename都不用多说了，path是生成文件的存放目录，filename是文件名，当然可以在前面加上目录位置。<br>这里提醒一下，filename 的相对路径就是 path了，并且下面 静态文件生成的filename也是相对于这里的path的，比如 image 和 html。<br>publicPath 的话是打包的时候生成的文件链接，比如 图片 资源，<br>如果是在生产环境当然是用服务器地址，如果是开发环境就是用本地静态服务器的地址。</p>
<h3 id="module_loaders_打包加载的处理器">module loaders 打包加载的处理器</h3><p>可以不用夹 loader了 比如 原来 url-loader  现在 url</p>
<h4 id="js/jsx">js/jsx</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">test</span>:<span class="value"> /(\.jsx|\.js)$/,</span><br><span class="line">  loaders: [<span class="string">'babel?presets[]=es2015&amp;presets[]=react'</span>],</span><br><span class="line">  exclude: /node_modules/</span><br><span class="line"></span></span></span>&#125;,</span><br></pre></td></tr></table></figure>
<p>对于js文件和jsx文件用了babel来处理，这里注意一下，最新版本的babel吧es2015和react的处理分开了，所有要这么写。</p>
<h3 id="处理scss文件">处理scss文件</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">test</span>:<span class="value"> /\.scss$/,</span><br><span class="line">  loaders: [<span class="string">'style'</span>, <span class="string">'css?root='</span>+__dirname, <span class="string">'resolve-url'</span>, <span class="string">'sass'</span>]</span><br><span class="line"></span></span></span>&#125;,</span><br></pre></td></tr></table></figure>
<p>这里用了sass、css、style的loader这不用多说了。<br>那么root和resolve-url是怎么回事呢，root是定义了scss文件里面声明的url地址是相对于根目录的，然后resolve-url回去相对解析这个路径，而不用require去获取，比如<br><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span><span class="value">: <span class="function">url</span>(<span class="string">'./assets/images/webpack.png'</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>这样就可以加载到<code>./assets/images/webpack.png</code>这个文件，而不用使用相对路径和require</p>
<h3 id="处理json文件">处理json文件</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">test</span>:<span class="value"> /\.json$/,</span><br><span class="line">  loader: <span class="string">'json'</span>,</span><br><span class="line"></span></span></span>&#125;,</span><br></pre></td></tr></table></figure>
<p>对于json文件，可以自动请求该模块并且打包。</p>
<h3 id="处理_图片_字体_资源文件">处理 图片 字体 资源文件</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">test</span>:<span class="value"> /\.(jpe?g|png|gif|svg)$/,</span><br><span class="line">  loader: <span class="string">'url?limit=1024&amp;name=img/[name].[ext]'</span></span><br><span class="line"></span></span></span>&#125;,</span><br><span class="line"><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">test</span>:<span class="value"> /\.(woff2?|otf|eot|svg|ttf)$/i,</span><br><span class="line">  loader: <span class="string">'url?name=fonts/[name].[ext]'</span></span><br><span class="line"></span></span></span>&#125;,</span><br></pre></td></tr></table></figure>
<p>这里使用了 url 这个loader，但是url依赖 file-loader，它是对file-loader的二次封装。<br>在请求图片的时候如果文件大小小于 1024k ，使用内联 base64 URLs，否则会自动导入到name所声明的目录，这里是相对之前声明的 outputDir 路径。<br>字体资源也是一样。</p>
<h3 id="处理html文件">处理html文件</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">test</span>:<span class="value"> /\.html$/,</span><br><span class="line">  loader: <span class="string">'file?name=views/[name].[ext]'</span></span><br><span class="line"></span></span></span>&#125;,</span><br></pre></td></tr></table></figure>
<p>在多页面的项目中需要，可以自动吧html文件导入到指定的生产文件夹下。</p>
<h2 id="resolve">resolve</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">resolve</span>: <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">extensions</span>:<span class="value"> [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'jsx'</span>],</span><br><span class="line"></span></span></span>&#125;,</span><br></pre></td></tr></table></figure>
<p>是可以忽略的文件后缀名，比如可以直接<code>require(&#39;Header&#39;);</code>而不用加.jsx。</p>
<h2 id="devtool">devtool</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">devtool:</span> isProduction()?null:<span class="string">'source-map'</span>,</span><br></pre></td></tr></table></figure>
<p>规定了在开发环境下才使用 source-map。</p>
<h1 id="疑问">疑问</h1><p>目前为止，对于多页面项目还是没有找到一个很好的方案去构建自动化。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/webpack.png" alt="webpack"></p>
<h1 id="tip">tip</h1><p>webpack的入门篇可以看我的这一片博文。<br><a href="http://qiutc.me/post/%E5%A6%82%]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="webpack" scheme="http://qiutc.me/tags/webpack/"/>
    
      <category term="webpack" scheme="http://qiutc.me/categories/webpack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[RN]2.样式style--React-Native learning notes]]></title>
    <link href="http://qiutc.me/post/RN-2-%E6%A0%B7%E5%BC%8Fstyle-React-Native-learning-notes.html"/>
    <id>http://qiutc.me/post/RN-2-样式style-React-Native-learning-notes.html</id>
    <published>2015-11-22T08:27:03.000Z</published>
    <updated>2016-05-10T03:51:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tip:">tip:</h1><p>这是一篇学习 React-Native for Android 的学习笔记，主要上其实是看官方的文档来自己学习 RN，目前的主要是学习android的开发。</p>
<p>😏😏😏😏😏😏😏😏😏😏😏😏😏😏😏😏</p>
<h1 id="React-Native_for_Android_样式的使用。">React-Native for Android 样式的使用。</h1><p>React-Native 编写的应用的样式不是靠css来实现的，而是依赖javascript来为你的应用来添加样式，先不讨论这样做的好处与坏处，因为这个实现方法本身就存在着很多争议，我们主要关注他的样式的语法和特性。</p>
<h1 id="声明样式:">声明样式:</h1><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> styles = StyleSheet.create(&#123;</span><br><span class="line">     <span class="keyword">base</span>: &#123;</span><br><span class="line">          width: <span class="number">38</span>,</span><br><span class="line">          height: <span class="number">38</span>,</span><br><span class="line">     &#125;,</span><br><span class="line">     background: &#123;</span><br><span class="line">          backgroundColor: <span class="string">'#222222'</span>,</span><br><span class="line">     &#125;,</span><br><span class="line">     active: &#123;</span><br><span class="line">          borderWidth: <span class="number">2</span>,</span><br><span class="line">          borderColor: ‘<span class="preprocessor">#ff00ff',</span></span><br><span class="line">     &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从语法来看：调用了React-Native的一个构造方法，传入一个对象生成style，如果你写过React就应该很熟悉这种写法，和React的React.createCladd()语法是一样的，传入对象的key就相当于类名（我是这么理解），每个类也是一个对象，可以配置各种样式参数，总体来说和CSS的写法差不多，差别上把CSS的命名又“-”连字符改成驼峰写法，然后长度不用加单位“px”，字符串比如色值需要加引号写成字符串。<br>其实也是和React的行内样式写法的语法一样。</p>
<h1 id="样式的使用:">样式的使用:</h1><p>所有的核心组件都支持样式属性<br><code>&lt;View style={style.base} /&gt;</code><br>当你需要设置多个属性类的时候，可以传入一个数组<br><code>&lt;View style={[style.base,style.backgroundColor]} /&gt;</code><br>在两个样式又冲突的情况下，以右边的值优先，有些情况下可以加一些条件判断样式是否加载，比如，<br><code>&lt;View style={[style.base,this.state.active&amp;&amp;style.active]} /&gt;</code><br>你也可以在组件中render样式，然而这种做法不推荐，其实就像一般html页面中行内样式不推荐一样，<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">&lt;View</span><br><span class="line">  style=&#123;[styles.base,&#123;<span class="variable">width</span>:<span class="keyword">this</span>.state.<span class="variable">width</span>, <span class="variable">height</span>:<span class="keyword">this</span>.state.<span class="variable">width</span>*<span class="keyword">this</span>.state.aspectRatio&#125;]&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="布局_–_flexbox">布局 – flexbox</h1><p>React-Native 采用flexbox布局方式，flexbox是css3引入的布局模型－－弹性盒子模型，旨在通过弹性的方式对齐和分布容器中的item，使其适应不同的宽度和高度。<br>在 React-Native 中的flexbox 是css3中flexbox的一个子集，并不支持所有的flexbox属性。<br>flexbox  布局分为flexbox container 和 flexbox item ：如下图<br><img src="/img/RN_img_4.png" alt=""><br>flexbox 是一个属性的集合，有些是属于container的有些湿属于item的。<br>可以看下面这幅图：<br><img src="/img/RN_img_5.png" alt=""><br>对于 container 有 main axis（主轴）和cross axis（交叉轴）。main size 和 cross size 分别是container主轴方向的交叉轴方向的宽度，main start 和 main end 分别是主轴的起始和结点，其他同理，container里面包含items。<br>下面介绍一下属性：</p>
<h2 id="container的属性：">container的属性：</h2><ul>
<li><p>flexDirection: ‘ row ‘ | ‘ column ‘<br>主轴的方向，水平 | 垂直，默认是 column ，item会按照主轴方向排列。</p>
</li>
<li><p>flexWrap: ‘ warp ‘ | ‘ nowrap ’<br>flexbox 会默认将所有元素基于一行，这个属性表示是否折行。</p>
</li>
<li><p>alignItems: ‘ flex-start ’ | ’ flex-end ’ | ’ center ’ | ‘ stretch ‘<br>表示item在 cross axis 上的对齐方式，基于cross axis的顶部｜基于cross axis的底部｜基于cross axis的中部｜布满整个。</p>
</li>
<li><p>justifyContent: ‘ flex-start ’ | ‘ flex-end ‘ | ‘ center ‘ | ‘ space-between ‘ | ’space-around’<br>表示item在 main axis 上的对齐方式，基于主轴开始｜基于主轴结束｜居中｜左右两边对齐，item间隔相等｜每个item两端间隔相等。</p>
</li>
</ul>
<h2 id="item的属性">item的属性</h2><ul>
<li><p>flex: num<br>item 所占的比例大小。</p>
</li>
<li><p>alignSelf:‘ flex-start ’ | ’ flex-end ’ | ’ center ’ | ‘ stretch ‘<br>它允许项目中当个item和其他itemsyou不一样的对齐方式，会覆盖alignitems的属性。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="tip:">tip:</h1><p>这是一篇学习 React-Native for Android 的学习笔记，主要上其实是看官方的文档来自己学习 RN，目前的主要是学习android的开发。</p>
<p>😏😏😏😏😏😏😏😏😏😏😏😏😏😏]]>
    </summary>
    
      <category term="Note" scheme="http://qiutc.me/tags/Note/"/>
    
      <category term="React-Native" scheme="http://qiutc.me/tags/React-Native/"/>
    
      <category term="React-Native" scheme="http://qiutc.me/categories/React-Native/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[RN]1.环境搭建--React-Native learning notes]]></title>
    <link href="http://qiutc.me/post/RN-1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-React-Native-learning-notes.html"/>
    <id>http://qiutc.me/post/RN-1-环境搭建-React-Native-learning-notes.html</id>
    <published>2015-11-21T12:57:35.000Z</published>
    <updated>2016-07-28T10:54:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="tip:">tip:</h1><p>这是一篇学习 React-Native for Android 的学习笔记，主要上其实是看官方的文档来自己学习 RN，目前的主要是学习android的开发。</p>
<h1 id="React-Native_for_Android_的环境搭建">React-Native for Android 的环境搭建</h1><h3 id="要求：">要求：</h3><ol>
<li>前提 OS X (假设大家有用Mac了😏ß);</li>
<li><a href="http://brew.sh/" target="_blank" rel="external">Homebrew</a> (包管理器)(用来安装Watchman 和 Flow);</li>
<li>安装<a href="https://nodejs.org/" target="_blank" rel="external">node.js</a> 4.0 或者以上;</li>
<li>安装 watchman(文件监控) ,在命令行: <code>brew install watchman</code>;</li>
<li>安装 flow ,在命令行: <code>brew install flow</code>;</li>
<li>安装最新的 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">JDK</a>;</li>
<li>安装 SDK ,在命令行: <code>brew install android-idk</code>;</li>
<li>配置 android 环境:<br>在 ~/.bashrc, ~/.bash_profile写入<br>  <code>export ANDROID_HOME=/usr/local/opt/android-sdk</code>;<br>(在这一步可以先到~目录下，然后如果没有.bashrc，就创建一个，然后vim .bashrc，然后写入上面代码，按esc键，输入<code>:wq</code>，然后自动保存退出，.bash_profile同理);</li>
<li>配置 SDK:<br>新开一个shell窗口：运行 <code>android</code>,<br>会弹出 Android SDK Manager窗口，<br>安装下列选项:<br><img src="/img/RN_img_1.png" alt=""><br><img src="/img/RN_img_2.png" alt=""><br>(tip: 这一步可能需要翻墙);</li>
<li>安装 <a href="https://www.genymotion.com/#!/download/freemium/mac/classical" target="_blank" rel="external">Genymotion</a> (android 的模拟器,推荐使用这个吧);</li>
<li>安装react native 的命令行工具包,在命令行: <code>npm install -g react-native-cli</code>;</li>
<li>命令行进入需要创建的文件夹目录下: <code>react-native init AwesomeProject</code>，会自动获取下载react native的包（建议翻墙）;</li>
<li><p>项目的目录结构如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="tag">android</span>           <span class="id">#android</span>需要的文件夹</span><br><span class="line">├── <span class="tag">ios</span>               <span class="id">#ios</span>需要的文件夹</span><br><span class="line">├── <span class="tag">node_modules</span>      <span class="id">#npm</span>包文件夹</span><br><span class="line">├── <span class="tag">index</span><span class="class">.android</span><span class="class">.js</span>  <span class="id">#android</span>应用的入口<span class="tag">js</span>文件</span><br><span class="line">├── <span class="tag">index</span><span class="class">.ios</span><span class="class">.js</span>      <span class="id">#ios</span>应用的入口<span class="tag">js</span>文件</span><br><span class="line">└── <span class="tag">package</span><span class="class">.json</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开Genymotion,下载安装最新的android模拟器，打开;</p>
</li>
<li>在文件夹下运行命令行: <code>react-native run-android</code>,等待安装，<br>然后android的模拟器就会出现：<br><img src="/img/RN_img_3.png" alt=""><br>ß<h2 id="完成！">完成！</h2></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="tip:">tip:</h1><p>这是一篇学习 React-Native for Android 的学习笔记，主要上其实是看官方的文档来自己学习 RN，目前的主要是学习android的开发。</p>
<h1 id="React-Native_for_Androi]]>
    </summary>
    
      <category term="Note" scheme="http://qiutc.me/tags/Note/"/>
    
      <category term="React-Native" scheme="http://qiutc.me/tags/React-Native/"/>
    
      <category term="React-Native" scheme="http://qiutc.me/categories/React-Native/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用webpack—webpack-howto]]></title>
    <link href="http://qiutc.me/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8webpack%E2%80%94webpack-howto.html"/>
    <id>http://qiutc.me/post/如何使用webpack—webpack-howto.html</id>
    <published>2015-10-21T02:58:10.000Z</published>
    <updated>2016-07-26T23:16:27.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何使用webpack">如何使用webpack</h1><p>本文章翻译自petehunt的webpack-howto教程，<a href="https://github.com/petehunt/webpack-howto" target="_blank" rel="external">原地址https://github.com/petehunt/webpack-howto</a>，还有源码。</p>
<h2 id="本教程的目标">本教程的目标</h2><p>这是一本如何使用webpack来处理代码的“烹饪书”，它包括了我们在Instagram用的大多数东西以及我们还没在项目中用到过的。<br>我（作者）的建议：把这本书作为你学习webpack文档的开端，然后配合看官方文档的说明。</p>
<h2 id="预备知识">预备知识</h2><ul>
<li>你了解browserify，ReqiureJs或者其他类似的东西。</li>
<li>你明白这些东西的价值：<ul>
<li>打包分离</li>
<li>异步加载</li>
<li>打包静态资源，比如图片和CSS</li>
</ul>
</li>
</ul>
<h2 id="1-为什么使用webpack？">1.为什么使用webpack？</h2><ul>
<li><strong>他类似browserify</strong> 但是可以把你的应用分离成许多文件，如果你有许多页面在你的单页应用里面，用户只需要下载当前页面所需要的代码。如果你跳转到另一个页面，他们不需要重新加载通用的代码。</li>
<li><strong>他能替代grunt或者gulp大部分的功能</strong> 因为他可以构建和打包CSS，预处理CSS，编译JS和打包处理图片，甚至更多事情。<br>他支持AMD和CommonJs以及其他的模块化系统（Angular，ES6）。如果你不知道用什么，那么可以用CommonJs。</li>
</ul>
<h2 id="2-给用browserify的人">2.给用browserify的人</h2><p>下面的代码是等价的：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">browserify</span> <span class="tag">main</span><span class="class">.js</span> &gt; <span class="tag">bundle</span><span class="class">.js</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">webpack</span> <span class="tag">main</span><span class="class">.js</span> <span class="tag">bundle</span><span class="class">.js</span></span><br></pre></td></tr></table></figure>
<p>然而，webpack比browserify更加强大，你可能会更愿意去编写一个<code>webpack.config.js</code>来合理地组织你的项目：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="module"><span class="keyword">module</span>.exports = </span>&#123;</span><br><span class="line">    entry: <span class="string">'./main.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这就是JS，所以你可以很轻松地在这个文件里编写代码。</p>
<h2 id="3-如何调用webpack？">3.如何调用webpack？</h2><p>切换带包含webpack.config.js的目录然后在命令行运行：</p>
<ul>
<li><code>webpack</code> 执行一次开发时的编译</li>
<li><code>webpack -p</code> 执行一次生成环境的编译（压缩）</li>
<li><code>webpack --watch</code> 在开发时持续监控增量编译（很快）</li>
<li><code>webpack -d</code> 让他生成SourceMaps</li>
</ul>
<h2 id="编译JS语言">编译JS语言</h2><p>webpack和browserify一样能转化（transforms）的RequireJs插件是一个加载器（loader）<br>你能让webpack加载CoffeeScript和Facebook的JSX+ES6支持（你必须先 <code>npm install babel-loader coffee-loader</code>）:<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line"><span class="label">    entry:</span> <span class="string">'./main.js'</span>,</span><br><span class="line"><span class="label">    output:</span> &#123;</span><br><span class="line"><span class="label">        filename:</span> <span class="string">'bundle,js'</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="label">    module:</span> &#123;</span><br><span class="line"><span class="label">        loader:</span> [</span><br><span class="line">            &#123; <span class="string">test:</span> <span class="regexp">/\.coffee$/</span>, <span class="string">loader:</span> <span class="string">'coffee-loader'</span> &#125;,</span><br><span class="line">            &#123; <span class="string">test:</span> <span class="regexp">/\.js$/</span>, <span class="string">loader:</span> <span class="string">'bebel-loader'</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>为了开启后缀名的自动补全，你需要添加<code>resolve.extensions</code>参数来指定哪些文件是webpack需要搜索的：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> webpack.config.js</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attribute">entry</span>: <span class="string">'./main.js'</span>,</span><br><span class="line">    <span class="attribute">output</span>: &#123;</span><br><span class="line">        <span class="attribute">filename</span>: <span class="string">'bundle,js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attribute">module</span>: &#123;</span><br><span class="line">        <span class="attribute">loader</span>: [</span><br><span class="line">            &#123; <span class="attribute">test</span>: <span class="regexp">/\.coffee$/</span>, <span class="attribute">loader</span>: <span class="string">'coffee-loader'</span> &#125;,</span><br><span class="line">            &#123; <span class="attribute">test</span>: <span class="regexp">/\.js$/</span>, <span class="attribute">loader</span>: <span class="string">'bebel-loader'</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attribute">resolve</span>: &#123;</span><br><span class="line">        <span class="regexp">//</span> 你现在可以使用 `<span class="javascript"></span>`<span class="built_in">require</span>(<span class="string">'file'</span>)`<span class="javascript"></span>` 来代替 `<span class="javascript"></span>`<span class="built_in">require</span>(<span class="string">'file.coffee'</span>)`<span class="javascript"></span>` 。</span><br><span class="line">        <span class="attribute">extensions</span>: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.coffee'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-样式和图片">5.样式和图片</h2><p>首先你需要更新你的代码去请求 <code>require()</code> 你的静态资源（命名和他们在node里面使用 <code>require()</code> 一样）。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./bootstrap.css'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./myapp.less'</span>);</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.src = <span class="built_in">require</span>(<span class="string">'./glyph.png'</span>);</span><br></pre></td></tr></table></figure></p>
<p>当你请求CSS（或者less或者其他）的时候，webpack会把CSS像字符串一样内联到JS包里面，require（）会在页面插入一个style标签。<br>当你请求图片时，webpack会内联一个图片的URL链接到你的代码包然后通过<code>require()</code>返回。<br>但是你需要去教webpack去做这件事（再次重复，用loaders）：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">module.exports = &#123;</span><br><span class="line"><span class="label">  entry:</span> <span class="string">'./main.js'</span>,</span><br><span class="line"><span class="label">  output:</span> &#123;</span><br><span class="line"><span class="label">    path:</span> <span class="string">'./build'</span>, <span class="comment">// 图片和js会被打包到这个目录</span></span><br><span class="line"><span class="label">    publicPath:</span> <span class="string">'http://mycdn.com/'</span>, <span class="comment">// 这个是用来生成图片地址的URL</span></span><br><span class="line"><span class="label">    filename:</span> <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="label">  module:</span> &#123;</span><br><span class="line"><span class="label">    loaders:</span> [</span><br><span class="line">      &#123; <span class="string">test:</span> <span class="regexp">/\.less$/</span>, <span class="string">loader:</span> <span class="string">'style-loader!css-loader!less-loader'</span> &#125;, <span class="comment">// 使用 ! 来链接多个loader</span></span><br><span class="line">      &#123; <span class="string">test:</span> <span class="regexp">/\.css$/</span>, <span class="string">loader:</span> <span class="string">'style-loader!css-loader'</span> &#125;,</span><br><span class="line">      &#123;<span class="string">test:</span> <span class="regexp">/\.(png|jpg)$/</span>, <span class="string">loader:</span> <span class="string">'url-loader?limit=8192'</span>&#125; <span class="comment">// 内联小于8k的base64图片，其他的直接使用URL</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-功能标志">6.功能标志</h2><p>有些代码可能我们只想要在生产环境下运行（比如日志logging）和我们内部的测试调试服务器（就像我们的测试人员在测试应用），可以在你的代码引入全局环境变量。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(__DEV__) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">'Extra logging'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span>(__PRERELEASE__) &#123;</span><br><span class="line">    showSecretFeature();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这会教webpack这些奇特的全局环境：<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串.</span></span><br><span class="line"><span class="keyword">var</span> definePlugin = <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">  __DEV__: <span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(process.env.BUILD_DEV || <span class="string">'true'</span>)),</span><br><span class="line">  __PRERELEASE__: <span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(process.env.BUILD_PRERELEASE || <span class="string">'false'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="module"><span class="keyword">module</span>.exports = </span>&#123;</span><br><span class="line">  entry: <span class="string">'./main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>       </span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [definePlugin]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>你可以在控制台里执行 <code>BUILD_DEV=1 BUILD_PRERELEASE=1 webpack</code> .<br>注意：<code>webpack -p</code>会丑化并且剔除死代码，然和包含在里面的代码都会被剔除掉，这样你就不用担心泄露秘密咯~</p>
<h2 id="7-多重入口">7.多重入口</h2><p>比如说你有一个profile和一个feed页面，你不想让用户在只想要profile页面的时候下载feed页面的代码，所以你可以创建多个包，每个页面都有一个”main module”。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="module"><span class="keyword">module</span>.exports = </span>&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    Profile: <span class="string">'./profile.js'</span>,</span><br><span class="line">    Feed: <span class="string">'./feed.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="string">'build'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span> <span class="comment">// 模板基于上面入口文件的key</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在profile页面，插入 <code>&lt;script src=&quot;build/Profile.js&quot;&gt;&lt;/script&gt;</code> .feed页面也会这样。</p>
<h2 id="8-优化通用代码">8.优化通用代码</h2><p>feed和profile页面共享许多通用的代码（比如React和公用样式和组件）。<br>webpack可以计算出哪些代码是它们公用的然后生成一个共享的包然后在页面之间被缓存。<br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> commonsPlugin =</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="module"><span class="keyword">module</span>.exports = </span>&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    Profile: <span class="string">'./profile.js'</span>,</span><br><span class="line">    Feed: <span class="string">'./feed.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="string">'build'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span> <span class="comment">// Template based on keys in entry above</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [commonsPlugin]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在script标签添加之前添加 <code>&lt;script src=&quot;build/common.js&quot;&gt;&lt;/script&gt;</code> 就可以使用缓存啦~</p>
<h2 id="9-异步加载">9.异步加载</h2><p>CommonJs是同步加载的，但是webpack提供了一个方法可以异步加载指定的依赖项。<br>这对于客户端的路由是很有用的，每一个页面都需要路由，但是在某个功能被用到之前你不会想去下载这部分代码的。<br>在你想要异步加载的地方指定分离点，比如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.location.pathname === <span class="string">'/feed'</span>) &#123;</span><br><span class="line">  showLoadingState();</span><br><span class="line">  <span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 这个语法很怪异但是他能执行</span></span><br><span class="line">    hideLoadingState();</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'./feed'</span>).show(); <span class="comment">// 当这个函数被调用的时候, 这个模块时可以同步的。</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.location.pathname === <span class="string">'/profile'</span>) &#123;</span><br><span class="line">  showLoadingState();</span><br><span class="line">  <span class="built_in">require</span>.ensure([], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    hideLoadingState();</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'./profile'</span>).show();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>webpack会做剩下的事情并且生成额外的包然后给你加载。<br>webpack在html的script标签加载时会假设这些文件是在你的根目录下的，比如，你可以使用 <code>output.publicPath来配置他</code><br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="tag">output</span>: &#123;</span><br><span class="line">    <span class="attribute">path</span>: <span class="string">"/home/proj/public/assets"</span>, <span class="comment">//path指向你编译时的文件目录</span></span><br><span class="line">    <span class="attribute">publicPath</span>: <span class="string">"/assets/"</span> <span class="comment">//publicPath指向你引用文件是考虑的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="其他资源">其他资源</h1><p>可以看一看一个成功的团队如何在真实项目中使用webpack：<a href="http://youtu.be/VkTCL6Nqm6Y" target="_blank" rel="external">http://youtu.be/VkTCL6Nqm6Y</a><br>这是Pete Hunt 在OSCon大会上说的关于webpack在Instagram.com中的使用。</p>
<h1 id="FAQ">FAQ</h1><p><strong>webpack不像模块化？</strong><br>webpack非常的模块化。他能让插件自身集成到编译过程中的许多地方相比于browserify和requireJs.<br>许多看起来是在被编写在核心代码中的功能实际上是被默认加载的插件，他们可以被覆盖。</p>
<h1 id="PS">PS</h1><h2 id="1_关于_webpack_-p">1 关于 <code>webpack -p</code></h2><p>关于 <code>webpack -p</code> 混淆压缩代码，并剔除死代码，测试如下：<br>刚刚测试了下，会删除死代码：<br>webpack.config.js：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="string">'./'</span>,</span><br><span class="line">    filename: <span class="string">'output.js'</span>,</span><br><span class="line">    publicPath: <span class="string">''</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>测试一：<br>index.js<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'tesst'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行 webpack -p：<br>输出了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WARNING <span class="keyword">in</span> output.js from UglifyJs</span><br><span class="line">Dropping unused <span class="keyword">function</span> <span class="built_in">test</span> [./index.js:<span class="number">1</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>打开 output.js 看到，除了 webpack 的一些代码，index.js 中的 test 函数并没有被打包进来，一位它没有执行或者输出，是死代码；</p>
<p>测试二：<br>给刚刚的 index.js 改变一下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'tesst'</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p>
<p>执行了 test 函数。<br>执行 webpack -p：<br>没有刚刚的 WARNING 输出，打开 output.js 看到，test 函数被打包了进来。</p>
<p>ps. 这里的 test 函数名被混淆了，但是可以看函数里面执行的 console.log(‘test’) 来判断函数是否被打包进来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="如何使用webpack">如何使用webpack</h1><p>本文章翻译自petehunt的webpack-howto教程，<a href="https://github.com/petehunt/webpack-howto" target="_blank" r]]>
    </summary>
    
      <category term="JavaScript" scheme="http://qiutc.me/tags/JavaScript/"/>
    
      <category term="webpack" scheme="http://qiutc.me/tags/webpack/"/>
    
      <category term="翻译" scheme="http://qiutc.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="webpack" scheme="http://qiutc.me/categories/webpack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS 伪类before/after content内容生成技术----纯CSS实现tooltip]]></title>
    <link href="http://qiutc.me/post/CSS-%E4%BC%AA%E7%B1%BBbefore-after-content%E5%86%85%E5%AE%B9%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF-%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0tooltip.html"/>
    <id>http://qiutc.me/post/CSS-伪类before-after-content内容生成技术-纯CSS实现tooltip.html</id>
    <published>2015-10-17T07:30:41.000Z</published>
    <updated>2016-05-10T03:50:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="一、介绍before/after">一、介绍before/after</h1><p>CSS中的before和after伪类选择器早在CSS2时就被引入，改属性被所有主流浏览器所支持了。<br>before和after顾名思义，分别指的是伪元素在元素前/后添加内容，默认他们是display是inline，但是可以使用CSS设置为block。<br>应用before/和after也比较简单，举个例子：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="tag">a</span><span class="pseudo">:after</span> <span class="rules">&#123;</span><br><span class="line">      <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">" after "</span></span></span>;</span><br><span class="line">      <span class="rule"><span class="attribute">display</span>:<span class="value">  block</span></span>;</span><br><span class="line">      <span class="rule"><span class="attribute">coloe</span>:<span class="value"> red</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>可以在浏览器看到，a标签元素后面多出了一段文字 after。（在CSS3中伪类元素使用是如a::after的，不过目前两者并无多大区别）。<br>（伪元素不可通过DOM使用，IE6/7对该属性不支持）</p>
<p>after和before伪元素有许多用处，还可以简化代码，比如可以写一个计数器、tip小三角形、清除浮动……特别在CSS3中新加的一些属性更是丰富了它的应用，这里有个小教程，用before/after伪元素来实现一个纯CSS3的tooltip。</p>
<h1 id="二、tooltip实现教程">二、tooltip实现教程</h1><p>这里我们主要是用草after/before伪元素content中的attr属性，先来看看实现后的样子：</p>
<h2 id="1-实现样式">1.实现样式</h2><p><img src="/img/after&amp;before-demo.png" alt="DEMO"></p>
<h2 id="2-代码">2.代码</h2><p>鼠标hover button之后，出现一个tooltip小标签。<br>代码先贴上：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css"></span><br><span class="line">        <span class="class">.btn</span> <span class="rules">&#123;</span><br><span class="line">            <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">200px</span> auto</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">10px</span> <span class="number">20px</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">20px</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#6bdf4e</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid <span class="hexcolor">#6bdf4e</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">cursor</span>:<span class="value"> pointer</span></span>;</span><br><span class="line">        &#125;</span></span><br><span class="line">        <span class="class">.btn</span><span class="pseudo">::after</span> <span class="rules">&#123;</span><br><span class="line">            <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="function">attr</span>(data-tip)</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">padding</span>:<span class="value"> <span class="number">5px</span> <span class="number">10px</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">50%</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">12px</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translateX</span>(-<span class="number">50%</span>)</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">16px</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#000</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#fff</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">cursor</span>:<span class="value"> default</span></span>;</span><br><span class="line">        &#125;</span></span><br><span class="line">        <span class="class">.btn</span><span class="pseudo">::before</span> <span class="rules">&#123;</span><br><span class="line">            <span class="rule"><span class="attribute">content</span>:<span class="value"> <span class="string">" "</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">50%</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">bottom</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">transform</span>:<span class="value"> <span class="function">translateX</span>(-<span class="number">50%</span>)</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">margin-bottom</span>:<span class="value"> <span class="number">3px</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">border-left</span>:<span class="value"> <span class="number">6px</span> solid transparent</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">border-right</span>:<span class="value"> <span class="number">6px</span> solid transparent</span></span>;</span><br><span class="line">            <span class="rule"><span class="attribute">border-top</span>:<span class="value"> <span class="number">9px</span> solid <span class="hexcolor">#000</span></span></span>;</span><br><span class="line">        &#125;</span></span><br><span class="line">        <span class="class">.btn</span><span class="pseudo">:hover</span><span class="pseudo">::after</span>,</span><br><span class="line">        <span class="class">.btn</span><span class="pseudo">:hover</span><span class="pseudo">::before</span> <span class="rules">&#123;</span><br><span class="line">            <span class="rule"><span class="attribute">display</span>:<span class="value"> block</span></span>;</span><br><span class="line">        &#125;</span></span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">button</span> <span class="attribute">class</span>=<span class="value">"btn"</span> <span class="attribute">data-tip</span>=<span class="value">"ToolTip"</span>&gt;</span>button<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-实现过程">3.实现过程</h2><ul>
<li>一. 创建一个标签，然后在标签内加上一个属性 data-[] = “ToolTip”,[]表示的是自定义的属性名称，引号里面是tooltip需要显示的内容。</li>
<li>二. 给标签加样式，position设置为relative，因为之后伪元素需要设置绝对定位来设置位置。</li>
<li>三. 给after加样式，after是需要显示的tooltip，通过content: attr(data-tip);拿到需要显示的内容，设置绝对定位，调整位置。</li>
<li>四. 给before加样式，before需要设置成一个小三角tip放在after下面。</li>
<li>五. 给after/before的display都设置为none。</li>
<li>六. 给需要tooltip的元素伪类选择hover时设置after/before的display为block，这里需要注意的是after/before默认display为inline，所以我们前面创建调试是display应该先设置为block。</li>
<li>七. 打开浏览器查看效果~</li>
</ul>
<h1 id="三、对于不支持伪元素的IE6/7">三、对于不支持伪元素的IE6/7</h1><p>解决方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $beforeAfter = <span class="function"><span class="keyword">function</span>(<span class="params">dom</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.querySelector || !dom &amp;&amp; dom.nodeType !== <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> content = dom.getAttribute(<span class="string">"data-content"</span>) || <span class="string">''</span>;     </span><br><span class="line">    <span class="keyword">var</span> before = <span class="built_in">document</span>.createElement(<span class="string">"before"</span>)</span><br><span class="line">        , after = <span class="built_in">document</span>.createElement(<span class="string">"after"</span>);</span><br><span class="line">    before.innerHTML = content;</span><br><span class="line">    after.innerHTML = content;</span><br><span class="line">    dom.insertBefore(before, dom.firstChild);</span><br><span class="line">    dom.appendChild(after);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="四、tip">四、tip</h1><p>关于after/before还有许多有趣有用的用法，感兴趣的同学可以研究研究哦~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="一、介绍before/after">一、介绍before/after</h1><p>CSS中的before和after伪类选择器早在CSS2时就被引入，改属性被所有主流浏览器所支持了。<br>before和after顾名思义，分别指的是伪元素在元素前/后添加内容，]]>
    </summary>
    
      <category term="CSS" scheme="http://qiutc.me/tags/CSS/"/>
    
      <category term="CSS" scheme="http://qiutc.me/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用hexo+github搭建静态博客]]></title>
    <link href="http://qiutc.me/post/%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2.html"/>
    <id>http://qiutc.me/post/使用hexo-github搭建静态博客.html</id>
    <published>2015-10-04T03:01:31.000Z</published>
    <updated>2016-05-10T03:52:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="认识hexo">认识hexo</h1><p>&#8195;&#8195;hexo是一款基于Node.js的静态博客框架，可以生成静态文件并且一键部署到github pages上，并且他可以使用markdown来编写文章，十分简单。</p>
<p>他有许多优点：</p>
<ul>
<li>快速：hexo基于Node.js，支持多进程，几百篇文章可以秒生成。</li>
<li>写文章流程：支持GitHub Flavored Markdown和所有Octopress的插件。</li>
<li>扩展性：Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less。</li>
</ul>
<p><em>这是一篇用hexo在github上面搭建博客的教程</em></p>
<hr>
<h1 id="安装：">安装：</h1><h2 id="系统环境：">系统环境：</h2><ul>
<li>系统： win10 64bit</li>
<li>编译器：<a href="http://www.sublimetext.com/" target="_blank" rel="external">sublime text 3</a>（可以看这篇文章）</li>
<li>编码： 把文本编码确定成 UTF-8</li>
</ul>
<h2 id="Git">Git</h2><ol>
<li>可以选择安装GitHub for Windows 或者 git 。</li>
<li>注册github，选择Repositories，然后new新建一个仓库，建好仓库之后选择settings，到GitHub Pages那一栏，选择Launch automatic page generator，接下去就是确定。</li>
<li>然后就是把仓库clone下来，关于怎么clone和使用git可以参考这篇文字。</li>
</ol>
<h2 id="nodejs">nodejs</h2><p>下载安装<a href="https://nodejs.org/" target="_blank" rel="external">nodejs</a>，nodejs安装后会自动带有npm包，如果嫌外网下npm下载包文件比较慢，可以使用淘宝的<a href="http://npm.taobao.org/" target="_blank" rel="external">cnpm</a>镜像。<br>nodejs安装好之后可以打开命令行（win+r，输入cmd，确定），<br>输入 node -v 查看nodejs版本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ v0.<span class="number">12.7</span> <span class="comment">##版本号</span></span><br></pre></td></tr></table></figure></p>
<p>输入 npm -v 查看npm版本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">$ v2.<span class="number">11.3</span> <span class="comment">##版本号</span></span><br></pre></td></tr></table></figure></p>
<p>到这里说明nodejs安装成功了。</p>
<h2 id="hexo">hexo</h2><p>打开命令行，我这里安装的是3.x版本（后面可能会有个小坑）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g <span class="operator">-d</span></span><br></pre></td></tr></table></figure></p>
<p>查看hexo的版本号：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo -v</span><br></pre></td></tr></table></figure></p>
<p>进入到我们clone的那个文件夹，执行命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></p>
<p>接着安装依赖包：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p>
<p>接着可以启动服务测试一下:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p>
<p>用浏览器打开<code>http://localhost:4000/</code>或者<code>http://127.0.0.1:4000/</code>就可以看到页面了。</p>
<hr>
<h1 id="Hexo的使用">Hexo的使用</h1><h2 id="目录和文件">目录和文件</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy       <span class="preprocessor">#需要部署的文件</span></span><br><span class="line">├── node_modules  <span class="preprocessor">#Hexo插件</span></span><br><span class="line">├── <span class="keyword">public</span>        <span class="preprocessor">#生成的静态网页文件</span></span><br><span class="line">├── scaffolds     <span class="preprocessor">#模板</span></span><br><span class="line">├── source        <span class="preprocessor">#博客正文和其他源文件, <span class="number">404</span> 、favicon 、CNAME</span></span><br><span class="line">|   ├── _drafts   <span class="preprocessor">#草稿</span></span><br><span class="line">|   └── _posts    <span class="preprocessor">#文章</span></span><br><span class="line">├── themes        <span class="preprocessor">#主题</span></span><br><span class="line">├── _config.yml   <span class="preprocessor">#全局配置文件</span></span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<p>（有些文件是在部署时才会产生的）</p>
<h2 id="全局站点配置文件_config-yml">全局站点配置文件_config.yml</h2><p>（yml语法严格，注意冒号后面必须加空格）<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># Site #站点信息</span></span><br><span class="line"><span class="label">title:</span> Hexo <span class="preprocessor">#博客标题</span></span><br><span class="line"><span class="label">subtitle:</span> 啦啦啦 <span class="preprocessor">#副标题</span></span><br><span class="line"><span class="label">description:</span> 哈哈哈 <span class="preprocessor">#描述</span></span><br><span class="line"><span class="label">author:</span> John Doe <span class="preprocessor">#作者</span></span><br><span class="line"><span class="label">language:</span> <span class="built_in">zh</span>-Hans <span class="preprocessor">#语言</span></span><br><span class="line"><span class="label">timezone:</span> Asia/Shanghai <span class="preprocessor">#时区</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># URL #链接格式</span></span><br><span class="line"><span class="label">url:</span> http://yoursite.com <span class="preprocessor">#博客网址</span></span><br><span class="line"><span class="label">root:</span> / <span class="preprocessor">#根目录</span></span><br><span class="line"><span class="label">permalink:</span> :year/:month/:day/:title/ <span class="preprocessor">#文章的链接格式</span></span><br><span class="line"><span class="label">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Directory #目录</span></span><br><span class="line"><span class="label">source_dir:</span> source <span class="preprocessor">#源文件</span></span><br><span class="line"><span class="label">public_dir:</span> public <span class="preprocessor">#生成的文件</span></span><br><span class="line"><span class="label">tag_dir:</span> tags <span class="preprocessor">#标签文件夹</span></span><br><span class="line"><span class="label">archive_dir:</span> archives <span class="preprocessor">#归档文件夹</span></span><br><span class="line"><span class="label">category_dir:</span> categories <span class="preprocessor">#分类文件夹</span></span><br><span class="line"><span class="label">code_dir:</span> downloads/code <span class="preprocessor">#下载文件</span></span><br><span class="line"><span class="label">i18n_dir:</span> :lang <span class="preprocessor">#国际化</span></span><br><span class="line"><span class="label">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Writing #写作</span></span><br><span class="line"><span class="label">new_post_name:</span> :title.md <span class="preprocessor">#文章标题</span></span><br><span class="line"><span class="label">default_layout:</span> post <span class="preprocessor">#模板</span></span><br><span class="line"><span class="label">titlecase:</span> false <span class="preprocessor">#标题是否换成小写</span></span><br><span class="line"><span class="label">external_link:</span> true <span class="preprocessor">#是否在新页面打开链接</span></span><br><span class="line"><span class="label">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="label">render_drafts:</span> false</span><br><span class="line"><span class="label">post_asset_folder:</span> false</span><br><span class="line"><span class="label">relative_link:</span> false</span><br><span class="line"><span class="label">future:</span> true</span><br><span class="line"><span class="label">highlight:</span></span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Category &amp; Tag #分类和标签</span></span><br><span class="line"><span class="label">default_category:</span> uncategorized</span><br><span class="line"><span class="label">category_map:</span></span><br><span class="line"><span class="label">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Date #时间日期格式</span></span><br><span class="line"><span class="label">date_format:</span> YYYY-MM-DD</span><br><span class="line"><span class="label">time_format:</span> HH:mm:ss</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Pagination #分页</span></span><br><span class="line"><span class="label">per_page:</span> <span class="number">10</span> <span class="preprocessor">#每页文章数</span></span><br><span class="line"><span class="label">pagination_dir:</span> page</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Extensions #插件和主题</span></span><br><span class="line"><span class="preprocessor">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line"><span class="preprocessor">## Themes: http://hexo.io/themes/</span></span><br><span class="line"><span class="label">theme:</span> landscape</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Deployment #部署配置</span></span><br><span class="line"><span class="preprocessor">## Docs: http://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="label">deploy:</span></span><br><span class="line">  type:</span><br></pre></td></tr></table></figure></p>
<h2 id="站点的_config-yml_配置">站点的_config.yml 配置</h2><h3 id="站点建立时间">站点建立时间</h3><p>例如 <code>© 2015 - 2016</code><br>在文件添加：<br><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">since</span>: <span class="string">2015</span></span><br></pre></td></tr></table></figure></p>
<h3 id="头像设置">头像设置</h3><p>/images/avatar.jpg //头像图片放置在主题的 source/images/<br>在文件添加：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">avatar:</span> <span class="regexp">/images/</span>avatar.png</span><br></pre></td></tr></table></figure></p>
<h3 id="侧边栏社交链接">侧边栏社交链接</h3><p>增加 social<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># Social links</span></span><br><span class="line">social:</span><br><span class="line">  GitHub: https:<span class="comment">//github.com/tongchengqiu</span></span><br><span class="line">  Twitter: https:<span class="comment">//twitter.com/tongchengqiu</span></span><br><span class="line">  Zhihu: http:<span class="comment">//www.zhihu.com/people/tongchengqiu</span></span><br></pre></td></tr></table></figure></p>
<h2 id="友情链接">友情链接</h2><h3 id="标题">标题</h3><p>links_title: 友情链接</p>
<h3 id="链接">链接</h3><p>links:<br>  Hexo: <a href="http://hexo.io/" target="_blank" rel="external">http://hexo.io/</a><br>  Lmintlcx: <a href="http://blog.lmintlcx.com/" target="_blank" rel="external">http://blog.lmintlcx.com/</a></p>
<h2 id="命令的使用">命令的使用</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">hexo help <span class="preprocessor">#查看帮助</span></span><br><span class="line">hexo init <span class="preprocessor">#初始化目录</span></span><br><span class="line">hexo <span class="keyword">new</span> <span class="string">"postName"</span> <span class="preprocessor">#新建文章</span></span><br><span class="line">hexo <span class="keyword">new</span> page <span class="string">"pageName"</span> <span class="preprocessor">#新建页面</span></span><br><span class="line">hexo generate <span class="preprocessor">#生成网页, 可以在public目录查看整个网站的文件</span></span><br><span class="line">hexo <span class="keyword">server</span> <span class="preprocessor">#本地预览,'Ctrl+C'关闭</span></span><br><span class="line">hexo deploy <span class="preprocessor">#部署.deploy目录</span></span><br><span class="line">hexo clean <span class="preprocessor">#清除缓存, 建议每次执行命令前先清理缓存</span></span><br><span class="line">hexo n == hexo <span class="keyword">new</span></span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo <span class="keyword">server</span></span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>
<h2 id="写文章">写文章</h2><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"文章标题"</span></span><br></pre></td></tr></table></figure>
<p>然后到_post 目录下打开 文章标题.md<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date: <span class="number">2015</span>-<span class="number">10</span>-<span class="number">3</span> <span class="number">11</span>:<span class="number">11</span>:<span class="number">11</span></span><br><span class="line">tags:</span><br><span class="line">- 标签<span class="number">1</span></span><br><span class="line">- 标签<span class="number">2</span></span><br><span class="line">- 标签<span class="number">3</span></span><br><span class="line">categories: [分类<span class="number">1</span>,分类<span class="number">2</span>,分类<span class="number">3</span>]</span><br><span class="line">---</span><br><span class="line">正文, 使用 Markdown 语法书写</span><br></pre></td></tr></table></figure></p>
<p>编辑后可以先预览<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="title">hexo</span> clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p>
<p>然后打开浏览器预览</p>
<h2 id="部署上传更新">部署上传更新</h2><p>以github为例，打开站点根目录下的_config.yml文件，找到deploy部分，更改配置<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:test/test.git #在仓库找到该仓库的ssh</span><br><span class="line">  <span class="attribute">branch</span>: github-pages #分支，这里为github-pages</span><br></pre></td></tr></table></figure></p>
<p>然后就可以部署了，在文件根目录执行命令行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>这里有可能会报个错误<code>ERROR Deployer not found : git</code><br>这里需要安装一个包<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>然后就可以继续执行<code>deploy</code>了，第一次部署可能会有点慢，可以耐心等候哦。<br>成功之后可以继续打开仓库的settings，在GitHub Pages会看到 Your site is published at <a href="http://qiutongcheng.com.（如果还没有绑定域名就会是github给你分配的url哦）" target="_blank" rel="external">http://qiutongcheng.com.（如果还没有绑定域名就会是github给你分配的url哦）</a><br>就可以打开链接看看咯~</p>
<hr>
<h1 id="绑定域名">绑定域名</h1><p>当然我们的个人博客当然希望绑定自己的一个个性域名咯~</p>
<h2 id="注册购买顶级域名">注册购买顶级域名</h2><p>国内购买可以上<a href="http://wanwang.aliyun.com/" target="_blank" rel="external">万网</a>；<br>嫌国内不好可以用<a href="https://www.godaddy.com/" target="_blank" rel="external">godaddy</a>。</p>
<h2 id="DNS设置">DNS设置</h2><p>在购买域名的后台管理设置DNS<br>主机记录@, 类型A, 记录值192.30.252.153<br>主机记录www, 类型A, 记录值192.30.252.153</p>
<h2 id="在github绑定域名">在github绑定域名</h2><p>在source文件夹下面新建 CNAME（不要后缀），内容输入要绑定的域名，比如<br><code>qiutongcheng.com</code>或者<code>www.qiutongcheng.com</code>。</p>
<h2 id="绑定子域名">绑定子域名</h2><p>比如要绑定 <code>blog.qiutongcheng.com</code> ：<br>吧CNAME内容改成 <code>blog.qiutongcheng.com</code><br>DNS设置里面添加 主机记录有blog，类型 CNAME ，记录值 <code>blog.qiutongcheng.com</code></p>
<hr>
<h1 id="主题">主题</h1><p>hexo的<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">(主题列表)</a><br>我使用的是 NexT 主题，这里一NexT主题为例剖析一下吧。</p>
<h2 id="下载与使用">下载与使用</h2><p>执行命令行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next <span class="comment">#主题的地址</span></span><br></pre></td></tr></table></figure></p>
<p>也可以下载zip文件，然后手动解压到themes目录下<br>配置全局站点文件<code>_config.yml</code><br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">themes: <span class="keyword">next</span> <span class="preprocessor">#主题文件夹名</span></span><br></pre></td></tr></table></figure></p>
<h2 id="主题的目录结构">主题的目录结构</h2><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── languages          <span class="preprocessor">#国际化</span></span><br><span class="line">|   ├── <span class="keyword">default</span>.yml    <span class="preprocessor">#默认</span></span><br><span class="line">|   └── zh-CN.yml      <span class="preprocessor">#中文</span></span><br><span class="line">├── <span class="keyword">layout</span>             <span class="preprocessor">#布局</span></span><br><span class="line">|   ├── _partial       <span class="preprocessor">#局部的布局</span></span><br><span class="line">|   └── _widget        <span class="preprocessor">#小挂件的布局</span></span><br><span class="line">├── script             <span class="preprocessor">#js脚本</span></span><br><span class="line">├── source             <span class="preprocessor">#源代码文件</span></span><br><span class="line">|   ├── css            <span class="preprocessor">#CSS</span></span><br><span class="line">|   |   ├── _base      <span class="preprocessor">#基础CSS</span></span><br><span class="line">|   |   ├── _partial   <span class="preprocessor">#局部CSS</span></span><br><span class="line">|   |   ├── fonts      <span class="preprocessor">#字体</span></span><br><span class="line">|   |   ├── images     <span class="preprocessor">#图片</span></span><br><span class="line">|   |   └── style.styl <span class="preprocessor">#style.css</span></span><br><span class="line">|   ├── fancybox       <span class="preprocessor">#fancybox</span></span><br><span class="line">|   └── js             <span class="preprocessor">#js</span></span><br><span class="line">├── _config.yml        <span class="preprocessor">#主题配置文件</span></span><br><span class="line">└── README.md          <span class="preprocessor">#主题介绍</span></span><br></pre></td></tr></table></figure>
<h2 id="主题配置文件_config-yml文件">主题配置文件_config.yml文件</h2><p>打开主题目录下的_config.yml文件<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">menu: #菜单</span><br><span class="line">  home: / #首页</span><br><span class="line">  archives: /archives #归档</span><br><span class="line">  #commonweal: /<span class="number">404.</span>html #<span class="number">404</span>页面</span><br><span class="line">  #tags: /tags #标签</span><br><span class="line">  #categories: /categories #分类</span><br><span class="line">  about: /about #关于</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 小图标</span></span><br><span class="line">favicon: /favicon.ico</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 默认关键词</span></span><br><span class="line">keywords: <span class="string">"~"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 留空使用默认的, false 禁用, 也可以写指定的地址</span></span><br><span class="line">rss:</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Icon fonts</span></span><br><span class="line"><span class="preprocessor"># default | linecons | fifty-shades | feather</span></span><br><span class="line">icon_font: <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 代码高亮主题 https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="preprocessor"># normal | night | night eighties | night blue | night bright</span></span><br><span class="line">highlight_theme: normal</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># MathJax Support #数学公式</span></span><br><span class="line">mathjax: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Schemes #启用主题中的主题Mist</span></span><br><span class="line">scheme: Mist</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 侧边栏</span></span><br><span class="line"><span class="preprocessor">#  - post    只在文章页面显示</span></span><br><span class="line"><span class="preprocessor">#  - always  所有页面显示</span></span><br><span class="line"><span class="preprocessor">#  - hide    隐藏</span></span><br><span class="line">sidebar: always</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 自动滚动到"阅读更多"标记的下面</span></span><br><span class="line">scroll_to_more: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 自动给目录添加序号</span></span><br><span class="line">toc_list_number: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 自动截取摘要</span></span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: <span class="literal">false</span></span><br><span class="line">  length: <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Lato 字体</span></span><br><span class="line">use_font_lato: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Make duoshuo show UA</span></span><br><span class="line"><span class="preprocessor"># user_id must NOT be null when admin_enable is true!</span></span><br><span class="line"><span class="preprocessor"># you can visit http://dev.duoshuo.com get duoshuo user id.</span></span><br><span class="line">duoshuo_info:</span><br><span class="line">  ua_enable: <span class="literal">true</span></span><br><span class="line">  admin_enable: <span class="literal">false</span></span><br><span class="line">  user_id: <span class="number">0</span></span><br><span class="line">  #admin_nickname: ROOT</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">## DO NOT EDIT THE FOLLOWING SETTINGS</span></span><br><span class="line"><span class="preprocessor">## UNLESS YOU KNOW WHAT YOU ARE DOING</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 动画</span></span><br><span class="line">use_motion: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Fancybox 看图插件</span></span><br><span class="line">fancybox: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Static files</span></span><br><span class="line">vendors: vendors</span><br><span class="line">css: css</span><br><span class="line">js: js</span><br><span class="line">images: images</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># Theme version</span></span><br><span class="line">version: <span class="number">0.4</span><span class="number">.5</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="选择Scheme">选择Scheme</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">scheme</span>: <span class="string">Mist</span></span><br></pre></td></tr></table></figure>
<h3 id="添加网站图标">添加网站图标</h3><p>将网站图标文件 favicon.ico 放到source目录下面<br>修改主题_config.yml文件<br><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">favicon</span>: <span class="string">/favicon.ico</span></span><br></pre></td></tr></table></figure></p>
<h3 id="菜单设置">菜单设置</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">menu</span>:</span><br><span class="line">  <span class="attribute">home</span>: /</span><br><span class="line">  <span class="attribute">archives</span>: /archives</span><br><span class="line">  <span class="attribute">categories</span>: /categories</span><br><span class="line">  <span class="attribute">tags</span>: /tags</span><br><span class="line">  <span class="attribute">commonweal</span>: /<span class="number">404</span>.html</span><br><span class="line">  <span class="attribute">about</span>: /about</span><br></pre></td></tr></table></figure>
<h3 id="标签页面">标签页面</h3><p>执行命令行<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page <span class="string">"tags"</span></span><br></pre></td></tr></table></figure></p>
<p>到生成的页面文件里<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2015-10-4 22:37:08</span><br><span class="line">type: "tags"</span><br><span class="line"><span class="header">comments: false    #关闭评论（建议）</span><br><span class="line">---</span></span><br></pre></td></tr></table></figure></p>
<h3 id="分类页面">分类页面</h3><p>执行命令行<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page <span class="string">"categories"</span></span><br></pre></td></tr></table></figure></p>
<p>到生成的页面文件里<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2015-10-4 22:37:08</span><br><span class="line">type: "categories"</span><br><span class="line"><span class="header">comments: false    #关闭评论（建议）</span><br><span class="line">---</span></span><br></pre></td></tr></table></figure></p>
<h3 id="关于页面">关于页面</h3><p>执行命令行<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page <span class="string">"about"</span></span><br></pre></td></tr></table></figure></p>
<p>到生成的页面文件里<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">title: about</span><br><span class="line">date: 2015-10-4 22:37:08</span><br><span class="line">type: "about"</span><br><span class="line"><span class="header">comments: false    #关闭评论（建议）</span><br><span class="line">---</span></span><br></pre></td></tr></table></figure></p>
<h3 id="RSS链接">RSS链接</h3><p>编辑主题的_config.yml文件<br>禁止：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">rss:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="label">rss:</span></span><br></pre></td></tr></table></figure></p>
<p>需要安装插件 hexo-generator-feed ，继续看下面有安装插件教程<br>自定义：<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="label">rss:</span> url<span class="preprocessor">#自定义的地址</span></span><br></pre></td></tr></table></figure></p>
<h3 id="侧边栏设置">侧边栏设置</h3><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="label">sidebar:</span> post  <span class="preprocessor">#只在文章页面自动显示</span></span><br><span class="line"><span class="preprocessor">#sidebar: always #在所以页面自动显示</span></span><br><span class="line"><span class="preprocessor">#sidebar: hide #全隐藏</span></span><br></pre></td></tr></table></figure>
<h3 id="腾讯公益_404_页面">腾讯公益 404 页面</h3><p>source 目录下新建 404.html 页面<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"content-type"</span> <span class="attribute">content</span>=<span class="value">"text/html;charset=utf-8;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"X-UA-Compatible"</span> <span class="attribute">content</span>=<span class="value">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"robots"</span> <span class="attribute">content</span>=<span class="value">"all"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"robots"</span> <span class="attribute">content</span>=<span class="value">"index,follow"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"http://www.qq.com/404/search_children.js"</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span> <span class="attribute">homePageUrl</span>=<span class="value">"your-site-url"</span> <span class="attribute">homePageName</span>=<span class="value">"回到我的主页"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="首页文章摘录">首页文章摘录</h3><p>在主题配置文件添加<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  length: <span class="number">150</span> <span class="preprocessor">#默认截取的长度为 <span class="number">150</span> 字符</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="扩展">扩展</h1><h2 id="评论系统">评论系统</h2><h3 id="多说评论系统">多说评论系统</h3><p>注册<a href="http://duoshuo.com/" target="_blank" rel="external">多说</a>，配置域名站点域名 xxx.duoshuo.com<br>在站点配置文件添加：<br><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">duoshuo_shortname</span>: <span class="string">xxx</span></span><br></pre></td></tr></table></figure></p>
<h2 id="设置网站统计">设置网站统计</h2><h3 id="百度统计">百度统计</h3><p>登陆注册<a href="http://tongji.baidu.com/web/welcome/login" target="_blank" rel="external">百度统计</a>，配置后到代码获取页面，<br>找到代码里 <code>hm?js</code> 复制后面一串字符串ID  xxx<br>在站点配置文件添加：<br><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">baidu_analytics</span>: <span class="string">xxxxxxxxxxxxxxxx</span></span><br></pre></td></tr></table></figure></p>
<h2 id="分享">分享</h2><h3 id="百度分享">百度分享</h3><p>在站点配置文件添加：<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># 百度分享服务</span></span><br><span class="line">baidushare: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="多说分享">多说分享</h3><p>在站点配置文件添加：<br><figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor"># 多说分享服务</span></span><br><span class="line">duoshuo_share: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="版权协议">版权协议</h2><p>在站点配置文件添加：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"># Creative Commons 4.0 International License.</span><br><span class="line"># http:<span class="comment">//creativecommons.org/</span></span><br><span class="line"># Available: <span class="keyword">by</span> | <span class="keyword">by</span>-nc | <span class="keyword">by</span>-nc-nd | <span class="keyword">by</span>-nc-<span class="keyword">sa</span> | <span class="keyword">by</span>-nd | <span class="keyword">by</span>-<span class="keyword">sa</span> | zero</span><br><span class="line">creative_commons: <span class="keyword">by</span>-nc-<span class="keyword">sa</span></span><br></pre></td></tr></table></figure></p>
<h2 id="网站访问量统计">网站访问量统计</h2><p>使用 <a href="http://service.ibruce.info/" target="_blank" rel="external">不蒜子</a> 提供的服务<br>算法a: pv的方式, 单个用户连续点击n篇文章, 记录n次访问量.<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_container_site_pv"</span>&gt;</span></span><br><span class="line">    本站总访问量<span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>次</span><br><span class="line"><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>算法b: uv的方式, 单个用户连续点击n篇文章, 只记录1次访客数.<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_container_site_uv"</span>&gt;</span></span><br><span class="line">  本站访客数<span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>人次</span><br><span class="line"><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>找到themes/next/layout/partials/footer.wsig文件<br>在最后一行前面添加<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">async</span> <span class="attribute">src</span>=<span class="value">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_container_site_pv"</span>&gt;</span></span><br><span class="line">    本站总访问量<span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>次</span><br><span class="line"><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="网站运行时间">网站运行时间</h2><p>在最后一行前面添加<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="keyword">var</span> birthDay = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"11/20/2014"</span>);</span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> duration = now.getTime() - birthDay.getTime();</span><br><span class="line"><span class="keyword">var</span> total= <span class="built_in">Math</span>.floor(duration / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>));</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"showDays"</span>).innerHTML = <span class="string">"本站已运行 "</span>+total+<span class="string">" 天"</span>;</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">id</span>=<span class="value">"showDays"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="认识hexo">认识hexo</h1><p>&#8195;&#8195;hexo是一款基于Node.js的静态博客框架，可以生成静态文件并且一键部署到github pages上，并且他可以使用markdown来编写文章，十分简单。</p>
<p>他有许多优点：</]]>
    </summary>
    
      <category term="hexo" scheme="http://qiutc.me/tags/hexo/"/>
    
      <category term="hexo" scheme="http://qiutc.me/categories/hexo/"/>
    
  </entry>
  
</feed>
